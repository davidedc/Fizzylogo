// Generated by CoffeeScript 1.12.7
(function() {
  var DEBUG_STRINGIFICATION_CHECKS, FLAccessUpperContext, FLAccessUpperContextClass, FLBoolean, FLBooleanClass, FLBreak, FLBreakClass, FLClass, FLClassClass, FLClasses, FLConsole, FLConsoleClass, FLContext, FLDone, FLDoneClass, FLEvaluationsCounter, FLEvaluationsCounterClass, FLException, FLExceptionClass, FLFakeCatch, FLFakeCatchClass, FLFakeElse, FLFakeElseClass, FLFor, FLForClass, FLForever, FLForeverClass, FLIfFallThrough, FLIfFallThroughClass, FLIfThen, FLIfThenClass, FLIn, FLInClass, FLList, FLListClass, FLNil, FLNilClass, FLNot, FLNotClass, FLNumber, FLNumberClass, FLObjects, FLPause, FLPauseClass, FLQuote, FLQuoteClass, FLRepeat1, FLRepeat1Class, FLRepeat2, FLRepeat2Class, FLReturn, FLReturnClass, FLString, FLStringClass, FLThrow, FLThrowClass, FLTo, FLToClass, FLToken, FLTokenClass, FLTry, FLTryClass, FLWorkspace, FLWorkspaceClass, Fizzylogo, StringFromValidID, ValidIDfromString, addDefaultMethods, allClasses, bootClasses, clearClasses, commonSimpleValueEqualityFunction, commonSimpleValueInequalityFunction, environmentErrors, environmentPrintout, flContexts, flTokenize, indentation, initBootClasses, initContext, injectStrings, keyStr, linearize, outerMostContext, quickReset, rWorkspace, removeComments, removeStrings, repeatFunctionContinuation, reset, run, sortFirstArrayAccordingToSecond, stringsTable_TO_CHECK_CONVERTIONS, textOutputElement, tokenizeCommand,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Fizzylogo = {};

  (typeof exports !== "undefined" && exports !== null ? exports : this).Fizzylogo = Fizzylogo;

  repeatFunctionContinuation = null;

  outerMostContext = null;

  DEBUG_STRINGIFICATION_CHECKS = true;

  if (DEBUG_STRINGIFICATION_CHECKS) {
    stringsTable_TO_CHECK_CONVERTIONS = {};
  }

  indentation = function() {
    return "";
  };

  Array.prototype.jsArrayPush = function(element) {
    return this.push(element);
  };

  keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789Γಠ_';

  ValidIDfromString = function(input) {
    var chr1, chr2, chr3, enc1, enc2, enc3, enc4, i, output, utf8_encode;
    if (/^([A-Z_][0-9A-Z_$]*)$/gi.test(input)) {
      return input;
    }
    utf8_encode = function(string) {
      var c, n, utftext;
      string = string.replace(/\r\n/g, '\n');
      utftext = '';
      n = 0;
      while (n < string.length) {
        c = string.charCodeAt(n);
        if (c < 128) {
          utftext += String.fromCharCode(c);
        } else if (c > 127 && c < 2048) {
          utftext += String.fromCharCode(c >> 6 | 192);
          utftext += String.fromCharCode(c & 63 | 128);
        } else {
          utftext += String.fromCharCode(c >> 12 | 224);
          utftext += String.fromCharCode(c >> 6 & 63 | 128);
          utftext += String.fromCharCode(c & 63 | 128);
        }
        n++;
      }
      return utftext;
    };
    output = '';
    i = 0;
    input = utf8_encode(input);
    while (i < input.length) {
      chr1 = input.charCodeAt(i++);
      chr2 = input.charCodeAt(i++);
      chr3 = input.charCodeAt(i++);
      enc1 = chr1 >> 2;
      enc2 = (chr1 & 3) << 4 | chr2 >> 4;
      enc3 = (chr2 & 15) << 2 | chr3 >> 6;
      enc4 = chr3 & 63;
      if (isNaN(chr2)) {
        enc3 = enc4 = 64;
      } else if (isNaN(chr3)) {
        enc4 = 64;
      }
      output = output + keyStr.charAt(enc1) + keyStr.charAt(enc2) + keyStr.charAt(enc3) + keyStr.charAt(enc4);
    }
    return "$" + output;
  };

  StringFromValidID = function(input) {
    var a, b, c, d, e, f, g, i, output, utf8_decode;
    if (/^([A-Z_][0-9A-Z_$]*)$/gi.test(input)) {
      return input;
    }
    utf8_decode = function(string) {
      var charCode, i, output;
      output = '';
      i = 0;
      charCode = 0;
      while (i < string.length) {
        charCode = string.charCodeAt(i);
        if (charCode < 128) {
          output += String.fromCharCode(charCode);
          i++;
        } else if (charCode > 191 && charCode < 224) {
          output += String.fromCharCode((charCode & 31) << 6 | string.charCodeAt(i + 1) & 63);
          i += 2;
        } else {
          output += String.fromCharCode((charCode & 15) << 12 | (string.charCodeAt(i + 1) & 63) << 6 | string.charCodeAt(i + 2) & 63);
          i += 3;
        }
      }
      return output;
    };
    input = input.replace(/[^ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789Γಠ_]/g, '');
    input = input.replace(/^\$/, '');
    output = '';
    i = 0;
    while (i < input.length) {
      d = keyStr.indexOf(input.charAt(i++));
      e = keyStr.indexOf(input.charAt(i++));
      f = keyStr.indexOf(input.charAt(i++));
      g = keyStr.indexOf(input.charAt(i++));
      a = d << 2 | e >> 4;
      b = (e & 15) << 4 | f >> 2;
      c = (f & 3) << 6 | g;
      output += String.fromCharCode(a);
      if (f !== 64) {
        output += String.fromCharCode(b);
      }
      if (g !== 64) {
        output += String.fromCharCode(c);
      }
    }
    return utf8_decode(output);
  };

  sortFirstArrayAccordingToSecond = function(targetData, refData) {
    var indices, j, ref, results;
    indices = (function() {
      results = [];
      for (var j = 0, ref = targetData.length; 0 <= ref ? j < ref : j > ref; 0 <= ref ? j++ : j--){ results.push(j); }
      return results;
    }).apply(this);
    indices.sort(function(indexA, indexB) {
      if (refData[indexA] < refData[indexB]) {
        return -1;
      } else if (refData[indexA] > refData[indexB]) {
        return 1;
      }
      return 0;
    });
    return indices.map(function(index) {
      return targetData[index];
    });
  };

  allClasses = [];

  tokenizeCommand = function(command) {
    command = command.replace(/'[ ]*s[\s]/g, ".");
    command = command.replace(/\(/g, " ( ");
    command = command.replace(/\)/g, " ) ");
    command = command.replace(/\[/g, " [ ");
    command = command.replace(/\]/g, " ] ");
    command = command.replace(/;/g, " ; ");
    command = command.replace(/@([^\]);\s])/g, " self . $1");
    command = command.replace(/@/g, " self ");
    command = command.replace(/([0-9]*\.[0-9]+([eE][- ]?[0-9]*)?)|([^+\-^*\/()=←⇒.!%])([+\-^*\/()=←⇒.!%]+)/g, "$1$3 $4 ");
    command = command.replace(/([+\-^*\/()=←⇒!%])([^+\-^*\/()=←⇒!%])/g, "$1 $2");
    command = command.replace(/([+\-^*\/=←⇒!%_])[ ]+_/g, "$1_ ");
    command = command.replace(/'/g, " ' ");
    command = command.replace(/:/g, " : ");
    command = command.replace(/[ ]+/g, " ");
    return command = command.trim();
  };

  removeComments = function(code) {
    return code.replace(/(^)\/\*[\s\S]*?\*\/\n?|([^\\\n])\/\*[\s\S]*?\*\/|(^)\/\/.*$\n|([^\\\n])\/\/.*$|\n\/\/.*$|\n\/\*[\s\S]*?\*\n/gm, "$1$2$3$4");
  };

  removeStrings = function(code) {
    var codeWithoutStrings;
    codeWithoutStrings = code.replace(/"((?:[^"\\\n]|\\.)*)"/g, function(all, quoted) {
      if (DEBUG_STRINGIFICATION_CHECKS) {
        stringsTable_TO_CHECK_CONVERTIONS[ValidIDfromString(quoted)] = quoted;
      }
      return "$STRING_TOKEN_" + (ValidIDfromString(quoted));
    });
    return codeWithoutStrings;
  };

  injectStrings = function(code) {
    code = code.replace(/\$STRING_TOKEN_([\$a-zA-Z0-9_]+)/g, function(all, index) {
      var val;
      val = StringFromValidID(index);
      if (DEBUG_STRINGIFICATION_CHECKS) {
        if (val !== stringsTable_TO_CHECK_CONVERTIONS[index]) {
          throw "ERROR cannot get back string from ID, got back: " + StringFromValidID(index);
        }
      }
      return val;
    });
    return code;
  };

  linearize = function(code) {
    var actualLineTabs, correctedIndentationDifference, correctedLineTabs, eachLine, j, k, l, leftOrRightOrAligned, line, linesWithBlockStart, match, outputSource, ref, ref1, rx, sourceByLine, startOfPreviousLine, startOfThisLine, unclosedParens;
    sourceByLine = code.split("\n");
    startOfPreviousLine = "";
    linesWithBlockStart = [];
    unclosedParens = 0;
    outputSource = "";
    actualLineTabs = [];
    correctedLineTabs = [];
    for (eachLine = j = 0, ref = sourceByLine.length; 0 <= ref ? j < ref : j > ref; eachLine = 0 <= ref ? ++j : --j) {
      line = sourceByLine[eachLine];
      rx = RegExp("^(﹍*)", 'gm');
      match = rx.exec(line);
      if (eachLine === 0) {
        outputSource += " " + line;
        actualLineTabs.push(0);
        correctedLineTabs.push(0);
        continue;
      }
      startOfThisLine = match[1];
      leftOrRightOrAligned = startOfThisLine.length - actualLineTabs[actualLineTabs.length - 1];
      actualLineTabs.push(startOfThisLine.length);
      console.log("linearize startOfThisLine: " + startOfThisLine + " " + startOfThisLine.length + " difference in alignment: " + leftOrRightOrAligned + " content: " + line);
      if (leftOrRightOrAligned === 0) {
        correctedIndentationDifference = 0;
        outputSource += " ; " + line;
      } else if (leftOrRightOrAligned > 0) {
        correctedIndentationDifference = 1;
        console.log("linearize adding a ( ");
        outputSource += (Array(correctedIndentationDifference + 1).join("(")) + line;
      } else {
        for (k = l = ref1 = actualLineTabs.length - 2; ref1 <= 0 ? l <= 0 : l >= 0; k = ref1 <= 0 ? ++l : --l) {
          console.log(" k: " + k + " checking line " + sourceByLine[k] + " for alignment ");
          if (actualLineTabs[k] <= startOfThisLine.length) {
            console.log("line " + sourceByLine[k] + " is aligned with me and the corrected tabs for that were: " + correctedLineTabs[k]);
            correctedIndentationDifference = correctedLineTabs[k] - correctedLineTabs[correctedLineTabs.length - 1];
            break;
          }
        }
        console.log("linearize adding " + (-correctedIndentationDifference) + " ) ");
        outputSource += (Array(-correctedIndentationDifference + 1).join(")")) + line;
      }
      unclosedParens += correctedIndentationDifference;
      correctedLineTabs.push(unclosedParens);
    }
    outputSource += Array(unclosedParens + 1).join(")");
    return outputSource.replace(/﹍/g, "");
  };

  flTokenize = function(command) {
    var eachToken, j, len, listsStack, nestedList, simpleTokenization;
    listsStack = [];
    listsStack.jsArrayPush(FLList.createNew());
    command = command.replace(/\\\n﹍*/g, " ");
    command = removeComments(command);
    command = removeStrings(command);
    console.log("codeWithoutStrings: " + command);
    command = linearize(command);
    console.log("linearized command: " + command);
    console.log("command before replacements: " + command);
    command = tokenizeCommand(command);
    console.log("command after replacements: " + command);
    simpleTokenization = command.split(" ");
    for (j = 0, len = simpleTokenization.length; j < len; j++) {
      eachToken = simpleTokenization[j];
      console.log("eachToken: " + eachToken);
      if (/\$STRING_TOKEN_([\$a-zA-Z0-9_]+)/g.test(eachToken)) {
        console.log(eachToken + " is a string literal");
        listsStack[listsStack.length - 1] = listsStack[listsStack.length - 1].flListImmutablePush(FLToken.createNew(eachToken));
      } else if (/^\($/.test(eachToken)) {
        nestedList = FLList.createNew();
        listsStack.jsArrayPush(nestedList);
      } else if (/^\)$/.test(eachToken)) {
        nestedList = listsStack.pop();
        listsStack[listsStack.length - 1] = listsStack[listsStack.length - 1].flListImmutablePush(nestedList);
      } else {
        console.log(eachToken + " is something else");
        listsStack[listsStack.length - 1] = listsStack[listsStack.length - 1].flListImmutablePush(FLToken.createNew(eachToken));
      }
    }
    return listsStack[listsStack.length - 1];
  };

  FLObjects = (function() {
    FLObjects.prototype.flClass = null;

    FLObjects.prototype.instanceVariablesDict = null;

    function FLObjects(flClass) {
      this.flClass = flClass;
      this.instanceVariablesDict = {};
      this.instanceVariablesDict[ValidIDfromString("class")] = this.flClass;
    }

    FLObjects.prototype.isClass = function() {
      return this.name != null;
    };

    FLObjects.prototype.methodsHolder = function() {
      if (this.isClass()) {
        return this;
      } else {
        return this.flClass;
      }
    };

    FLObjects.prototype.flToString = function() {
      if (this.isClass()) {
        if (this.name === "") {
          return "[anonymous class (an object of class Class)]";
        } else {
          return "[class \"" + this.name + "\" (an object of class Class)]";
        }
      } else if (this.flClass.name !== "") {
        return "[object of class \"" + this.flClass.name + "\"]";
      } else {
        return "[object of anonymous class]";
      }
    };

    FLObjects.prototype.flToStringForList = function() {
      return this.flToString();
    };

    FLObjects.prototype["eval"] = function*(theContext) {
      yield;
      return this;
    };

    FLObjects.prototype.findSignatureBindParamsAndMakeCall = function*(methodInvocationToBeChecked, theContext) {
      var classContainingMethods, contextToBeReturned, eachElementOfInvocation, eachElementOfSignature, eachSignature, eachSignatureIndex, j, methodInvocation, newContext, originalMethodInvocationStart, paramToken, ref, ref1, ref2, ref3, ref4, returnedContext, soFarEverythingMatched, valueToBeBound;
      console.log("evaluation " + indentation() + "  !!! looking up method invocation " + methodInvocationToBeChecked.flToString() + " with signatures!");
      console.log("evaluation " + indentation() + "  !!! looking up method invocation, is method empty? " + methodInvocationToBeChecked.isEmpty());
      console.log("evaluation " + indentation() + "  I am: " + this.value);
      console.log("evaluation " + indentation() + "  matching - my class patterns: ");
      flContexts.jsArrayPush(null);
      classContainingMethods = this.methodsHolder();
      for (eachSignatureIndex = j = 0, ref = classContainingMethods.msgPatterns.length; 0 <= ref ? j < ref : j > ref; eachSignatureIndex = 0 <= ref ? ++j : --j) {
        eachSignature = classContainingMethods.msgPatterns[eachSignatureIndex];
        methodInvocation = methodInvocationToBeChecked;
        flContexts.pop();
        newContext = new FLContext(theContext, this);
        flContexts.jsArrayPush(newContext);
        soFarEverythingMatched = true;
        originalMethodInvocationStart = methodInvocation.cursorStart;
        while (!(eachSignature.isEmpty() || methodInvocation.isEmpty())) {
          console.log("evaluation " + indentation() + "  matching: - next signature piece: " + eachSignature.flToString() + " is token: " + " with: " + methodInvocation.flToString());
          ref1 = eachSignature.nextElement(), eachElementOfSignature = ref1[0], eachSignature = ref1[1];
          if (eachElementOfSignature.flClass !== FLList && eachElementOfSignature.flClass !== FLToken) {
            theContext.throwing = true;
            theContext.returned = FLException.createNew("signature of a method should only contain tokens or lists. Found instead: " + eachElementOfSignature.flToString() + " . Perhaps some variable in the signature has been closed?");
            return [theContext, methodInvocationToBeChecked];
          }
          if (eachElementOfSignature.flClass === FLToken) {
            ref2 = methodInvocation.nextElement(), eachElementOfInvocation = ref2[0], methodInvocation = ref2[1];
            if (eachElementOfInvocation.flClass === FLToken) {
              if (eachElementOfSignature.value === eachElementOfInvocation.value) {
                console.log("evaluation " + indentation() + "  matching - token matched: " + eachElementOfSignature.flToString());
                continue;
              } else {
                soFarEverythingMatched = false;
                break;
              }
            } else {
              soFarEverythingMatched = false;
              break;
            }
          } else {
            console.log("evaluation " + indentation() + "  matching - getting the token inside the parameter: " + eachElementOfSignature.flToString());
            paramToken = eachElementOfSignature.getParamToken();
            console.log("evaluation " + indentation() + "  matching - token inside the parameter: " + paramToken.flToString());
            if (eachElementOfSignature.isEvaluatingParam()) {
              console.log("evaluation " + indentation() + "  matching - need to evaluate next msg element from invocation: " + methodInvocation.flToString() + " and bind to: " + paramToken.flToString());
              ref3 = (yield* methodInvocation.partialEvalAsMessage(theContext, methodInvocation)), returnedContext = ref3[0], methodInvocation = ref3[1];
              valueToBeBound = returnedContext.returned;
            } else {
              console.log("evaluation " + indentation() + "  matching - need to get next msg element from invocation: " + methodInvocation.flToString() + " and bind to: " + paramToken.flToString());
              ref4 = methodInvocation.nextElement(), valueToBeBound = ref4[0], methodInvocation = ref4[1];
            }
            console.log("evaluation " + indentation() + "  matching - adding paramater " + paramToken.flToString() + " to tempVariables dictionary in current frame");
            newContext.tempVariablesDict[ValidIDfromString(paramToken.value)] = valueToBeBound;
            continue;
          }
        }
        if (eachSignature.isEmpty() && soFarEverythingMatched) {
          console.log("evaluation " + indentation() + "  matching - consumed from matching this sig: " + (methodInvocation.cursorStart - originalMethodInvocationStart));
          console.log("evaluation " + indentation() + "             methodInvocation: " + methodInvocation.flToString() + " cursor start: " + methodInvocation.cursorStart + " original methodInvocation start: " + originalMethodInvocationStart);
          console.log("methodInvocation.cursorStart - originalMethodInvocationStart: " + " " + methodInvocation.cursorStart + " " + originalMethodInvocationStart);
          theContext.unparsedMessage = null;
          console.log("theContext method invocation after: " + methodInvocation.flToString());
          contextToBeReturned = (yield* this.methodCall(classContainingMethods.methodBodies[eachSignatureIndex], newContext));
          return [contextToBeReturned, methodInvocation];
        }
      }
      console.log("evaluation " + indentation() + "  matching - no match found");
      return [null, methodInvocationToBeChecked];
    };

    FLObjects.prototype.methodCall = function*(methodBody, theContext) {
      var contextToBeReturned;
      yield;
      if (methodBody.flClass === FLList) {
        console.log("evaluation " + indentation() + "  matching - method body: " + methodBody.flToString());
        console.log("evaluation " + indentation() + "  method body mandates receiver? " + methodBody.mandatesNewReceiver());
        theContext.returned = (yield* methodBody["eval"](theContext, methodBody));
        theContext.findAnotherReceiver = methodBody.mandatesNewReceiver();
        console.log("evaluation " + indentation() + "  method body mandates receiver2 ? " + methodBody.mandatesNewReceiver());
      } else {
        console.log("evaluation " + indentation() + "  matching - NATIVE method body: " + methodBody);
        theContext.returned = (yield* methodBody.call(this, theContext));
      }
      contextToBeReturned = theContext;
      return contextToBeReturned;
    };

    return FLObjects;

  })();

  FLContext = (function() {
    FLContext.prototype.self = null;

    FLContext.prototype.tempVariablesDict = null;

    FLContext.prototype.previousContext = null;

    FLContext.prototype.returned = null;

    FLContext.prototype.isTransparent = false;

    function FLContext(previousContext, newSelf) {
      this.previousContext = previousContext;
      if (newSelf) {
        this.self = newSelf;
      } else {
        this.self = this.previousContext.self;
      }
      this.tempVariablesDict = {};
    }

    FLContext.prototype.depth = function() {
      var ascendingTheContext, depthCount;
      depthCount = 0;
      ascendingTheContext = this.previousContext;
      while (ascendingTheContext != null) {
        depthCount++;
        ascendingTheContext = ascendingTheContext.previousContext;
      }
      return depthCount;
    };

    FLContext.prototype.firstNonTransparentContext = function() {
      var ascendingTheContext;
      ascendingTheContext = this;
      while (ascendingTheContext.isTransparent) {
        ascendingTheContext = ascendingTheContext.previousContext;
      }
      console.log("first non-transparent context is the one at depth: " + ascendingTheContext.depth());
      return ascendingTheContext;
    };

    FLContext.prototype.whichDictionaryContainsToken = function(theToken) {
      var base, base1, contextBeingSearched, tokenString;
      contextBeingSearched = this;
      tokenString = theToken.value;
      if (tokenString === "self") {
        return this.firstNonTransparentContext();
      }
      while (true) {
        if (contextBeingSearched.tempVariablesDict[ValidIDfromString(tokenString)] != null) {
          console.log("evaluation " + indentation() + "lookup: found in context at depth " + contextBeingSearched.depth() + " with self: " + (typeof (base = contextBeingSearched.self).flToString === "function" ? base.flToString() : void 0));
          return contextBeingSearched.tempVariablesDict;
        }
        console.log("evaluation " + indentation() + "lookup: not found in context at depth " + contextBeingSearched.depth() + " with self: " + (typeof (base1 = contextBeingSearched.self).flToString === "function" ? base1.flToString() : void 0));
        if (contextBeingSearched.isTransparent) {
          console.log("evaluation " + indentation() + "lookup: ... this context is transparent so I can go up");
          contextBeingSearched = contextBeingSearched.previousContext;
        } else {
          break;
        }
      }
      if (outerMostContext.tempVariablesDict[ValidIDfromString(tokenString)] != null) {
        return outerMostContext.tempVariablesDict;
      }
      console.log("evaluation " + indentation() + "lookup: " + tokenString + " not found!");
      return null;
    };

    FLContext.prototype.lookUpTokenValue = function(theToken, alreadyKnowWhichDict) {
      var dictWhereValueIs;
      if (alreadyKnowWhichDict != null) {
        dictWhereValueIs = alreadyKnowWhichDict;
      } else {
        dictWhereValueIs = this.whichDictionaryContainsToken(theToken);
      }
      if (dictWhereValueIs == null) {
        dictWhereValueIs = this.firstNonTransparentContext().tempVariablesDict;
      }
      console.log("evaluation " + indentation() + "lookup: " + theToken.value + " also known as " + (ValidIDfromString(theToken.value)));
      console.log("evaluation " + indentation() + "lookup: value looked up: ");
      return dictWhereValueIs[ValidIDfromString(theToken.value)];
    };

    return FLContext;

  })();

  FLClasses = (function(superClass) {
    extend(FLClasses, superClass);

    FLClasses.prototype.name = null;

    FLClasses.prototype.msgPatterns = null;

    FLClasses.prototype.methodBodies = null;

    function FLClasses(name) {
      this.name = name;
      FLClasses.__super__.constructor.call(this, this);
      this.flClass = FLClass;
      this.instanceVariablesDict[ValidIDfromString("class")] = FLClass;
      this.value = this;
      if (!this.isClass()) {
        this.name = this.constructor.name;
        this.name = this.name.substr(2, this.name.length - 7);
      }
      this.resetMethods();
      allClasses.push(this);
    }

    FLClasses.prototype.rename = function(newName) {
      return this.name = newName;
    };

    FLClasses.prototype.resetMethods = function() {
      this.msgPatterns = [];
      return this.methodBodies = [];
    };

    FLClasses.prototype.createNew = function(theClass) {
      var toBeReturned;
      toBeReturned = new FLObjects(theClass);
      return toBeReturned;
    };

    FLClasses.prototype.addMethod = function(signature, methodBody) {
      var eachSignature, i, j, ref, sortOrderStrings;
      for (i = j = 0, ref = this.msgPatterns.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        eachSignature = this.msgPatterns[i];
        if (eachSignature.flToString() === signature.flToString()) {
          this.msgPatterns[i] = signature;
          this.methodBodies[i] = methodBody;
          console.log("adding method  signature (replacing): " + signature.flToString() + " body: " + (typeof methodBody.flToString === "function" ? methodBody.flToString() : void 0));
          return;
        }
      }
      console.log("adding method  signature (appending): " + signature.flToString() + " body: " + (typeof methodBody.flToString === "function" ? methodBody.flToString() : void 0));
      this.msgPatterns.jsArrayPush(signature);
      this.methodBodies.jsArrayPush(methodBody);
      sortOrderStrings = this.msgPatterns.map(function(elem) {
        return elem.sortOrderString();
      });
      this.msgPatterns = sortFirstArrayAccordingToSecond(this.msgPatterns, sortOrderStrings);
      return this.methodBodies = sortFirstArrayAccordingToSecond(this.methodBodies, sortOrderStrings);
    };

    return FLClasses;

  })(FLObjects);

  FLClassClass = (function(superClass) {
    extend(FLClassClass, superClass);

    function FLClassClass() {
      return FLClassClass.__super__.constructor.apply(this, arguments);
    }

    FLClassClass.prototype.createNew = function(theName) {
      var newUserClass;
      if (theName == null) {
        theName = "";
      }
      newUserClass = new FLClasses(theName);
      addDefaultMethods(newUserClass);
      newUserClass.addMethod(flTokenize("new"), function*(context) {
        var objectTBR, returnedContext, toBeReturned;
        yield;
        console.log("///////// creating a new object from a user class!");
        objectTBR = newUserClass.createNew();
        objectTBR.flClass = newUserClass;
        objectTBR.instanceVariablesDict[ValidIDfromString("class")] = newUserClass;
        console.log("///////// creating a new object from a user class - user class of object: " + objectTBR.flClass.flToString());
        console.log("///////// creating a new object from a user class - objectTBR: " + objectTBR.flToString());
        console.log("///////// creating a new object from a user class - making space for instanceVariables");
        console.log("invoking whenNew");
        returnedContext = (yield* objectTBR.findSignatureBindParamsAndMakeCall(flTokenize("whenNew"), context));
        returnedContext = returnedContext[0];
        toBeReturned = returnedContext.returned;
        return toBeReturned;
      });
      newUserClass.addMethod(flTokenize("nameit (newName)"), function*(context) {
        var newName;
        yield;
        newName = context.tempVariablesDict[ValidIDfromString("newName")];
        if (typeof this.rename === "function") {
          this.rename(newName.value);
        }
        return this;
      });
      return newUserClass;
    };

    return FLClassClass;

  })(FLClasses);

  FLClass = new FLClassClass(FLClass);

  FLClass.flClass = FLClass;

  FLClass.instanceVariablesDict[ValidIDfromString("class")] = FLClass;

  FLTokenClass = (function(superClass) {
    extend(FLTokenClass, superClass);

    function FLTokenClass() {
      return FLTokenClass.__super__.constructor.apply(this, arguments);
    }

    FLTokenClass.prototype.createNew = function(tokenString) {
      var toBeReturned;
      toBeReturned = FLTokenClass.__super__.createNew.call(this, FLToken);
      toBeReturned.value = tokenString;
      toBeReturned.flToString = function() {
        var toPrint;
        if (/\$STRING_TOKEN_([\$a-zA-Z0-9_]+)/g.test(this.value)) {
          toPrint = "TOKEN:" + injectStrings(this.value);
        } else {
          toPrint = this.value;
        }
        return toPrint;
      };
      toBeReturned.isStatementSeparator = function() {
        return this.value === ";";
      };
      toBeReturned.lookup = function(theContext) {
        var existingLookedUpValuePlace;
        console.log("evaluation " + indentation() + "looking up temp token: " + this.value);
        existingLookedUpValuePlace = theContext.whichDictionaryContainsToken(this);
        if (existingLookedUpValuePlace != null) {
          console.log("evaluation " + indentation() + "found temp token: " + this.value);
          return theContext.lookUpTokenValue(this, existingLookedUpValuePlace);
        }
      };
      toBeReturned["eval"] = function*(theContext, remainingMessage) {
        var lookup, ref;
        yield;
        if ((remainingMessage != null) && remainingMessage.flClass === FLList) {
          console.log("remainingMessage: " + remainingMessage.flToString());
          console.log("secondElementIsEqual: " + remainingMessage.secondElementIsEqual());
          if (remainingMessage.startsWithIncrementOrDecrementOperator() || remainingMessage.startsWithCompoundAssignmentOperator() || remainingMessage.secondElementIsEqual()) {
            return this;
          }
        }
        lookup = this.lookup(theContext);
        if (lookup != null) {
          return lookup;
        } else if (/^[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?$/.test(this.value)) {
          return FLNumber.createNew(this.value);
        } else if (/\$STRING_TOKEN_([\$a-zA-Z0-9_]+)/g.test(this.value)) {
          return FLString.createNew(injectStrings(this.value));
        } else if (/^true$/.test(this.value)) {
          return FLBoolean.createNew(true);
        } else if (/^false$/.test(this.value)) {
          return FLBoolean.createNew(false);
        }
        console.log("evaluation " + indentation() + "token " + this.value + " contents: " + ((ref = theContext.returned) != null ? ref.value : void 0));
        console.log("evaluation " + indentation() + "not found temp token: " + this.value);
        rWorkspace.lastUndefinedArom = this;
        return FLNil.createNew();
      };
      return toBeReturned;
    };

    return FLTokenClass;

  })(FLClasses);

  FLToken = new FLTokenClass();

  FLListClass = (function(superClass) {
    extend(FLListClass, superClass);

    function FLListClass() {
      return FLListClass.__super__.constructor.apply(this, arguments);
    }

    FLListClass.prototype.emptyMessage = function() {
      var newMessage;
      newMessage = FLList.createNew().toMessage();
      return newMessage;
    };

    FLListClass.prototype.emptyList = function() {
      var newMessage;
      newMessage = FLList.createNew();
      return newMessage;
    };

    FLListClass.prototype.createNew = function() {
      var toBeReturned;
      toBeReturned = FLListClass.__super__.createNew.call(this, FLList);
      toBeReturned.value = [];
      toBeReturned.cursorStart = 0;
      toBeReturned.cursorEnd = -1;
      toBeReturned.toList = function() {
        this.isMessage = false;
        return this;
      };
      toBeReturned.toMessage = function() {
        this.isMessage = true;
        return this;
      };
      toBeReturned.flListImmutablePush = function(theItemToPush) {
        var copy;
        copy = this.shallowCopy();
        copy.value.jsArrayPush(theItemToPush);
        copy.cursorEnd++;
        return copy;
      };
      toBeReturned.elementAt = function(theElementNumber) {
        return this.value[this.cursorStart + theElementNumber];
      };
      toBeReturned.mandatesNewReceiver = function() {
        var base;
        if (this.isEmpty()) {
          return false;
        }
        if (typeof (base = this.elementAt(this.length() - 1)).isStatementSeparator === "function" ? base.isStatementSeparator() : void 0) {
          return true;
        }
        return false;
      };
      toBeReturned.elementAtSetMutable = function(theElementNumber, theValue) {
        if (this.isMessage || this.cursorStart !== 0) {
          throw "elementAtSetMutable: you can't set an element of a message";
        }
        this.value[theElementNumber] = theValue;
        return this;
      };
      toBeReturned.sortOrderString = function() {
        var element, i, j, paddingLength, ref, sortOrderString;
        sortOrderString = "";
        for (i = j = 0, ref = this.length(); 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          element = this.elementAt(i);
          if (element.flClass === FLToken) {
            sortOrderString += "a";
          }
          if (element.flClass === FLList) {
            if (element.isEvaluatingParam()) {
              sortOrderString += "c";
            } else {
              sortOrderString += "b";
            }
          }
        }
        paddingLength = 10 - sortOrderString.length;
        return sortOrderString += new Array(paddingLength).join('d');
      };
      toBeReturned.evaluatedElementsList = function(context) {
        var evalled, gen, i, j, newList, ref, ret;
        newList = FLList.createNew();
        for (i = j = 0, ref = this.length(); 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          console.log("toBeReturned.evaluatedElementsList evaluating " + (this.elementAt(i)).flToString());
          if ((this.elementAt(i)).flClass === FLList) {
            evalled = (this.elementAt(i)).evaluatedElementsList(context);
          } else {
            if ((this.elementAt(i)).flClass === FLToken && (this.elementAt(i)).value === "self") {
              evalled = this.elementAt(i);
            } else {
              gen = (this.elementAt(i))["eval"](context, this);
              while (!(ret = gen.next()).done) {
                console.log("yielding");
              }
              evalled = ret.value;
              if ((this.elementAt(i)).flClass === FLToken && evalled.flClass === FLNil) {
                evalled = this.elementAt(i);
              } else if ((this.elementAt(i)).flClass === FLToken && evalled.flClass === FLQuote) {
                evalled = this.elementAt(i);
              }
            }
          }
          newList = newList.flListImmutablePush(evalled);
        }
        return newList;
      };
      toBeReturned.flToString = function() {
        var i, j, ref, toBePrinted;
        if (this.length() <= 0) {
          return "empty message";
        }
        toBePrinted = "(";
        for (i = j = 0, ref = this.length(); 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          toBePrinted += " " + this.elementAt(i).flToStringForList();
        }
        toBePrinted += " )";
        return toBePrinted;
      };
      toBeReturned.evalFirstListElementAndTurnRestIntoMessage = function*(theContext) {
        var firstElement, restOfMessage;
        firstElement = this.firstElement();
        console.log("           " + indentation() + "evaling element " + firstElement.value);
        theContext.returned = (yield* firstElement["eval"](theContext, this));
        restOfMessage = this.restOfMessage();
        return [theContext, restOfMessage];
      };
      toBeReturned.findReceiver = function*(theContext) {
        var receiver, ref, restOfMessage, returnedContext;
        ref = (yield* this.evalFirstListElementAndTurnRestIntoMessage(theContext)), returnedContext = ref[0], restOfMessage = ref[1];
        receiver = returnedContext.returned;
        console.log("evaluation " + indentation() + "remaining part of list to be sent as message is: " + restOfMessage.flToString());
        return [returnedContext, restOfMessage, receiver];
      };
      toBeReturned["eval"] = function*(theContext) {
        var ref, ref1, ref2, returnedContext, returnedMessage;
        ref = (yield* this.partialEvalAsMessage(theContext)), returnedContext = ref[0], returnedMessage = ref[1];
        console.log("list eval - returned message: " + returnedMessage.flToString());
        console.log("list eval - returned context: " + (returnedContext != null ? typeof returnedContext.flToString === "function" ? returnedContext.flToString() : void 0 : void 0));
        console.log("list eval - returnedcontext.returned: " + ((ref1 = returnedContext.returned) != null ? typeof ref1.flToString === "function" ? ref1.flToString() : void 0 : void 0));
        console.log("list eval - returnedcontext.unparsedMessage: " + ((ref2 = returnedContext.unparsedMessage) != null ? typeof ref2.flToString === "function" ? ref2.flToString() : void 0 : void 0));
        if (!returnedMessage.isEmpty()) {
          console.log("list couldn't be fully evaluated: " + this.flToString() + " unexecutable: " + returnedMessage.flToString());
          theContext.throwing = true;
          return FLException.createNew("message was not understood: " + returnedMessage.flToString());
        }
        return returnedContext.returned;
      };
      toBeReturned.partialEvalAsMessage = function*(theContext) {
        var base, eachStatement, findAnotherReceiver, j, len, receiver, ref, ref1, restOfMessage, returnedContext, returnedMessage, statements;
        console.log("evaluation " + indentation() + "list received empty message, evaluating content of list");
        console.log("evaluation " + indentation() + "  i.e. " + this.flToString());
        this.toList();
        statements = this.separateStatements();
        for (j = 0, len = statements.length; j < len; j++) {
          eachStatement = statements[j];
          console.log("evaluation " + indentation() + "evaluating single statement");
          console.log("evaluation " + indentation() + "  i.e. " + eachStatement.flToString());
          returnedContext = theContext;
          restOfMessage = eachStatement;
          findAnotherReceiver = true;
          while (true) {
            if (returnedContext.exhaustPreviousContextMessage) {
              restOfMessage = FLList.emptyMessage();
            }
            if (returnedContext.findAnotherReceiver && !returnedContext.throwing && !restOfMessage.isEmpty()) {
              returnedContext.findAnotherReceiver = false;
              returnedContext = returnedContext.previousContext;
              findAnotherReceiver = true;
              console.log("finding next receiver from:  " + restOfMessage.flToString());
            }
            if (findAnotherReceiver) {
              findAnotherReceiver = false;
              ref = (yield* restOfMessage.findReceiver(returnedContext)), returnedContext = ref[0], restOfMessage = ref[1], receiver = ref[2];
              console.log("found next receiver and now message is: " + restOfMessage.flToString());
              console.log("3 returnedContext.throwing: " + returnedContext.throwing);
            }
            if (theContext.throwing || returnedContext.throwing) {
              console.log("throw escape");
              console.log("context at depth " + theContext.depth() + " with self: " + (typeof (base = theContext.self).flToString === "function" ? base.flToString() : void 0) + " is transparent: " + theContext.isTransparent);
              if (receiver.flClass === FLReturn && !theContext.isTransparent) {
                console.log("got a return!");
                theContext.throwing = false;
                theContext.returned = receiver.value;
              } else {
                console.log(" throwing the receiver up " + receiver.flToString());
                theContext.throwing = true;
                theContext.returned = receiver;
              }
              return [theContext, FLList.emptyMessage()];
            }
            console.log("evaluation " + indentation() + "receiver: " + (receiver != null ? typeof receiver.flToString === "function" ? receiver.flToString() : void 0 : void 0));
            console.log("evaluation " + indentation() + "message: " + restOfMessage.flToString());
            if ((receiver.flClass === FLNumber || receiver.flClass === FLString || receiver.flClass === FLBoolean) && restOfMessage.isEmpty()) {
              returnedContext = theContext;
              returnedMessage = restOfMessage;
              returnedContext.returned = receiver;
              console.log("skipping empty evaluation because basic type ");
            } else {
              ref1 = (yield* receiver.findSignatureBindParamsAndMakeCall(restOfMessage, theContext)), returnedContext = ref1[0], returnedMessage = ref1[1];
            }
            if (returnedContext == null) {
              returnedContext = theContext;
              returnedContext.returned = receiver;
              console.log("restOfMessage: " + restOfMessage.flToString());
              console.log("receiver: " + receiver.flToString());
              returnedContext.unparsedMessage = returnedMessage;
              if (returnedMessage.isEmpty()) {
                break;
              }
              return [returnedContext, returnedMessage];
            }
            receiver = returnedContext.returned;
            restOfMessage = returnedMessage;
            console.log("evaluation " + indentation() + "list evaluation returned: " + (receiver != null ? typeof receiver.flToString === "function" ? receiver.flToString() : void 0 : void 0));
            console.log("theContext.throwing: " + theContext.throwing);
            console.log("returnedContext.throwing: " + returnedContext.throwing);
            console.log("restOfMessage: " + restOfMessage);
            console.log("returnedContext.findAnotherReceiver: " + returnedContext.findAnotherReceiver);
            if (restOfMessage.isEmpty() && !(theContext.throwing || returnedContext.throwing)) {
              console.log("breaking and moving on to next statement");
              break;
            }
          }
          console.log("evaluation " + indentation() + "list: nothing more to evaluate");
          theContext.returned = receiver;
        }
        console.log("evaluation " + indentation() + "list: theContext.returned: " + theContext.returned);
        flContexts.pop();
        return [theContext, restOfMessage];
      };
      toBeReturned.length = function() {
        return this.cursorEnd - this.cursorStart + 1;
      };
      toBeReturned.restOfMessage = function() {
        var copy;
        copy = this.copy();
        copy.cursorStart++;
        return copy;
      };
      toBeReturned.firstElement = function() {
        if (this.cursorStart > this.cursorEnd) {
          throw "no first element, array is empty";
        }
        return this.elementAt(0);
      };
      toBeReturned.startsWithCompoundAssignmentOperator = function() {
        if (this.length() >= 2) {
          if ((this.elementAt(1)).flClass === FLToken) {
            if (/([+\-^*\/⇒%_]+=)/g.test((this.elementAt(1)).value)) {
              console.log("startsWithCompoundAssignmentOperator: oh yes");
              return true;
            }
          }
        }
        console.log("startsWithCompoundAssignmentOperator: oh no");
        return false;
      };
      toBeReturned.startsWithIncrementOrDecrementOperator = function() {
        if (this.length() >= 2) {
          if ((this.elementAt(1)).flClass === FLToken) {
            if ((this.elementAt(1)).value === "++" || (this.elementAt(1)).value === "--") {
              console.log("startsWithIncrementOrDecrementOperator: oh yes");
              return true;
            }
          }
        }
        console.log("startsWithIncrementOrDecrementOperator: oh no");
        return false;
      };
      toBeReturned.secondElementIsEqual = function() {
        if (this.length() >= 2) {
          if ((this.elementAt(1)).flClass === FLToken) {
            if ((this.elementAt(1)).value === "=") {
              return true;
            }
          }
        }
        return false;
      };
      toBeReturned.nextElement = function() {
        return [this.firstElement(), this.restOfMessage()];
      };
      toBeReturned.advanceMessageBy = function(numberOfElements) {
        var copy;
        copy = this.copy();
        copy.cursorStart += numberOfElements;
        return copy;
      };
      toBeReturned.isEmpty = function() {
        return this.length() <= 0;
      };
      toBeReturned.copy = function() {
        var copy;
        copy = FLList.createNew();
        copy.value = this.value;
        copy.cursorStart = this.cursorStart;
        copy.cursorEnd = this.cursorEnd;
        copy.isMessage = this.isMessage;
        return copy;
      };
      toBeReturned.shallowCopy = function() {
        var copy;
        copy = this.copy();
        copy.value = this.value.slice();
        return copy;
      };
      toBeReturned.isEvaluatingParam = function() {
        return this.length() === 1;
      };
      toBeReturned.getParamToken = function() {
        if (this.isEvaluatingParam()) {
          return this.elementAt(0);
        } else {
          return this.elementAt(1);
        }
      };
      toBeReturned.separateStatements = function() {
        var arrayOfStatements, base, base1, base2, i, j, lastStatementEnd, ref, ref1, statementToBeAdded;
        console.log("evaluation " + indentation() + "separating statements   start: " + this.flToString());
        arrayOfStatements = [];
        lastStatementEnd = this.cursorStart - 1;
        for (i = j = ref = this.cursorStart, ref1 = this.cursorEnd; ref <= ref1 ? j <= ref1 : j >= ref1; i = ref <= ref1 ? ++j : --j) {
          console.log("evaluation " + indentation() + "separating statements   examining element " + this.value[i].flToString());
          if ((typeof (base = this.value[i]).isStatementSeparator === "function" ? base.isStatementSeparator() : void 0) || (i === this.cursorEnd)) {
            statementToBeAdded = this.copy().toList();
            statementToBeAdded.cursorStart = lastStatementEnd + 1;
            statementToBeAdded.cursorEnd = i - 1;
            if (i === this.cursorEnd && !(typeof (base1 = this.value[this.cursorEnd]).isStatementSeparator === "function" ? base1.isStatementSeparator() : void 0)) {
              console.log(" last char: " + this.value[this.cursorEnd].flToString());
              statementToBeAdded.cursorEnd++;
            }
            lastStatementEnd = i;
            if (!statementToBeAdded.isEmpty() && !(typeof (base2 = statementToBeAdded.firstElement()).isStatementSeparator === "function" ? base2.isStatementSeparator() : void 0)) {
              console.log(" adding: " + statementToBeAdded.flToString());
              arrayOfStatements.jsArrayPush(statementToBeAdded);
            }
            console.log("evaluation " + indentation() + "separating statements isolated new statement " + statementToBeAdded.flToString());
          }
        }
        return arrayOfStatements;
      };
      return toBeReturned;
    };

    return FLListClass;

  })(FLClasses);

  FLList = new FLListClass();

  FLQuoteClass = (function(superClass) {
    extend(FLQuoteClass, superClass);

    function FLQuoteClass() {
      return FLQuoteClass.__super__.constructor.apply(this, arguments);
    }

    FLQuoteClass.prototype.createNew = function() {
      return FLQuoteClass.__super__.createNew.call(this, FLQuote);
    };

    return FLQuoteClass;

  })(FLClasses);

  FLQuote = new FLQuoteClass();

  FLBooleanClass = (function(superClass) {
    extend(FLBooleanClass, superClass);

    function FLBooleanClass() {
      return FLBooleanClass.__super__.constructor.apply(this, arguments);
    }

    FLBooleanClass.prototype.createNew = function(value) {
      var toBeReturned;
      toBeReturned = FLBooleanClass.__super__.createNew.call(this, FLBoolean);
      toBeReturned.value = value;
      toBeReturned.flToString = function() {
        return this.value;
      };
      return toBeReturned;
    };

    return FLBooleanClass;

  })(FLClasses);

  FLBoolean = new FLBooleanClass();

  FLIfThenClass = (function(superClass) {
    extend(FLIfThenClass, superClass);

    function FLIfThenClass() {
      return FLIfThenClass.__super__.constructor.apply(this, arguments);
    }

    FLIfThenClass.prototype.createNew = function() {
      return FLIfThenClass.__super__.createNew.call(this, FLIfThen);
    };

    return FLIfThenClass;

  })(FLClasses);

  FLIfThen = new FLIfThenClass();

  FLIfFallThroughClass = (function(superClass) {
    extend(FLIfFallThroughClass, superClass);

    function FLIfFallThroughClass() {
      return FLIfFallThroughClass.__super__.constructor.apply(this, arguments);
    }

    FLIfFallThroughClass.prototype.createNew = function() {
      return FLIfFallThroughClass.__super__.createNew.call(this, FLIfFallThrough);
    };

    return FLIfFallThroughClass;

  })(FLClasses);

  FLIfFallThrough = new FLIfFallThroughClass();

  FLFakeElseClass = (function(superClass) {
    extend(FLFakeElseClass, superClass);

    function FLFakeElseClass() {
      return FLFakeElseClass.__super__.constructor.apply(this, arguments);
    }

    FLFakeElseClass.prototype.createNew = function() {
      return FLFakeElseClass.__super__.createNew.call(this, FLFakeElse);
    };

    return FLFakeElseClass;

  })(FLClasses);

  FLFakeElse = new FLFakeElseClass();

  FLExceptionClass = (function(superClass) {
    extend(FLExceptionClass, superClass);

    function FLExceptionClass() {
      return FLExceptionClass.__super__.constructor.apply(this, arguments);
    }

    FLExceptionClass.prototype.createNew = function(value) {
      var toBeReturned;
      toBeReturned = FLExceptionClass.__super__.createNew.call(this, FLException);
      toBeReturned.value = value;
      toBeReturned.flToString = function() {
        return this.value;
      };
      return toBeReturned;
    };

    return FLExceptionClass;

  })(FLClasses);

  FLException = new FLExceptionClass();

  FLRepeat1Class = (function(superClass) {
    extend(FLRepeat1Class, superClass);

    function FLRepeat1Class() {
      return FLRepeat1Class.__super__.constructor.apply(this, arguments);
    }

    FLRepeat1Class.prototype.createNew = function() {
      return FLRepeat1Class.__super__.createNew.call(this, FLRepeat1);
    };

    return FLRepeat1Class;

  })(FLClasses);

  FLRepeat1 = new FLRepeat1Class();

  FLRepeat2Class = (function(superClass) {
    extend(FLRepeat2Class, superClass);

    function FLRepeat2Class() {
      return FLRepeat2Class.__super__.constructor.apply(this, arguments);
    }

    FLRepeat2Class.prototype.createNew = function() {
      return FLRepeat2Class.__super__.createNew.call(this, FLRepeat2);
    };

    return FLRepeat2Class;

  })(FLClasses);

  FLRepeat2 = new FLRepeat2Class();

  FLForClass = (function(superClass) {
    extend(FLForClass, superClass);

    function FLForClass() {
      return FLForClass.__super__.constructor.apply(this, arguments);
    }

    FLForClass.prototype.createNew = function() {
      return FLForClass.__super__.createNew.call(this, FLFor);
    };

    return FLForClass;

  })(FLClasses);

  FLFor = new FLForClass();

  FLInClass = (function(superClass) {
    extend(FLInClass, superClass);

    function FLInClass() {
      return FLInClass.__super__.constructor.apply(this, arguments);
    }

    FLInClass.prototype.createNew = function() {
      return FLInClass.__super__.createNew.call(this, FLIn);
    };

    return FLInClass;

  })(FLClasses);

  FLIn = new FLInClass();

  FLTryClass = (function(superClass) {
    extend(FLTryClass, superClass);

    function FLTryClass() {
      return FLTryClass.__super__.constructor.apply(this, arguments);
    }

    FLTryClass.prototype.createNew = function() {
      return FLTryClass.__super__.createNew.call(this, FLTry);
    };

    return FLTryClass;

  })(FLClasses);

  FLTry = new FLTryClass();

  FLFakeCatchClass = (function(superClass) {
    extend(FLFakeCatchClass, superClass);

    function FLFakeCatchClass() {
      return FLFakeCatchClass.__super__.constructor.apply(this, arguments);
    }

    FLFakeCatchClass.prototype.createNew = function() {
      return FLFakeCatch;
    };

    return FLFakeCatchClass;

  })(FLClasses);

  FLFakeCatch = new FLFakeCatchClass();

  FLThrowClass = (function(superClass) {
    extend(FLThrowClass, superClass);

    function FLThrowClass() {
      return FLThrowClass.__super__.constructor.apply(this, arguments);
    }

    FLThrowClass.prototype.createNew = function() {
      return FLThrowClass.__super__.createNew.call(this, FLThrow);
    };

    return FLThrowClass;

  })(FLClasses);

  FLThrow = new FLThrowClass();

  FLNotClass = (function(superClass) {
    extend(FLNotClass, superClass);

    function FLNotClass() {
      return FLNotClass.__super__.constructor.apply(this, arguments);
    }

    FLNotClass.prototype.createNew = function() {
      return FLNotClass.__super__.createNew.call(this, FLNot);
    };

    return FLNotClass;

  })(FLClasses);

  FLNot = new FLNotClass();

  FLToClass = (function(superClass) {
    extend(FLToClass, superClass);

    function FLToClass() {
      return FLToClass.__super__.constructor.apply(this, arguments);
    }

    FLToClass.prototype.createNew = function() {
      return FLToClass.__super__.createNew.call(this, FLTo);
    };

    return FLToClass;

  })(FLClasses);

  FLTo = new FLToClass();

  FLDoneClass = (function(superClass) {
    extend(FLDoneClass, superClass);

    function FLDoneClass() {
      return FLDoneClass.__super__.constructor.apply(this, arguments);
    }

    FLDoneClass.prototype.createNew = function() {
      var toBeReturned;
      toBeReturned = FLDoneClass.__super__.createNew.call(this, FLDone);
      toBeReturned.value = null;
      return toBeReturned;
    };

    return FLDoneClass;

  })(FLClasses);

  FLDone = new FLDoneClass();

  FLPauseClass = (function(superClass) {
    extend(FLPauseClass, superClass);

    function FLPauseClass() {
      return FLPauseClass.__super__.constructor.apply(this, arguments);
    }

    FLPauseClass.prototype.createNew = function() {
      var toBeReturned;
      toBeReturned = FLPauseClass.__super__.createNew.call(this, FLPause);
      toBeReturned.value = null;
      return toBeReturned;
    };

    return FLPauseClass;

  })(FLClasses);

  FLPause = new FLPauseClass();

  FLBreakClass = (function(superClass) {
    extend(FLBreakClass, superClass);

    function FLBreakClass() {
      return FLBreakClass.__super__.constructor.apply(this, arguments);
    }

    FLBreakClass.prototype.createNew = function() {
      return FLBreakClass.__super__.createNew.call(this, FLBreak);
    };

    return FLBreakClass;

  })(FLClasses);

  FLBreak = new FLBreakClass();

  FLReturnClass = (function(superClass) {
    extend(FLReturnClass, superClass);

    function FLReturnClass() {
      return FLReturnClass.__super__.constructor.apply(this, arguments);
    }

    FLReturnClass.prototype.createNew = function() {
      var toBeReturned;
      toBeReturned = FLReturnClass.__super__.createNew.call(this, FLReturn);
      toBeReturned.value = null;
      return toBeReturned;
    };

    return FLReturnClass;

  })(FLClasses);

  FLReturn = new FLReturnClass();

  FLAccessUpperContextClass = (function(superClass) {
    extend(FLAccessUpperContextClass, superClass);

    function FLAccessUpperContextClass() {
      return FLAccessUpperContextClass.__super__.constructor.apply(this, arguments);
    }

    FLAccessUpperContextClass.prototype.createNew = function() {
      return FLAccessUpperContextClass.__super__.createNew.call(this, FLAccessUpperContext);
    };

    return FLAccessUpperContextClass;

  })(FLClasses);

  FLAccessUpperContext = new FLAccessUpperContextClass();

  FLForeverClass = (function(superClass) {
    extend(FLForeverClass, superClass);

    function FLForeverClass() {
      return FLForeverClass.__super__.constructor.apply(this, arguments);
    }

    FLForeverClass.prototype.createNew = function() {
      return FLForeverClass.__super__.createNew.call(this, FLForever);
    };

    return FLForeverClass;

  })(FLClasses);

  FLForever = new FLForeverClass();

  FLEvaluationsCounterClass = (function(superClass) {
    extend(FLEvaluationsCounterClass, superClass);

    function FLEvaluationsCounterClass() {
      return FLEvaluationsCounterClass.__super__.constructor.apply(this, arguments);
    }

    FLEvaluationsCounterClass.prototype.createNew = function() {
      return FLEvaluationsCounterClass.__super__.createNew.call(this, FLEvaluationsCounter);
    };

    return FLEvaluationsCounterClass;

  })(FLClasses);

  FLEvaluationsCounter = new FLEvaluationsCounterClass();

  FLNumberClass = (function(superClass) {
    extend(FLNumberClass, superClass);

    function FLNumberClass() {
      return FLNumberClass.__super__.constructor.apply(this, arguments);
    }

    FLNumberClass.prototype.createNew = function(value) {
      var toBeReturned;
      toBeReturned = FLNumberClass.__super__.createNew.call(this, FLNumber);
      toBeReturned.value = parseFloat(value + "");
      toBeReturned.flToString = function() {
        return this.value;
      };
      return toBeReturned;
    };

    return FLNumberClass;

  })(FLClasses);

  FLNumber = new FLNumberClass();

  FLNilClass = (function(superClass) {
    extend(FLNilClass, superClass);

    function FLNilClass() {
      return FLNilClass.__super__.constructor.apply(this, arguments);
    }

    FLNilClass.prototype.createNew = function() {
      var toBeReturned;
      toBeReturned = FLNilClass.__super__.createNew.call(this, FLNil);
      toBeReturned.flToString = function() {
        return "nil";
      };
      return toBeReturned;
    };

    return FLNilClass;

  })(FLClasses);

  FLNil = new FLNilClass();

  FLStringClass = (function(superClass) {
    extend(FLStringClass, superClass);

    function FLStringClass() {
      return FLStringClass.__super__.constructor.apply(this, arguments);
    }

    FLStringClass.prototype.createNew = function(value) {
      var toBeReturned;
      toBeReturned = FLStringClass.__super__.createNew.call(this, FLString);
      toBeReturned.value = value + "";
      toBeReturned.flToString = function() {
        return this.value;
      };
      toBeReturned.flToStringForList = function() {
        return '"' + this.value + '"';
      };
      return toBeReturned;
    };

    return FLStringClass;

  })(FLClasses);

  FLString = new FLStringClass();

  FLWorkspaceClass = (function(superClass) {
    extend(FLWorkspaceClass, superClass);

    function FLWorkspaceClass() {
      return FLWorkspaceClass.__super__.constructor.apply(this, arguments);
    }

    FLWorkspaceClass.prototype.createNew = function() {
      return FLWorkspaceClass.__super__.createNew.call(this, FLWorkspace);
    };

    return FLWorkspaceClass;

  })(FLClasses);

  FLWorkspace = new FLWorkspaceClass();

  FLConsoleClass = (function(superClass) {
    extend(FLConsoleClass, superClass);

    function FLConsoleClass() {
      return FLConsoleClass.__super__.constructor.apply(this, arguments);
    }

    FLConsoleClass.prototype.createNew = function() {
      return FLConsoleClass.__super__.createNew.call(this, FLConsole);
    };

    return FLConsoleClass;

  })(FLClasses);

  FLConsole = new FLConsoleClass();

  commonSimpleValueEqualityFunction = function*(context) {
    var toCompare;
    yield;
    toCompare = context.tempVariablesDict[ValidIDfromString("toCompare")];
    if (this.value === toCompare.value) {
      return FLBoolean.createNew(true);
    } else {
      return FLBoolean.createNew(false);
    }
  };

  commonSimpleValueInequalityFunction = function*(context) {
    var toCompare;
    yield;
    toCompare = context.tempVariablesDict[ValidIDfromString("toCompare")];
    if (this.value !== toCompare.value) {
      return FLBoolean.createNew(true);
    } else {
      return FLBoolean.createNew(false);
    }
  };

  addDefaultMethods = function(classToAddThemTo) {
    var commonPropertyAccessFunction, commonPropertyAssignmentFunction;
    classToAddThemTo.addMethod(flTokenize("isPrimitiveType"), flTokenize("if (self.class == Class) or (self.class == String) or (self.class == Number) or (self.class == List) or (self.class == Boolean):\n﹍return true\nelse:\n﹍return false"));
    classToAddThemTo.addMethod(flTokenize("postfixPrint"), function*(context) {
      yield;
      console.log("///////// program printout: " + this.flToString());
      environmentPrintout += this.flToString();
      return this;
    });
    classToAddThemTo.addMethod(flTokenize("toString"), function*(context) {
      yield;
      return FLString.createNew(this.flToString());
    });
    classToAddThemTo.addMethod(flTokenize("whenNew"), function*(context) {
      yield;
      return this;
    });
    classToAddThemTo.addMethod(flTokenize("eval"), function*(context) {
      var newContext, toBeReturned;
      context.isTransparent = true;
      newContext = new FLContext(context);
      newContext.isTransparent = true;
      flContexts.jsArrayPush(newContext);
      toBeReturned = (yield* this["eval"](newContext, this));
      flContexts.pop();
      return toBeReturned;
    });
    classToAddThemTo.addMethod(flTokenize("== ( toCompare )"), function*(context) {
      var toCompare;
      yield;
      toCompare = context.tempVariablesDict[ValidIDfromString("toCompare")];
      if (this === toCompare) {
        return FLBoolean.createNew(true);
      } else {
        return FLBoolean.createNew(false);
      }
    });
    classToAddThemTo.addMethod(flTokenize("!= ( toCompare )"), function*(context) {
      var toCompare;
      yield;
      toCompare = context.tempVariablesDict[ValidIDfromString("toCompare")];
      if (this !== toCompare) {
        return FLBoolean.createNew(true);
      } else {
        return FLBoolean.createNew(false);
      }
    });
    commonPropertyAssignmentFunction = function*(context) {
      var value, variable;
      yield;
      context.isTransparent = true;
      variable = context.tempVariablesDict[ValidIDfromString("variable")];
      value = context.tempVariablesDict[ValidIDfromString("value")];
      this.instanceVariablesDict[ValidIDfromString(variable.value)] = value;
      context.findAnotherReceiver = true;
      return this;
    };
    commonPropertyAccessFunction = function*(context) {
      var objectsBeingChecked, variable;
      yield;
      context.isTransparent = true;
      variable = context.tempVariablesDict[ValidIDfromString("variable")];
      console.log(". ('variable) : checking instance variables");
      objectsBeingChecked = this;
      while (true) {
        if (objectsBeingChecked.instanceVariablesDict[ValidIDfromString(variable.value)] != null) {
          console.log("yes it's an instance variable: ");
          return objectsBeingChecked.instanceVariablesDict[ValidIDfromString(variable.value)];
        }
        if (objectsBeingChecked === objectsBeingChecked.flClass) {
          break;
        } else {
          objectsBeingChecked = objectsBeingChecked.flClass;
        }
      }
      return FLNil.createNew();
    };
    classToAddThemTo.addMethod(flTokenize(". ('variable) = (value)"), commonPropertyAssignmentFunction);
    classToAddThemTo.addMethod(flTokenize(". ('variable) ← (value)"), commonPropertyAssignmentFunction);
    classToAddThemTo.addMethod(flTokenize(". evaluating (variable)"), commonPropertyAccessFunction);
    classToAddThemTo.addMethod(flTokenize(". ('variable) += (value)"), function*(context) {
      var runThis, toBeReturned, value, variable;
      variable = context.tempVariablesDict[ValidIDfromString("variable")];
      value = context.tempVariablesDict[ValidIDfromString("value")];
      runThis = flTokenize("(self . evaluating variable) += value");
      toBeReturned = (yield* runThis["eval"](context, runThis));
      this.instanceVariablesDict[ValidIDfromString(variable.value)] = toBeReturned;
      context.findAnotherReceiver = true;
      return toBeReturned;
    });
    classToAddThemTo.addMethod(flTokenize(". ('variable) *= (value)"), function*(context) {
      var runThis, toBeReturned, value, variable;
      variable = context.tempVariablesDict[ValidIDfromString("variable")];
      value = context.tempVariablesDict[ValidIDfromString("value")];
      runThis = flTokenize("(self . evaluating variable) *= value");
      toBeReturned = (yield* runThis["eval"](context, runThis));
      this.instanceVariablesDict[ValidIDfromString(variable.value)] = toBeReturned;
      context.findAnotherReceiver = true;
      return toBeReturned;
    });
    classToAddThemTo.addMethod(flTokenize(". ('variable) ++"), function*(context) {
      var runThis, toBeReturned, variable;
      variable = context.tempVariablesDict[ValidIDfromString("variable")];
      runThis = flTokenize("(self . evaluating variable) ++");
      toBeReturned = (yield* runThis["eval"](context, runThis));
      this.instanceVariablesDict[ValidIDfromString(variable.value)] = toBeReturned;
      return toBeReturned;
    });
    classToAddThemTo.addMethod(flTokenize(". ('variable)"), commonPropertyAccessFunction);
    return classToAddThemTo.addMethod(flTokenize("answer ( signature ) by ( methodBody )"), function*(context) {
      var methodBody, signature;
      yield;
      signature = context.tempVariablesDict[ValidIDfromString("signature")];
      methodBody = context.tempVariablesDict[ValidIDfromString("methodBody")];
      if (this.isClass()) {
        this.addMethod(signature, methodBody);
      } else {
        this.flClass.addMethod(signature, methodBody);
      }
      context.findAnotherReceiver = true;
      return this;
    });
  };

  bootClasses = allClasses.slice();

  clearClasses = function() {
    var eachClass, j, len;
    for (j = 0, len = bootClasses.length; j < len; j++) {
      eachClass = bootClasses[j];
      eachClass.resetMethods();
    }
    return allClasses = [];
  };

  initBootClasses = function() {
    var BaseDivideFunction, BaseFloorDivisionFunction, BaseMinusFunction, BaseMultiplyFunction, BasePercentFunction, BasePlusFunction, commonClassCreationFunction, eachClass, j, len, pauseFunctionContinuation;
    for (j = 0, len = bootClasses.length; j < len; j++) {
      eachClass = bootClasses[j];
      addDefaultMethods(eachClass);
    }
    FLToken.addMethod(flTokenize("← ( valueToAssign )"), function*(context) {
      var assigneeTokenString, dictToPutValueIn, valueToAssign;
      yield;
      valueToAssign = context.tempVariablesDict[ValidIDfromString("valueToAssign")];
      assigneeTokenString = this.value;
      console.log("evaluation " + indentation() + "assignment to token " + assigneeTokenString);
      console.log("evaluation " + indentation() + "value to assign to token: " + assigneeTokenString + " : " + valueToAssign.value);
      context.isTransparent = true;
      dictToPutValueIn = context.whichDictionaryContainsToken(this);
      if (dictToPutValueIn == null) {
        console.log("evaluation " + indentation() + "creating temp token: " + assigneeTokenString + " at depth: " + context.firstNonTransparentContext().depth() + " with self: " + context.firstNonTransparentContext().self.flToString());
        dictToPutValueIn = context.firstNonTransparentContext().tempVariablesDict;
      } else {
        console.log("evaluation " + indentation() + "found temp token: " + assigneeTokenString);
      }
      dictToPutValueIn[ValidIDfromString(assigneeTokenString)] = valueToAssign;
      console.log("evaluation " + indentation() + "stored value in dictionary");
      return valueToAssign;
    });
    FLToken.addMethod(flTokenize("= ( valueToAssign )"), function*(context) {
      var assigneeTokenString, dictToPutValueIn, valueToAssign;
      yield;
      valueToAssign = context.tempVariablesDict[ValidIDfromString("valueToAssign")];
      assigneeTokenString = this.value;
      console.log("evaluation " + indentation() + "assignment to token " + assigneeTokenString);
      console.log("evaluation " + indentation() + "value to assign to token: " + assigneeTokenString + " : " + valueToAssign.value);
      context.isTransparent = true;
      dictToPutValueIn = context.whichDictionaryContainsToken(this);
      if (dictToPutValueIn == null) {
        console.log("evaluation " + indentation() + "creating temp token: " + assigneeTokenString);
        dictToPutValueIn = context.firstNonTransparentContext().tempVariablesDict;
      } else {
        console.log("evaluation " + indentation() + "found temp token: " + assigneeTokenString);
      }
      dictToPutValueIn[ValidIDfromString(assigneeTokenString)] = valueToAssign;
      console.log("evaluation " + indentation() + "stored value in dictionary");
      context.findAnotherReceiver = true;
      return valueToAssign;
    });
    commonClassCreationFunction = function*(context, assigneeTokenString, className) {
      var dictToPutValueIn, valueToAssign;
      yield;
      valueToAssign = FLClass.createNew(className);
      console.log("evaluation " + indentation() + "assignment to token " + assigneeTokenString);
      console.log("evaluation " + indentation() + "value to assign to token: " + assigneeTokenString + " : " + valueToAssign.value);
      context.isTransparent = true;
      dictToPutValueIn = context.whichDictionaryContainsToken(this);
      if (dictToPutValueIn == null) {
        console.log("evaluation " + indentation() + "creating temp token: " + assigneeTokenString);
        dictToPutValueIn = context.firstNonTransparentContext().tempVariablesDict;
      } else {
        console.log("evaluation " + indentation() + "found temp token: " + assigneeTokenString);
      }
      dictToPutValueIn[ValidIDfromString(assigneeTokenString)] = valueToAssign;
      console.log("evaluation " + indentation() + "stored value in dictionary");
      context.findAnotherReceiver = true;
      return valueToAssign;
    };
    FLToken.addMethod(flTokenize("= Class new"), function*(context) {
      var toBeReturned;
      toBeReturned = (yield* commonClassCreationFunction(context, this.value, this.value));
      return toBeReturned;
    });
    FLToken.addMethod(flTokenize("= Class new named (theName)"), function*(context) {
      var theName, toBeReturned;
      theName = context.tempVariablesDict[ValidIDfromString("theName")];
      toBeReturned = (yield* commonClassCreationFunction(context, this.value, theName.value));
      return toBeReturned;
    });
    FLToken.addMethod(flTokenize("+= ( operandum )"), flTokenize("self ← self eval + operandum"));
    FLToken.addMethod(flTokenize("*= ( operandum )"), flTokenize("self ← self eval * operandum"));
    FLToken.addMethod(flTokenize("++"), flTokenize("self ← self eval + 1"));
    FLNil.addMethod(flTokenize("== ( toCompare )"), function*(context) {
      var toCompare;
      yield;
      toCompare = context.tempVariablesDict[ValidIDfromString("toCompare")];
      if (toCompare.flClass === FLNil) {
        return FLBoolean.createNew(true);
      } else {
        return FLBoolean.createNew(false);
      }
    });
    FLIn.addMethod(flTokenize("(object) do ('code)"), function*(context) {
      var code, newContext, object, toBeReturned;
      object = context.tempVariablesDict[ValidIDfromString("object")];
      code = context.tempVariablesDict[ValidIDfromString("code")];
      newContext = new FLContext(context, object);
      toBeReturned = (yield* code["eval"](newContext, code));
      context.findAnotherReceiver = true;
      return toBeReturned;
    });
    FLTo.addMethod(flTokenize("( ' functionObjectName ) ( signature ) do ( functionBody )"), flTokenize("accessUpperContext\nif (nil == functionObjectName eval) or (functionObjectName eval isPrimitiveType):\n﹍'TempClass ← Class new\n﹍TempClass nameit \"Class_of_\" + functionObjectName\n﹍functionObjectName ← TempClass new\n﹍TempClass answer (signature) by (functionBody)\nelse:\n﹍functionObjectName eval answer (signature) by (functionBody)\n\n"));
    FLTo.addMethod(flTokenize("( ' functionObjectName ) ( functionBody )"), flTokenize("accessUpperContext\n// functionObjectName contains a token i.e.\n// it's a pointer. So to put something inside the\n// variable *it's pointing at*,\n// you need to do \"functionObjectName eval\"\nif (nil == functionObjectName eval) or (functionObjectName eval isPrimitiveType):\n﹍'TempClass ← Class new\n﹍TempClass nameit \"Class_of_\" + functionObjectName\n﹍functionObjectName ← TempClass new\n﹍TempClass answer: () by (functionBody)\nelse:\n﹍functionObjectName eval answer: () by (functionBody)\n\n"));
    FLClass.addMethod(flTokenize("new"), function*(context) {
      yield;
      console.log("///////// creating a new class for the user!");
      return this.createNew();
    });
    FLException.addMethod(flTokenize("new"), function*(context) {
      yield;
      return this.createNew("");
    });
    FLException.addMethod(flTokenize("initWith ( errorMessage )"), function*(context) {
      var errorMessage;
      yield;
      errorMessage = context.tempVariablesDict[ValidIDfromString("errorMessage")];
      this.value = errorMessage.value;
      return this;
    });
    FLException.addMethod(flTokenize("catch all : ( ' errorHandle )"), function*(context) {
      var errorHandle, toBeReturned;
      errorHandle = context.tempVariablesDict[ValidIDfromString("errorHandle")];
      console.log("catch: being thrown? " + context.throwing);
      console.log("catch: got right exception, catching it");
      toBeReturned = (yield* errorHandle["eval"](context, errorHandle));
      context.findAnotherReceiver = true;
      return toBeReturned;
    });
    FLException.addMethod(flTokenize("catch ( 'theError ) : ( ' errorHandle )"), function*(context) {
      var errorHandle, theError, toBeReturned;
      yield;
      theError = context.tempVariablesDict[ValidIDfromString("theError")];
      errorHandle = context.tempVariablesDict[ValidIDfromString("errorHandle")];
      theError = (yield* theError["eval"](context, theError));
      console.log("catch: same as one to catch?" + (this === theError) + " being thrown? " + context.throwing);
      if (this === theError) {
        console.log("catch: got right exception, catching it");
        toBeReturned = (yield* errorHandle["eval"](context, errorHandle));
        context.findAnotherReceiver = true;
      } else {
        console.log("catch: got wrong exception, propagating it");
        toBeReturned = this;
        context.findAnotherReceiver = false;
      }
      return toBeReturned;
    });
    FLException.addMethod(FLList.emptyMessage(), function*(context) {
      yield;
      if (this.thrown) {
        context.throwing = true;
      }
      return this;
    });
    FLString.addMethod(flTokenize("new"), function*(context) {
      yield;
      return this.createNew("");
    });
    FLString.addMethod(flTokenize("+ ( stringToBeAppended )"), function*(context) {
      var stringToBeAppended;
      yield;
      stringToBeAppended = context.tempVariablesDict[ValidIDfromString("stringToBeAppended")];
      return FLString.createNew(this.value + stringToBeAppended.flToString());
    });
    FLString.addMethod(flTokenize("== ( toCompare )"), commonSimpleValueEqualityFunction);
    FLString.addMethod(flTokenize("!= ( toCompare )"), commonSimpleValueInequalityFunction);
    FLNumber.addMethod(flTokenize("new"), function*(context) {
      yield;
      return this.createNew(0);
    });
    FLNumber.addMethod(flTokenize("anotherPrint"), flTokenize("console print self"));
    FLNumber.addMethod(flTokenize("doublePrint"), flTokenize("console print(console print self)"));
    FLNumber.addMethod(flTokenize("incrementInPlace"), flTokenize("self ← self + 1"));
    FLNumber.addMethod(flTokenize("factorial"), flTokenize("( self == 0 ) ⇒ ( 1 ) ( self minus 1 ) factorial * self"));
    FLNumber.addMethod(flTokenize("factorialtwo"), flTokenize("( self == 0 ) ⇒ ( 1 ) self * ( ( self minus 1 ) factorialtwo )"));
    FLNumber.addMethod(flTokenize("factorialthree"), flTokenize("( self == 0 ) ⇒ ( 1 ) ('temp ← self;console print temp; ( self minus 1 ) factorialthree * temp )"));
    FLNumber.addMethod(flTokenize("factorialfour"), flTokenize("( self == 0 ) ⇒ ( 1 ) ('temp ← self;( self minus 1 ) factorialfour * temp )"));
    FLNumber.addMethod(flTokenize("factorialfive"), flTokenize("( self == 0 ) ⇒ ( 1 ) (1 + 1;'temp ← self;( self minus 1 ) factorialfive * temp )"));
    FLNumber.addMethod(flTokenize("amIZero"), flTokenize("self == 0"));
    FLNumber.addMethod(flTokenize("printAFromDeeperCall"), flTokenize("console print a"));
    FLNumber.addMethod(flTokenize("...(endRange)"), function*(context) {
      var endRange, i, l, listToBeReturned, ref, ref1;
      yield;
      endRange = context.tempVariablesDict[ValidIDfromString("endRange")];
      listToBeReturned = FLList.createNew();
      for (i = l = ref = this.value, ref1 = endRange.value; ref <= ref1 ? l < ref1 : l > ref1; i = ref <= ref1 ? ++l : --l) {
        listToBeReturned.value.jsArrayPush(FLNumber.createNew(i));
        listToBeReturned.cursorEnd++;
      }
      return listToBeReturned;
    });
    BasePlusFunction = function*(context) {
      var operandum;
      yield;
      operandum = context.tempVariablesDict[ValidIDfromString("operandum")];
      if (operandum.flClass === FLString) {
        return FLString.createNew(this.value + operandum.value);
      } else {
        return FLNumber.createNew(this.value + operandum.value);
      }
    };
    FLNumber.addMethod(flTokenize("$plus_binary ( operandum )"), BasePlusFunction);
    FLNumber.addMethod(flTokenize("+ ( operandum )"), flTokenize("self $plus_binary operandum"));
    FLNumber.addMethod(flTokenize("++"), flTokenize("self + 1"));
    FLNumber.addMethod(flTokenize("+= (value)"), flTokenize("self + value"));
    BasePercentFunction = function*(context) {
      var operandum;
      yield;
      operandum = context.tempVariablesDict[ValidIDfromString("operandum")];
      return FLNumber.createNew(this.value % operandum.value);
    };
    FLNumber.addMethod(flTokenize("$percent_binary ( operandum )"), BasePercentFunction);
    FLNumber.addMethod(flTokenize("% ( operandum )"), flTokenize("self $percent_binary operandum"));
    BaseFloorDivisionFunction = function*(context) {
      var operandum;
      yield;
      operandum = context.tempVariablesDict[ValidIDfromString("operandum")];
      return FLNumber.createNew(Math.floor(this.value / operandum.value));
    };
    FLNumber.addMethod(flTokenize("$floordivision_binary ( operandum )"), BaseFloorDivisionFunction);
    FLNumber.addMethod(flTokenize("/_ ( operandum )"), flTokenize("self $floordivision_binary operandum"));
    BaseMinusFunction = function*(context) {
      var operandum;
      yield;
      operandum = context.tempVariablesDict[ValidIDfromString("operandum")];
      return FLNumber.createNew(this.value - operandum.value);
    };
    FLNumber.addMethod(flTokenize("$minus_binary ( operandum )"), BaseMinusFunction);
    FLNumber.addMethod(flTokenize("- ( operandum )"), flTokenize("self $minus_binary operandum"));
    BaseDivideFunction = function*(context) {
      var operandum;
      yield;
      operandum = context.tempVariablesDict[ValidIDfromString("operandum")];
      return FLNumber.createNew(this.value / operandum.value);
    };
    FLNumber.addMethod(flTokenize("$divide_binary ( operandum )"), BaseDivideFunction);
    FLNumber.addMethod(flTokenize("/ ( operandum )"), flTokenize("self $divide_binary operandum"));
    BaseMultiplyFunction = function*(context) {
      var operandum;
      yield;
      operandum = context.tempVariablesDict[ValidIDfromString("operandum")];
      return FLNumber.createNew(this.value * operandum.value);
    };
    FLNumber.addMethod(flTokenize("$multiply_binary ( operandum )"), BaseMultiplyFunction);
    FLNumber.addMethod(flTokenize("* ( operandum )"), flTokenize("self $multiply_binary operandum"));
    FLNumber.addMethod(flTokenize("*= (value)"), flTokenize("self * value"));
    FLNumber.addMethod(flTokenize("minus ( operandum )"), function*(context) {
      var operandum;
      yield;
      operandum = context.tempVariablesDict[ValidIDfromString("operandum")];
      return FLNumber.createNew(this.value - operandum.value);
    });
    FLNumber.addMethod(flTokenize("selftimesminusone"), flTokenize("self * self minus 1"));
    FLNumber.addMethod(flTokenize("times ( ' loopCode )"), function*(context) {
      var i, l, loopCode, ref, toBeReturned;
      loopCode = context.tempVariablesDict[ValidIDfromString("loopCode")];
      console.log("FLNumber ⇒ DO loop code is: " + loopCode.flToString());
      for (i = l = 0, ref = this.value; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
        toBeReturned = (yield* loopCode["eval"](context, loopCode));
        flContexts.pop();
        if (toBeReturned != null) {
          if (context.throwing && (toBeReturned.flClass === FLDone || toBeReturned.flClass === FLBreak)) {
            context.throwing = false;
            if (toBeReturned.value != null) {
              toBeReturned = toBeReturned.value;
            }
            console.log("times loop exited with Done ");
            break;
          }
          if (context.throwing && toBeReturned.flClass === FLReturn) {
            console.log("times loop exited with Return ");
            break;
          }
        }
      }
      context.findAnotherReceiver = true;
      return toBeReturned;
    });
    FLNumber.addMethod(flTokenize("== ( toCompare )"), commonSimpleValueEqualityFunction);
    FLNumber.addMethod(flTokenize("!= ( toCompare )"), commonSimpleValueInequalityFunction);
    FLNumber.addMethod(flTokenize("< ( toCompare )"), function*(context) {
      var toCompare;
      yield;
      toCompare = context.tempVariablesDict[ValidIDfromString("toCompare")];
      if (this.value < toCompare.value) {
        return FLBoolean.createNew(true);
      } else {
        return FLBoolean.createNew(false);
      }
    });
    FLNumber.addMethod(flTokenize("← ( valueToAssign )"), function*(context) {
      var valueToAssign;
      yield;
      console.log("evaluation " + indentation() + "assigning to number! ");
      valueToAssign = context.tempVariablesDict[ValidIDfromString("valueToAssign")];
      this.value = valueToAssign.value;
      return this;
    });
    FLBoolean.addMethod(flTokenize("negate"), function*(context) {
      yield;
      return FLBoolean.createNew(!this.value);
    });
    FLBoolean.addMethod(flTokenize("and ( operandum )"), function*(context) {
      var operandum;
      yield;
      operandum = context.tempVariablesDict[ValidIDfromString("operandum")];
      return FLBoolean.createNew(this.value && operandum.value);
    });
    FLBoolean.addMethod(flTokenize("⇒ ( ' trueBranch )"), function*(context) {
      var toBeReturned, trueBranch;
      context.isTransparent = true;
      trueBranch = context.tempVariablesDict[ValidIDfromString("trueBranch")];
      console.log("FLBoolean ⇒ , predicate value is: " + this.value);
      if (this.value) {
        toBeReturned = (yield* trueBranch["eval"](context, trueBranch));
        flContexts.pop();
        console.log("FLBoolean ⇒ returning result of true branch: " + toBeReturned);
        console.log("FLBoolean ⇒ remaining message after true branch: ");
        console.log("FLBoolean ⇒ message length:  ");
        context.exhaustPreviousContextMessage = true;
        return toBeReturned;
      }
      context.findAnotherReceiver = true;
      return this;
    });
    FLBoolean.addMethod(flTokenize("or ( operandum )"), function*(context) {
      var operandum;
      yield;
      console.log("executing an or! ");
      operandum = context.tempVariablesDict[ValidIDfromString("operandum")];
      return FLBoolean.createNew(this.value || operandum.value);
    });
    FLBoolean.addMethod(flTokenize("== ( toCompare )"), commonSimpleValueEqualityFunction);
    FLBoolean.addMethod(flTokenize("!= ( toCompare )"), commonSimpleValueInequalityFunction);
    FLQuote.addMethod(flTokenize("( ' operandum )"), function*(context) {
      var operandum;
      yield;
      operandum = context.tempVariablesDict[ValidIDfromString("operandum")];
      if (operandum.flClass === FLList) {
        operandum = operandum.evaluatedElementsList(context.previousContext);
      }
      return operandum;
    });
    FLNot.addMethod(flTokenize("( operandum )"), flTokenize("operandum negate"));
    FLList.addMethod(flTokenize("new"), function*(context) {
      yield;
      return this.createNew();
    });
    FLList.addMethod(flTokenize("+ ( elementToBeAppended )"), function*(context) {
      var elementToBeAppended;
      yield;
      elementToBeAppended = context.tempVariablesDict[ValidIDfromString("elementToBeAppended")];
      console.log("appending element to: " + this.flToString() + " : " + elementToBeAppended.toString());
      return this.flListImmutablePush(elementToBeAppended);
    });
    FLList.addMethod(flTokenize("length"), function*(context) {
      yield;
      return FLNumber.createNew(this.length());
    });
    FLList.addMethod(flTokenize("[ (indexValue) ] = (value)"), function*(context) {
      var indexValue, value;
      yield;
      indexValue = context.tempVariablesDict[ValidIDfromString("indexValue")];
      value = context.tempVariablesDict[ValidIDfromString("value")];
      context.findAnotherReceiver = true;
      return this.elementAtSetMutable(indexValue.value, value);
    });
    FLList.addMethod(flTokenize("[ (indexValue) ] += (value)"), function*(context) {
      var indexValue, runThis, toBeReturned, value;
      indexValue = context.tempVariablesDict[ValidIDfromString("indexValue")];
      value = context.tempVariablesDict[ValidIDfromString("value")];
      runThis = flTokenize("(self [indexValue]) += value");
      toBeReturned = (yield* runThis["eval"](context, runThis));
      context.findAnotherReceiver = true;
      this.elementAtSetMutable(indexValue.value, toBeReturned);
      return toBeReturned;
    });
    FLList.addMethod(flTokenize("[ (indexValue) ] *= (value)"), function*(context) {
      var indexValue, runThis, toBeReturned, value;
      indexValue = context.tempVariablesDict[ValidIDfromString("indexValue")];
      value = context.tempVariablesDict[ValidIDfromString("value")];
      runThis = flTokenize("(self [indexValue]) *= value");
      toBeReturned = (yield* runThis["eval"](context, runThis));
      context.findAnotherReceiver = true;
      this.elementAtSetMutable(indexValue.value, toBeReturned);
      return toBeReturned;
    });
    FLList.addMethod(flTokenize("[ (indexValue) ] ++"), function*(context) {
      var indexValue, runThis, toBeReturned;
      indexValue = context.tempVariablesDict[ValidIDfromString("indexValue")];
      runThis = flTokenize("(self [indexValue]) ++");
      toBeReturned = (yield* runThis["eval"](context, runThis));
      this.elementAtSetMutable(indexValue.value, toBeReturned);
      return toBeReturned;
    });
    FLList.addMethod(flTokenize("[ (indexValue) ]"), function*(context) {
      var indexValue;
      yield;
      indexValue = context.tempVariablesDict[ValidIDfromString("indexValue")];
      return this.elementAt(indexValue.value);
    });
    FLList.addMethod(flTokenize("each ( ' variable ) do ( ' code )"), function*(context) {
      var code, i, l, newContext, ref, toBeReturned, variable;
      variable = context.tempVariablesDict[ValidIDfromString("variable")];
      code = context.tempVariablesDict[ValidIDfromString("code")];
      console.log("FLList each do ");
      newContext = new FLContext(context);
      for (i = l = 0, ref = this.value.length; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
        newContext.tempVariablesDict[ValidIDfromString(variable.value)] = this.elementAt(i);
        toBeReturned = (yield* code["eval"](newContext, code));
        if (toBeReturned != null) {
          if (context.throwing && (toBeReturned.flClass === FLDone || toBeReturned.flClass === FLBreak)) {
            context.throwing = false;
            if (toBeReturned.value != null) {
              toBeReturned = toBeReturned.value;
            }
            console.log("list-each-do loop exited with Done ");
            break;
          }
          if (context.throwing && toBeReturned.flClass === FLReturn) {
            console.log("list-each-do loop exited with Return ");
            break;
          }
        }
      }
      return toBeReturned;
    });
    FLAccessUpperContext.addMethod(FLList.emptyMessage(), function*(context) {
      yield;
      console.log("FLAccessUpperContext running emptyMessage");
      context.previousContext.isTransparent = true;
      return this;
    });
    FLConsole.addMethod(flTokenize("print ( thingToPrint )"), function*(context) {
      var stringToPrint, thingToPrint;
      yield;
      thingToPrint = context.tempVariablesDict[ValidIDfromString("thingToPrint")];
      stringToPrint = thingToPrint.flToString();
      console.log("///////// program printout: " + stringToPrint);
      if (typeof textOutputElement !== "undefined" && textOutputElement !== null) {
        textOutputElement.value += stringToPrint;
      }
      environmentPrintout += stringToPrint;
      return thingToPrint;
    });
    FLDone.addMethod(flTokenize("with ( valueToReturn )"), function*(context) {
      var valueToReturn;
      yield;
      valueToReturn = context.tempVariablesDict[ValidIDfromString("valueToReturn")];
      console.log("Done_object thrown with return value: " + valueToReturn.flToString());
      this.value = valueToReturn;
      context.throwing = true;
      this.thrown = true;
      return this;
    });
    FLDone.addMethod(FLList.emptyMessage(), function*(context) {
      yield;
      console.log("Done_object running emptyMessage");
      context.throwing = true;
      this.thrown = true;
      return this;
    });
    FLBreak.addMethod(FLList.emptyMessage(), function*(context) {
      yield;
      console.log("Break_object");
      context.throwing = true;
      return this;
    });
    FLReturn.addMethod(flTokenize("( valueToReturn )"), function*(context) {
      var valueToReturn;
      yield;
      valueToReturn = context.tempVariablesDict[ValidIDfromString("valueToReturn")];
      console.log("Return_object running a value");
      this.value = valueToReturn;
      context.throwing = true;
      return this;
    });
    FLReturn.addMethod(FLList.emptyMessage(), function*(context) {
      yield;
      console.log("Return_object running emptyMessage");
      context.throwing = true;
      this.value = FLNil.createNew();
      return this;
    });
    FLRepeat1.addMethod(flTokenize("( ' loopCode )"), function*(context) {
      var loopCode, toBeReturned;
      context.isTransparent = true;
      loopCode = context.tempVariablesDict[ValidIDfromString("loopCode")];
      console.log("FLRepeat1 ⇒ loop code is: " + loopCode.flToString());
      while (true) {
        toBeReturned = (yield* loopCode["eval"](context, loopCode));
        flContexts.pop();
        console.log("Repeat1 ⇒ returning result after loop cycle: " + toBeReturned);
        console.log("Repeat1 ⇒ returning result CLASS after loop cycle: ");
        console.log("Repeat1 ⇒ remaining message after loop cycle: ");
        console.log("Repeat1 ⇒ message length:  ");
        console.log("Repeat1 ⇒ did I receive a Done? " + ((toBeReturned != null ? toBeReturned.flClass : void 0) === FLDone ? "yes" : "no"));
        if (toBeReturned != null) {
          if (context.throwing && (toBeReturned.flClass === FLDone || toBeReturned.flClass === FLBreak)) {
            context.throwing = false;
            if (toBeReturned.value != null) {
              toBeReturned = toBeReturned.value;
            }
            console.log("Repeat1 ⇒ the loop exited with Done at context depth " + context.depth());
            break;
          }
          if (context.throwing && toBeReturned.flClass === FLReturn) {
            console.log("Repeat1 ⇒ the loop exited with Return ");
            break;
          }
        }
      }
      return toBeReturned;
    });
    repeatFunctionContinuation = function*(context) {
      var howManyTimes, i, l, limit, loopCode, ref, toBeReturned;
      context.isTransparent = true;
      howManyTimes = context.tempVariablesDict[ValidIDfromString("howManyTimes")];
      loopCode = context.tempVariablesDict[ValidIDfromString("loopCode")];
      console.log("FLRepeat2 ⇒ loop code is: " + loopCode.flToString());
      if (howManyTimes.flClass === FLForever) {
        limit = Number.MAX_SAFE_INTEGER;
      } else {
        limit = howManyTimes.value;
      }
      for (i = l = 0, ref = limit; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
        yield "from repeatFunctionContinuation";
        console.log("Repeat2 ⇒ starting a(nother) cycle: ");
        toBeReturned = (yield* loopCode["eval"](context, loopCode));
        flContexts.pop();
        console.log("Repeat2 ⇒ returning result after loop cycle: " + toBeReturned);
        console.log("Repeat2 ⇒ returning result CLASS after loop cycle: ");
        console.log("Repeat2 ⇒ remaining message after loop cycle: ");
        console.log("Repeat2 ⇒ message length:  ");
        console.log("Repeat2 ⇒ did I receive a Done? " + ((toBeReturned != null ? toBeReturned.flClass : void 0) === FLDone ? "yes" : "no"));
        console.log("Repeat2 ⇒ did I receive a thrown object? " + (context.throwing ? "yes" : "no"));
        if (toBeReturned != null) {
          if (context.throwing && (toBeReturned.flClass === FLDone || toBeReturned.flClass === FLBreak)) {
            context.throwing = false;
            if (toBeReturned.value != null) {
              toBeReturned = toBeReturned.value;
            }
            console.log("Repeat2 ⇒ the loop exited with Done at context depth " + context.depth());
            break;
          }
          if (context.throwing && toBeReturned.flClass === FLReturn) {
            console.log("Repeat2 ⇒ the loop exited with Return ");
            break;
          }
        }
      }
      context.findAnotherReceiver = true;
      return toBeReturned;
    };
    FLRepeat2.addMethod(flTokenize("(howManyTimes) :( ' loopCode )"), repeatFunctionContinuation);
    FLEvaluationsCounter.addMethod(FLList.emptyMessage(), function*(context) {
      var stringToPrint;
      yield;
      stringToPrint = "EvaluationsCounter running the \"empty\" method // ";
      console.log(stringToPrint);
      environmentPrintout += stringToPrint;
      return this;
    });
    FLThrow.addMethod(flTokenize("( theError )"), function*(context) {
      var theError;
      yield;
      theError = context.tempVariablesDict[ValidIDfromString("theError")];
      theError.thrown = true;
      console.log("throwing an error: " + theError.value);
      context.throwing = true;
      return theError;
    });
    FLIfThen.addMethod(flTokenize("( predicate ) : ('trueBranch)"), function*(context) {
      var predicate, toBeReturned, trueBranch;
      yield;
      context.isTransparent = true;
      predicate = context.tempVariablesDict[ValidIDfromString("predicate")];
      trueBranch = context.tempVariablesDict[ValidIDfromString("trueBranch")];
      console.log("IfThen ⇒ , predicate value is: " + predicate.value);
      if (predicate.value) {
        console.log("IfThen ⇒ , evaling true branch at depth " + context.depth());
        toBeReturned = (yield* trueBranch["eval"](context, trueBranch));
        flContexts.pop();
        context.findAnotherReceiver = true;
      } else {
        toBeReturned = FLIfFallThrough.createNew();
      }
      return toBeReturned;
    });
    FLIfFallThrough.addMethod(FLList.emptyMessage(), function*(context) {
      yield;
      console.log("no more cases for the if");
      context.findAnotherReceiver = true;
      return this;
    });
    FLIfFallThrough.addMethod(flTokenize("else if ( predicate ): ('trueBranch)"), function*(context) {
      var predicate, toBeReturned, trueBranch;
      yield;
      context.isTransparent = true;
      predicate = context.tempVariablesDict[ValidIDfromString("predicate")];
      trueBranch = context.tempVariablesDict[ValidIDfromString("trueBranch")];
      console.log("IfThen ⇒ , predicate value is: " + predicate.value);
      if (predicate.value) {
        toBeReturned = (yield* trueBranch["eval"](context, trueBranch));
        flContexts.pop();
        context.findAnotherReceiver = true;
      } else {
        toBeReturned = FLIfFallThrough.createNew();
      }
      return toBeReturned;
    });
    FLIfFallThrough.addMethod(flTokenize("else: ('trueBranch)"), function*(context) {
      var toBeReturned, trueBranch;
      context.isTransparent = true;
      trueBranch = context.tempVariablesDict[ValidIDfromString("trueBranch")];
      toBeReturned = (yield* trueBranch["eval"](context, trueBranch));
      flContexts.pop();
      context.findAnotherReceiver = true;
      return toBeReturned;
    });
    FLFakeElse.addMethod(flTokenize("if ( 'predicate ) : ('trueBranch)"), function*(context) {
      yield;
      context.findAnotherReceiver = true;
      return this;
    });
    FLFakeElse.addMethod(flTokenize(": ('trueBranch)"), function*(context) {
      yield;
      context.findAnotherReceiver = true;
      return this;
    });
    FLTry.addMethod(flTokenize(": ( ' code )"), function*(context) {
      var code, toBeReturned;
      code = context.tempVariablesDict[ValidIDfromString("code")];
      toBeReturned = (yield* code["eval"](context, code));
      if (!context.throwing) {
        context.findAnotherReceiver = true;
      }
      context.throwing = false;
      return toBeReturned;
    });
    FLFakeCatch.addMethod(flTokenize("all : ( ' errorHandle )"), function*(context) {
      yield;
      context.findAnotherReceiver = true;
      return this;
    });
    FLFakeCatch.addMethod(flTokenize("( 'theError ) : ( ' errorHandle )"), function*(context) {
      yield;
      context.findAnotherReceiver = true;
      return this;
    });
    pauseFunctionContinuation = function*(context) {
      var endTime, remainingTime, seconds, startTime;
      yield;
      seconds = context.tempVariablesDict[ValidIDfromString("seconds")];
      startTime = new Date().getTime();
      endTime = startTime + seconds.value * 1000;
      while ((remainingTime = new Date().getTime() - endTime) < 0) {
        yield remainingTime;
        "do nothing";
      }
      context.findAnotherReceiver = true;
      return this;
    };
    FLPause.addMethod(flTokenize("( seconds )"), pauseFunctionContinuation);
    FLFor.addMethod(flTokenize("( ' loopVar ) from ( startIndex ) to ( endIndex ) : ( 'loopCode )"), function*(context) {
      var endIndex, forContext, i, l, loopCode, loopVar, loopVarName, ref, ref1, startIndex, toBeReturned;
      context.isTransparent = true;
      loopVar = context.tempVariablesDict[ValidIDfromString("loopVar")];
      startIndex = context.tempVariablesDict[ValidIDfromString("startIndex")];
      endIndex = context.tempVariablesDict[ValidIDfromString("endIndex")];
      loopCode = context.tempVariablesDict[ValidIDfromString("loopCode")];
      loopVarName = loopVar.value;
      forContext = new FLContext(context);
      forContext.isTransparent = true;
      flContexts.jsArrayPush(forContext);
      console.log("FLFor ⇒ loop code is: " + loopCode.flToString());
      for (i = l = ref = startIndex.value, ref1 = endIndex.value; ref <= ref1 ? l <= ref1 : l >= ref1; i = ref <= ref1 ? ++l : --l) {
        console.log("FLFor ⇒ loop iterating variable to " + i);
        forContext.tempVariablesDict[ValidIDfromString(loopVarName)] = FLNumber.createNew(i);
        toBeReturned = (yield* loopCode["eval"](forContext, loopCode));
        flContexts.pop();
        if (toBeReturned != null) {
          if (context.throwing && (toBeReturned.flClass === FLDone || toBeReturned.flClass === FLBreak)) {
            context.throwing = false;
            if (toBeReturned.value != null) {
              toBeReturned = toBeReturned.value;
            }
            console.log("For ⇒ the loop exited with Done ");
            break;
          }
          if (context.throwing && toBeReturned.flClass === FLReturn) {
            console.log("For ⇒ the loop exited with Return ");
            break;
          }
        }
      }
      flContexts.pop();
      context.findAnotherReceiver = true;
      return toBeReturned;
    });
    return FLFor.addMethod(flTokenize("each ( ' variable ) in: ( 'theList ) do: ( 'code )"), function*(context) {
      var code, evalledList, forContext, i, l, ref, theList, toBeReturned, variable;
      yield;
      context.isTransparent = true;
      variable = context.tempVariablesDict[ValidIDfromString("variable")];
      theList = context.tempVariablesDict[ValidIDfromString("theList")];
      code = context.tempVariablesDict[ValidIDfromString("code")];
      if (theList.flClass !== FLList) {
        context.throwing = true;
        return FLException.createNew("for...each expects a list");
      }
      if (theList.isEmpty()) {
        context.findAnotherReceiver = true;
        return theList;
      }
      if (theList.length() === 1) {
        theList = theList.firstElement();
      }
      console.log("evalling list: " + theList.flToString());
      evalledList = (yield* theList["eval"](context, theList));
      console.log("evalled list: " + evalledList.flToString());
      if (context.throwing) {
        theList = theList.evaluatedElementsList(context);
        context.throwing = false;
      } else {
        theList = evalledList;
      }
      if (theList.flClass !== FLList) {
        context.throwing = true;
        return FLException.createNew("for...each expects a list");
      }
      console.log("FLEach do on the list: " + theList.flToString());
      forContext = new FLContext(context);
      forContext.isTransparent = true;
      for (i = l = 0, ref = theList.value.length; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
        console.log("FLEach element at " + i + " : " + (theList.elementAt(i)).flToString());
        forContext.tempVariablesDict[ValidIDfromString(variable.value)] = theList.elementAt(i);
        console.log("FLEach do evaling...: " + code.flToString());
        toBeReturned = (yield* code["eval"](forContext, code));
        if (toBeReturned != null) {
          if (context.throwing && (toBeReturned.flClass === FLDone || toBeReturned.flClass === FLBreak)) {
            context.throwing = false;
            if (toBeReturned.value != null) {
              toBeReturned = toBeReturned.value;
            }
            console.log("for-each-in-list loop exited with Done ");
            break;
          }
          if (context.throwing && toBeReturned.flClass === FLReturn) {
            console.log("for-each-in-list loop exited with Return ");
            break;
          }
        }
      }
      context.findAnotherReceiver = true;
      return toBeReturned;
    });
  };

  flContexts = [];

  rWorkspace = null;

  environmentPrintout = "";

  environmentErrors = "";

  initContext = function(context) {
    var itsInitialisation, j, keyword, keywords, keywordsAndTheirInit, ref, ref1, results;
    keywordsAndTheirInit = ["WorkSpace", FLWorkspace, "Class", FLClass, "List", FLList, "String", FLString, "Exception", FLException, "Number", FLNumber, "Boolean", FLBoolean, "Console", FLConsole, "not", FLNot.createNew(), "true", FLBoolean.createNew(true), "false", FLBoolean.createNew(false), "for", FLFor.createNew(), "repeat1", FLRepeat1.createNew(), "done", FLDone.createNew(), "break", FLBreak.createNew(), "return", FLReturn.createNew(), "if", FLIfThen.createNew(), "else", FLFakeElse.createNew(), "forever", FLForever.createNew(), "repeat", FLRepeat2.createNew(), "try", FLTry.createNew(), "throw", FLThrow.createNew(), "catch", FLFakeCatch.createNew(), "to", FLTo.createNew(), "in", FLIn.createNew(), "accessUpperContext", FLAccessUpperContext.createNew(), "evaluationsCounter", FLEvaluationsCounter.createNew(), "nil", FLNil.createNew(), "console", FLConsole.createNew(), "pause", FLPause.createNew(), "'", FLQuote.createNew(), ":", FLQuote.createNew()];
    results = [];
    for (keywords = j = 0, ref = keywordsAndTheirInit.length; j < ref; keywords = j += 2) {
      ref1 = keywordsAndTheirInit.slice(keywords, +(keywords + 1) + 1 || 9e9), keyword = ref1[0], itsInitialisation = ref1[1];
      results.push(context.tempVariablesDict[ValidIDfromString(keyword)] = itsInitialisation);
    }
    return results;
  };

  quickReset = function() {
    environmentPrintout = "";
    environmentErrors = "";
    rWorkspace = FLWorkspace.createNew();
    outerMostContext = new FLContext(null, rWorkspace);
    flContexts.jsArrayPush(outerMostContext);
    return initContext(outerMostContext);
  };

  reset = function() {
    clearClasses();
    initBootClasses();
    return quickReset();
  };

  textOutputElement = null;

  Fizzylogo.init = function(textOutElem) {
    textOutputElement = textOutElem;
    return reset();
  };

  Fizzylogo.runOneStep = function*(code) {
    var parsed, returned;
    quickReset();
    parsed = flTokenize(code);
    console.log("evaluation " + indentation() + "messaging workspace with " + parsed.flToString());
    returned = (yield* parsed["eval"](outerMostContext, parsed));
    outerMostContext.returned = returned.value;
    console.log("evaluation " + indentation() + "end of workspace evaluation");
    if (outerMostContext.throwing && outerMostContext.returned.flClass === FLException) {
      console.log("evaluation " + indentation() + "exception: " + outerMostContext.returned.value);
      environmentErrors += "! exception: " + outerMostContext.returned.value;
      if (textOutputElement != null) {
        textOutputElement.value += environmentErrors + "\n";
      }
    }
    return null;
  };

  run = function(code) {
    var gen, parsed, ret, yieldMode;
    quickReset();
    parsed = flTokenize(code);
    console.log("evaluation " + indentation() + "messaging workspace with " + parsed.flToString());
    yieldMode = false;
    yieldMode = true;
    if (yieldMode) {
      gen = parsed["eval"](outerMostContext, parsed);
      while (!(ret = gen.next()).done) {
        if (ret.value != null) {
          console.log("obtained: " + ret.value);
        }
        console.log("obtained: yieldingfromtoplevel");
      }
      outerMostContext.returned = ret.value;
    } else {
      outerMostContext.returned = parsed["eval"](outerMostContext, parsed);
    }
    console.log("evaluation " + indentation() + "end of workspace evaluation");
    if (outerMostContext.throwing && outerMostContext.returned.flClass === FLException) {
      console.log("evaluation " + indentation() + "exception: " + outerMostContext.returned.value);
      environmentErrors += "! exception: " + outerMostContext.returned.value;
    }
    return null;
  };

}).call(this);
