// Generated by CoffeeScript 1.12.7
(function() {
  var DEBUG_STRINGIFICATION_CHECKS, FLAccessUpperContext, FLAccessUpperContextClass, FLBoolean, FLBooleanClass, FLBreak, FLBreakClass, FLClass, FLClassClass, FLClasses, FLConsole, FLConsoleClass, FLContext, FLDone, FLDoneClass, FLEvaluationsCounter, FLEvaluationsCounterClass, FLException, FLExceptionClass, FLFor, FLForClass, FLForever, FLForeverClass, FLIfFallThrough, FLIfFallThroughClass, FLIfThen, FLIfThenClass, FLIn, FLInClass, FLList, FLListClass, FLListLiteralArrayNotation, FLListLiteralArrayNotationClass, FLListLiteralArrayNotationStarter, FLListLiteralArrayNotationStarterClass, FLNil, FLNilClass, FLNot, FLNotClass, FLNumber, FLNumberClass, FLObjects, FLPause, FLPauseClass, FLQuote, FLQuoteClass, FLRepeat1, FLRepeat1Class, FLRepeat2, FLRepeat2Class, FLReturn, FLReturnClass, FLString, FLStringClass, FLThrow, FLThrowClass, FLTo, FLToClass, FLToken, FLTokenClass, FLTry, FLTryClass, FLTurtle, FLTurtleClass, FLUnaryMinus, FLUnaryMinusClass, FLWorkspace, FLWorkspaceClass, Fizzylogo, StringFromValidID, ValidIDfromString, addDefaultMethods, allClasses, bootClasses, canvasOutputElement, clearClasses, commonSimpleValueEqualityFunction, commonSimpleValueInequalityFunction, contextDebug, devicePixelRatio, dir, flClassesDebug, flTokenize, indentation, initBootClasses, initContext, injectStrings, keyStr, linearize, listEvaluationsDebug, log, mainTurtle, methodsExecutionDebug, objectFindSignatureMakeCallDebug, outerMostContext, quickReset, rWorkspace, removeComments, removeStatementSeparatorsBeforeAlignedConstructs, removeStrings, repeatFunctionContinuation, reset, run, sortFirstArrayAccordingToSecond, stringsTable_TO_CHECK_CONVERTIONS, textOutputElement, tokenizeCommand, tokenizerDebug, tokensDebug,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Fizzylogo = {};

  (typeof exports !== "undefined" && exports !== null ? exports : this).Fizzylogo = Fizzylogo;

  objectFindSignatureMakeCallDebug = false;

  listEvaluationsDebug = false;

  tokensDebug = false;

  tokenizerDebug = false;

  contextDebug = false;

  flClassesDebug = false;

  methodsExecutionDebug = false;

  rWorkspace = null;

  log = console.log;

  dir = console.dir;

  repeatFunctionContinuation = null;

  outerMostContext = null;

  DEBUG_STRINGIFICATION_CHECKS = false;

  if (DEBUG_STRINGIFICATION_CHECKS) {
    stringsTable_TO_CHECK_CONVERTIONS = {};
  }

  indentation = function() {
    return "";
  };

  Array.prototype.jsArrayPush = function(element) {
    return this.push(element);
  };

  keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789Γಠ_';

  ValidIDfromString = function(input) {
    var chr1, chr2, chr3, enc1, enc2, enc3, enc4, i, output, utf8_encode;
    if (/^([A-Z_][0-9A-Z_$]*)$/gi.test(input)) {
      return input;
    }
    utf8_encode = function(string) {
      var c, n, utftext;
      string = string.replace(/\r\n/g, '\n');
      utftext = '';
      n = 0;
      while (n < string.length) {
        c = string.charCodeAt(n);
        if (c < 128) {
          utftext += String.fromCharCode(c);
        } else if (c > 127 && c < 2048) {
          utftext += String.fromCharCode(c >> 6 | 192);
          utftext += String.fromCharCode(c & 63 | 128);
        } else {
          utftext += String.fromCharCode(c >> 12 | 224);
          utftext += String.fromCharCode(c >> 6 & 63 | 128);
          utftext += String.fromCharCode(c & 63 | 128);
        }
        n++;
      }
      return utftext;
    };
    output = '';
    i = 0;
    input = utf8_encode(input);
    while (i < input.length) {
      chr1 = input.charCodeAt(i++);
      chr2 = input.charCodeAt(i++);
      chr3 = input.charCodeAt(i++);
      enc1 = chr1 >> 2;
      enc2 = (chr1 & 3) << 4 | chr2 >> 4;
      enc3 = (chr2 & 15) << 2 | chr3 >> 6;
      enc4 = chr3 & 63;
      if (isNaN(chr2)) {
        enc3 = enc4 = 64;
      } else if (isNaN(chr3)) {
        enc4 = 64;
      }
      output = output + keyStr.charAt(enc1) + keyStr.charAt(enc2) + keyStr.charAt(enc3) + keyStr.charAt(enc4);
    }
    return "$" + output;
  };

  StringFromValidID = function(input) {
    var a, b, c, d, e, f, g, i, output, utf8_decode;
    if (/^([A-Z_][0-9A-Z_$]*)$/gi.test(input)) {
      return input;
    }
    utf8_decode = function(string) {
      var charCode, i, output;
      output = '';
      i = 0;
      charCode = 0;
      while (i < string.length) {
        charCode = string.charCodeAt(i);
        if (charCode < 128) {
          output += String.fromCharCode(charCode);
          i++;
        } else if (charCode > 191 && charCode < 224) {
          output += String.fromCharCode((charCode & 31) << 6 | string.charCodeAt(i + 1) & 63);
          i += 2;
        } else {
          output += String.fromCharCode((charCode & 15) << 12 | (string.charCodeAt(i + 1) & 63) << 6 | string.charCodeAt(i + 2) & 63);
          i += 3;
        }
      }
      return output;
    };
    input = input.replace(/[^ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789Γಠ_]/g, '');
    input = input.replace(/^\$/, '');
    output = '';
    i = 0;
    while (i < input.length) {
      d = keyStr.indexOf(input.charAt(i++));
      e = keyStr.indexOf(input.charAt(i++));
      f = keyStr.indexOf(input.charAt(i++));
      g = keyStr.indexOf(input.charAt(i++));
      a = d << 2 | e >> 4;
      b = (e & 15) << 4 | f >> 2;
      c = (f & 3) << 6 | g;
      output += String.fromCharCode(a);
      if (f !== 64) {
        output += String.fromCharCode(b);
      }
      if (g !== 64) {
        output += String.fromCharCode(c);
      }
    }
    return utf8_decode(output);
  };

  sortFirstArrayAccordingToSecond = function(targetData, refData) {
    var indices, j, ref, results;
    indices = (function() {
      results = [];
      for (var j = 0, ref = targetData.length; 0 <= ref ? j < ref : j > ref; 0 <= ref ? j++ : j--){ results.push(j); }
      return results;
    }).apply(this);
    indices.sort(function(indexA, indexB) {
      if (refData[indexA] < refData[indexB]) {
        return -1;
      } else if (refData[indexA] > refData[indexB]) {
        return 1;
      }
      return 0;
    });
    return indices.map(function(index) {
      return targetData[index];
    });
  };

  allClasses = [];

  tokenizeCommand = function(command) {
    command = command.replace(/'[ ]*s[\s]/g, ".");
    command = command.replace(/\(/g, " ( ");
    command = command.replace(/\)/g, " ) ");
    command = command.replace(/\[/g, " [ ");
    command = command.replace(/\]/g, " ] ");
    command = command.replace(/,/g, " , ");
    command = command.replace(/;/g, " ; ");
    command = command.replace(/@([^\]);\s])/g, " self . $1");
    command = command.replace(/@/g, " self ");
    command = command.replace(/([0-9]*\.[0-9]+([eE][- ]?[0-9]*)?)|([^+\-^*\/()\[\]=←.!%])([+\-^*\/()\[\]=←.!%]+)/g, "$1$3 $4 ");
    command = command.replace(/([+\-^*\/()\[\]=←!%])([^+\-^*\/()\[\]=←!%])/g, "$1 $2");
    command = command.replace(/([+\-^*\/=←!%_])[ ]+_/g, "$1_ ");
    command = command.replace(/'/g, " ' ");
    command = command.replace(/:/g, " : ");
    command = command.replace(/[ ]+/g, " ");
    return command = command.trim();
  };

  removeComments = function(code) {
    return code.replace(/(^)\/\*[\s\S]*?\*\/\n?|([^\\\n])\/\*[\s\S]*?\*\/|(^)\/\/.*$\n|([^\\\n])\/\/.*$|\n\/\/.*$|\n\/\*[\s\S]*?\*\n/gm, "$1$2$3$4");
  };

  removeStrings = function(code) {
    var codeWithoutStrings;
    codeWithoutStrings = code.replace(/"((?:[^"\\\n]|\\.)*)"/g, function(all, quoted) {
      if (DEBUG_STRINGIFICATION_CHECKS) {
        stringsTable_TO_CHECK_CONVERTIONS[ValidIDfromString(quoted)] = quoted;
      }
      return "$STRING_TOKEN_" + (ValidIDfromString(quoted));
    });
    return codeWithoutStrings;
  };

  injectStrings = function(code) {
    code = code.replace(/\$STRING_TOKEN_([\$a-zA-Z0-9_]+)/g, function(all, index) {
      var val;
      val = StringFromValidID(index);
      if (DEBUG_STRINGIFICATION_CHECKS) {
        if (val !== stringsTable_TO_CHECK_CONVERTIONS[index]) {
          throw "ERROR cannot get back string from ID, got back: " + StringFromValidID(index);
        }
      }
      return val;
    });
    return code;
  };

  linearize = function(code) {
    var actualLineTabs, correctedIndentationDifference, correctedLineTabs, eachLine, j, k, l, leftOrRightOrAligned, line, linesWithBlockStart, match, outputSource, ref, ref1, rx, sourceByLine, startOfPreviousLine, startOfThisLine, unclosedParens;
    code = code.replace(/﹍/g, " ");
    code = code.replace(/^\s*[\r\n]/gm, "");
    sourceByLine = code.split("\n");
    startOfPreviousLine = "";
    linesWithBlockStart = [];
    unclosedParens = 0;
    outputSource = "";
    actualLineTabs = [];
    correctedLineTabs = [];
    for (eachLine = j = 0, ref = sourceByLine.length; 0 <= ref ? j < ref : j > ref; eachLine = 0 <= ref ? ++j : --j) {
      line = sourceByLine[eachLine];
      rx = RegExp("^([ ]*)", 'gm');
      match = rx.exec(line);
      if (eachLine === 0) {
        outputSource += " " + line;
        actualLineTabs.push(0);
        correctedLineTabs.push(0);
        continue;
      }
      startOfThisLine = match[1];
      leftOrRightOrAligned = startOfThisLine.length - actualLineTabs[actualLineTabs.length - 1];
      actualLineTabs.push(startOfThisLine.length);
      if (tokenizerDebug) {
        log("linearize startOfThisLine: " + startOfThisLine + " " + startOfThisLine.length + " difference in alignment: " + leftOrRightOrAligned + " content: " + line);
      }
      if (leftOrRightOrAligned === 0) {
        correctedIndentationDifference = 0;
        outputSource += " ; " + line;
      } else if (leftOrRightOrAligned > 0) {
        correctedIndentationDifference = 1;
        if (tokenizerDebug) {
          log("linearize adding a ( ");
        }
        outputSource += (Array(correctedIndentationDifference + 1).join("(")) + line;
      } else {
        for (k = l = ref1 = actualLineTabs.length - 2; ref1 <= 0 ? l <= 0 : l >= 0; k = ref1 <= 0 ? ++l : --l) {
          if (tokenizerDebug) {
            log(" k: " + k + " checking line " + sourceByLine[k] + " for alignment ");
          }
          if (actualLineTabs[k] <= startOfThisLine.length) {
            if (tokenizerDebug) {
              log("line " + sourceByLine[k] + " is aligned with me and the corrected tabs for that were: " + correctedLineTabs[k]);
            }
            correctedIndentationDifference = correctedLineTabs[k] - correctedLineTabs[correctedLineTabs.length - 1];
            break;
          }
        }
        if (tokenizerDebug) {
          log("linearize adding " + (-correctedIndentationDifference) + " ) ");
        }
        if (actualLineTabs[k] === startOfThisLine.length) {
          outputSource += (Array(-correctedIndentationDifference + 1).join(")")) + " ; " + line;
        } else {
          outputSource += (Array(-correctedIndentationDifference + 1).join(")")) + line;
        }
      }
      unclosedParens += correctedIndentationDifference;
      correctedLineTabs.push(unclosedParens);
    }
    outputSource += Array(unclosedParens + 1).join(")");
    if (tokenizerDebug) {
      log("linearized program: " + outputSource.replace(/^[ ]*/g, ""));
    }
    return outputSource.replace(/^[ ]*/g, "");
  };

  removeStatementSeparatorsBeforeAlignedConstructs = function(command) {
    var eachToken, j, len, ref;
    ref = ["else", "catch"];
    for (j = 0, len = ref.length; j < len; j++) {
      eachToken = ref[j];
      command = command.replace(new RegExp("[; ]*(" + eachToken + "[ \n])", "g"), " $1");
    }
    command = command.replace(/[ ]+/g, " ");
    command = command.trim();
    return command;
  };

  flTokenize = function(command) {
    var eachToken, j, len, listsStack, nestedList, simpleTokenization;
    listsStack = [];
    listsStack.jsArrayPush(FLList.createNew());
    command = command.replace(/\\\n[ ]*/g, " ");
    command = removeComments(command);
    command = removeStrings(command);
    if (tokenizerDebug) {
      log("codeWithoutStrings: " + command);
    }
    command = linearize(command);
    if (tokenizerDebug) {
      log("linearized command: " + command);
    }
    if (tokenizerDebug) {
      log("command before replacements: " + command);
    }
    command = tokenizeCommand(command);
    if (tokenizerDebug) {
      log("command after replacements: " + command);
    }
    command = removeStatementSeparatorsBeforeAlignedConstructs(command);
    if (tokenizerDebug) {
      log("removed statement separators before aligned constructs: " + command);
    }
    simpleTokenization = command.split(" ");
    for (j = 0, len = simpleTokenization.length; j < len; j++) {
      eachToken = simpleTokenization[j];
      if (tokenizerDebug) {
        log("eachToken: " + eachToken);
      }
      if (/\$STRING_TOKEN_([\$a-zA-Z0-9_]+)/g.test(eachToken)) {
        if (tokenizerDebug) {
          log(eachToken + " is a string literal");
        }
        listsStack[listsStack.length - 1] = listsStack[listsStack.length - 1].flListImmutablePush(FLToken.createNew(eachToken));
      } else if (/^\($/.test(eachToken)) {
        nestedList = FLList.createNew();
        listsStack.jsArrayPush(nestedList);
      } else if (/^\)$/.test(eachToken)) {
        nestedList = listsStack.pop();
        listsStack[listsStack.length - 1] = listsStack[listsStack.length - 1].flListImmutablePush(nestedList);
      } else {
        if (tokenizerDebug) {
          log(eachToken + " is something else");
        }
        listsStack[listsStack.length - 1] = listsStack[listsStack.length - 1].flListImmutablePush(FLToken.createNew(eachToken));
      }
    }
    return listsStack[listsStack.length - 1];
  };

  FLObjects = (function() {
    FLObjects.prototype.flClass = null;

    FLObjects.prototype.instanceVariablesDict = null;

    function FLObjects(flClass) {
      this.flClass = flClass;
      this.instanceVariablesDict = {};
      this.instanceVariablesDict[ValidIDfromString("class")] = this.flClass;
    }

    FLObjects.prototype.isClass = function() {
      return this.name != null;
    };

    FLObjects.prototype.methodsHolder = function() {
      if (this.isClass()) {
        return this;
      } else {
        return this.flClass;
      }
    };

    FLObjects.prototype.flToString = function() {
      if (this.isClass()) {
        if (this.name === "") {
          return "[anonymous class (an object of class Class)]";
        } else {
          return "[class \"" + this.name + "\" (an object of class Class)]";
        }
      } else if (this.flClass.name !== "") {
        return "[object of class \"" + this.flClass.name + "\"]";
      } else {
        return "[object of anonymous class]";
      }
    };

    FLObjects.prototype.flToStringForList = function() {
      return this.flToString();
    };

    FLObjects.prototype["eval"] = function*(theContext) {
      yield;
      return this;
    };

    FLObjects.prototype.findSignatureBindParamsAndMakeCall = function*(methodInvocationToBeChecked, theContext, previousPriority) {
      var classContainingMethods, contextToBeReturned, eachElementOfInvocation, eachElementOfSignature, eachPriority, eachSignature, eachSignatureIndex, goodMatchSoFar, j, methodInvocation, newContext, originalMethodInvocationStart, paramToken, ref, ref1, ref2, ref3, ref4, returnedContext, valueToBeBound;
      if (objectFindSignatureMakeCallDebug) {
        log("object findSignature+makeCall: looking up method invocation " + methodInvocationToBeChecked.flToString() + " with signatures!");
        log("object findSignature+makeCall: looking up method invocation, is method empty? " + methodInvocationToBeChecked.isEmpty());
        log("object findSignature+makeCall: I am: " + this.value);
      }
      classContainingMethods = this.methodsHolder();
      for (eachSignatureIndex = j = 0, ref = classContainingMethods.msgPatterns.length; 0 <= ref ? j < ref : j > ref; eachSignatureIndex = 0 <= ref ? ++j : --j) {
        eachSignature = classContainingMethods.msgPatterns[eachSignatureIndex];
        eachPriority = classContainingMethods.priorities[eachSignatureIndex];
        goodMatchSoFar = true;
        if (objectFindSignatureMakeCallDebug) {
          log("object findSignature+makeCall: previousPriority, eachPriority: " + previousPriority + " , " + eachPriority);
        }
        if ((previousPriority != null) && (eachPriority != null)) {
          if (previousPriority <= eachPriority) {
            if (objectFindSignatureMakeCallDebug) {
              log("breaking matching due to priority going up: previousPriority, eachPriority: " + previousPriority + " , " + eachPriority);
            }
            goodMatchSoFar = false;
          }
        }
        methodInvocation = methodInvocationToBeChecked;
        newContext = new FLContext(theContext, this);
        originalMethodInvocationStart = methodInvocation.cursorStart;
        if (goodMatchSoFar) {
          while (!(eachSignature.isEmpty() || methodInvocation.isEmpty())) {
            if (objectFindSignatureMakeCallDebug) {
              log("evaluation " + indentation() + "  matching: - next signature piece: " + eachSignature.flToString() + " is token: " + " with: " + methodInvocation.flToString());
            }
            ref1 = eachSignature.nextElement(), eachElementOfSignature = ref1[0], eachSignature = ref1[1];
            if (eachElementOfSignature.flClass !== FLList && eachElementOfSignature.flClass !== FLToken) {
              theContext.throwing = true;
              theContext.returned = FLException.createNew("signature of a method should only contain tokens or lists. Found instead: " + eachElementOfSignature.flToString() + " . Perhaps some variable in the signature has been closed?");
              return [theContext, methodInvocationToBeChecked];
            }
            if (eachElementOfSignature.flClass === FLToken) {
              ref2 = methodInvocation.nextElement(), eachElementOfInvocation = ref2[0], methodInvocation = ref2[1];
              if (objectFindSignatureMakeCallDebug) {
                log("******* evaluation " + indentation() + "  matching tokens: - next signature piece: " + eachElementOfSignature.flToString() + " is token: " + (eachElementOfSignature.flClass === FLToken) + " with: " + eachElementOfInvocation.flToString());
              }
              if (eachElementOfSignature.value === eachElementOfInvocation.value) {
                if (objectFindSignatureMakeCallDebug) {
                  log("evaluation " + indentation() + "  matching - token matched: " + eachElementOfSignature.flToString());
                }
                continue;
              } else {
                goodMatchSoFar = false;
                break;
              }
            } else {
              if (objectFindSignatureMakeCallDebug) {
                log("evaluation " + indentation() + "  matching - getting the token inside the parameter: " + eachElementOfSignature.flToString());
              }
              paramToken = eachElementOfSignature.getParamToken();
              if (objectFindSignatureMakeCallDebug) {
                log("evaluation " + indentation() + "  matching - token inside the parameter: " + paramToken.flToString());
              }
              if (eachElementOfSignature.isEvaluatingParam()) {
                if (objectFindSignatureMakeCallDebug) {
                  log("evaluation " + indentation() + "  matching - need to evaluate next msg element from invocation: " + methodInvocation.flToString() + " and bind to: " + paramToken.flToString());
                }
                ref3 = (yield* methodInvocation.partialEvalAsMessage(theContext, eachPriority)), returnedContext = ref3[0], methodInvocation = ref3[1];
                valueToBeBound = returnedContext.returned;
              } else {
                if (objectFindSignatureMakeCallDebug) {
                  log("evaluation " + indentation() + "  matching - need to get next msg element from invocation: " + methodInvocation.flToString() + " and bind to: " + paramToken.flToString());
                }
                ref4 = methodInvocation.nextElement(), valueToBeBound = ref4[0], methodInvocation = ref4[1];
              }
              if (objectFindSignatureMakeCallDebug) {
                log("evaluation " + indentation() + "  matching - adding paramater " + paramToken.flToString() + " to tempVariables dictionary in current frame");
              }
              newContext.tempVariablesDict[ValidIDfromString(paramToken.value)] = valueToBeBound;
              continue;
            }
          }
        }
        if (eachSignature.isEmpty() && goodMatchSoFar) {
          if (objectFindSignatureMakeCallDebug) {
            log("evaluation " + indentation() + "  matching - consumed from matching this sig: " + (methodInvocation.cursorStart - originalMethodInvocationStart));
            log("evaluation " + indentation() + "             methodInvocation: " + methodInvocation.flToString() + " cursor start: " + methodInvocation.cursorStart + " original methodInvocation start: " + originalMethodInvocationStart);
            log("methodInvocation.cursorStart - originalMethodInvocationStart: " + " " + methodInvocation.cursorStart + " " + originalMethodInvocationStart);
            log("theContext method invocation after: " + methodInvocation.flToString());
          }
          theContext.unparsedMessage = null;
          contextToBeReturned = (yield* this.methodCall(classContainingMethods.methodBodies[eachSignatureIndex], newContext, methodInvocationToBeChecked.definitionContext));
          return [contextToBeReturned, methodInvocation];
        }
      }
      if (objectFindSignatureMakeCallDebug) {
        log("evaluation " + indentation() + "  matching - no match found");
      }
      return [null, methodInvocationToBeChecked];
    };

    FLObjects.prototype.methodCall = function*(methodBody, theContext, definitionContext) {
      var contextToBeReturned;
      yield;
      if (methodBody.flClass === FLList) {
        if (objectFindSignatureMakeCallDebug) {
          log("evaluation " + indentation() + "  matching - method body: " + methodBody.flToString());
        }
        theContext.returned = (yield* methodBody["eval"](theContext, methodBody));
      } else {
        if (objectFindSignatureMakeCallDebug) {
          log("evaluation " + indentation() + "  matching - NATIVE method body: " + methodBody);
        }
        theContext.returned = (yield* methodBody.call(this, theContext, definitionContext));
      }
      contextToBeReturned = theContext;
      return contextToBeReturned;
    };

    return FLObjects;

  })();

  FLContext = (function() {
    FLContext.prototype.self = null;

    FLContext.prototype.tempVariablesDict = null;

    FLContext.prototype.previousContext = null;

    FLContext.prototype.returned = null;

    FLContext.prototype.isTransparent = false;

    function FLContext(previousContext, newSelf) {
      this.previousContext = previousContext;
      if (newSelf) {
        this.self = newSelf;
      } else {
        this.self = this.previousContext.self;
      }
      this.tempVariablesDict = {};
    }

    FLContext.prototype.depth = function() {
      var ascendingTheContext, depthCount;
      depthCount = 0;
      ascendingTheContext = this.previousContext;
      while (ascendingTheContext != null) {
        depthCount++;
        ascendingTheContext = ascendingTheContext.previousContext;
      }
      return depthCount;
    };

    FLContext.prototype.firstNonTransparentContext = function() {
      var ascendingTheContext, base, base1;
      ascendingTheContext = this;
      while (ascendingTheContext.isTransparent) {
        if (contextDebug) {
          log("evaluation " + indentation() + "firstNonTransparentContext: context is transparent at depth " + ascendingTheContext.depth() + " with self: " + (typeof (base = ascendingTheContext.self).flToString === "function" ? base.flToString() : void 0));
        }
        ascendingTheContext = ascendingTheContext.previousContext;
      }
      if (contextDebug) {
        log("first non-transparent context is the one at depth: " + ascendingTheContext.depth() + " with self: " + (typeof (base1 = ascendingTheContext.self).flToString === "function" ? base1.flToString() : void 0));
      }
      return ascendingTheContext;
    };

    FLContext.prototype.lookupTemp = function(variableNameAsString) {
      return this.tempVariablesDict[ValidIDfromString(variableNameAsString)];
    };

    FLContext.prototype.lookupTempValue = function(variableNameAsString) {
      return (this.lookupTemp(variableNameAsString)).value;
    };

    FLContext.prototype.whichDictionaryContainsToken = function(theToken) {
      var base, base1, contextBeingSearched, tokenString;
      contextBeingSearched = this;
      tokenString = theToken.value;
      if (tokenString === "self") {
        return this.firstNonTransparentContext();
      }
      while (true) {
        if (contextBeingSearched.tempVariablesDict[ValidIDfromString(tokenString)] != null) {
          if (contextDebug) {
            log("evaluation " + indentation() + "lookup: found in context at depth " + contextBeingSearched.depth() + " with self: " + (typeof (base = contextBeingSearched.self).flToString === "function" ? base.flToString() : void 0));
          }
          return contextBeingSearched.tempVariablesDict;
        }
        if (contextDebug) {
          log("evaluation " + indentation() + "lookup: not found in context at depth " + contextBeingSearched.depth() + " with self: " + (typeof (base1 = contextBeingSearched.self).flToString === "function" ? base1.flToString() : void 0));
        }
        if (contextBeingSearched.isTransparent) {
          if (contextDebug) {
            log("evaluation " + indentation() + "lookup: ... this context is transparent so I can go up");
          }
          contextBeingSearched = contextBeingSearched.previousContext;
        } else {
          break;
        }
      }
      if (outerMostContext.tempVariablesDict[ValidIDfromString(tokenString)] != null) {
        return outerMostContext.tempVariablesDict;
      }
      if (contextDebug) {
        log("evaluation " + indentation() + "lookup: " + tokenString + " not found!");
      }
      return null;
    };

    return FLContext;

  })();

  FLClasses = (function(superClass) {
    extend(FLClasses, superClass);

    FLClasses.prototype.name = null;

    FLClasses.prototype.msgPatterns = null;

    FLClasses.prototype.methodBodies = null;

    FLClasses.prototype.priorities = null;

    function FLClasses(name) {
      this.name = name;
      FLClasses.__super__.constructor.call(this, this);
      this.flClass = FLClass;
      this.resetInstanceVariables();
      this.value = this;
      if (!this.isClass()) {
        this.name = this.constructor.name;
        this.name = this.name.substr(2, this.name.length - 7);
      }
      this.resetMethods();
      allClasses.push(this);
    }

    FLClasses.prototype.rename = function(newName) {
      return this.name = newName;
    };

    FLClasses.prototype.resetMethods = function() {
      this.msgPatterns = [];
      this.methodBodies = [];
      return this.priorities = [];
    };

    FLClasses.prototype.resetInstanceVariables = function() {
      this.instanceVariablesDict = {};
      return this.instanceVariablesDict[ValidIDfromString("class")] = FLClass;
    };

    FLClasses.prototype.createNew = function(theClass) {
      var toBeReturned;
      toBeReturned = new FLObjects(theClass);
      return toBeReturned;
    };

    FLClasses.prototype.addMethod = function(signature, methodBody, priority) {
      var eachSignature, i, j, ref, sortOrderStrings;
      for (i = j = 0, ref = this.msgPatterns.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        eachSignature = this.msgPatterns[i];
        if (eachSignature.flToString() === signature.flToString()) {
          this.msgPatterns[i] = signature;
          this.methodBodies[i] = methodBody;
          this.priorities[i] = priority;
          if (flClassesDebug) {
            log("adding method  signature (replacing): " + signature.flToString() + " body: " + (typeof methodBody.flToString === "function" ? methodBody.flToString() : void 0));
          }
          return;
        }
      }
      if (flClassesDebug) {
        log("adding method  signature (appending): " + signature.flToString() + " body: " + (typeof methodBody.flToString === "function" ? methodBody.flToString() : void 0));
      }
      this.msgPatterns.jsArrayPush(signature);
      this.methodBodies.jsArrayPush(methodBody);
      this.priorities.jsArrayPush(priority);
      sortOrderStrings = this.msgPatterns.map(function(elem) {
        return elem.sortOrderString();
      });
      this.msgPatterns = sortFirstArrayAccordingToSecond(this.msgPatterns, sortOrderStrings);
      this.methodBodies = sortFirstArrayAccordingToSecond(this.methodBodies, sortOrderStrings);
      return this.priorities = sortFirstArrayAccordingToSecond(this.priorities, sortOrderStrings);
    };

    return FLClasses;

  })(FLObjects);

  FLClassClass = (function(superClass) {
    extend(FLClassClass, superClass);

    function FLClassClass() {
      return FLClassClass.__super__.constructor.apply(this, arguments);
    }

    FLClassClass.prototype.createNew = function(theName) {
      var newUserClass;
      if (theName == null) {
        theName = "";
      }
      newUserClass = new FLClasses(theName);
      addDefaultMethods(newUserClass);
      newUserClass.addMethod(flTokenize("new"), function*(context) {
        var objectTBR, returnedContext, toBeReturned;
        yield;
        log("///////// creating a new object from a user class!");
        objectTBR = newUserClass.createNew();
        objectTBR.flClass = newUserClass;
        objectTBR.instanceVariablesDict[ValidIDfromString("class")] = newUserClass;
        log("///////// creating a new object from a user class - user class of object: " + objectTBR.flClass.flToString());
        log("///////// creating a new object from a user class - objectTBR: " + objectTBR.flToString());
        log("///////// creating a new object from a user class - making space for instanceVariables");
        log("invoking whenNew");
        returnedContext = (yield* objectTBR.findSignatureBindParamsAndMakeCall(flTokenize("whenNew"), context));
        returnedContext = returnedContext[0];
        toBeReturned = returnedContext.returned;
        return toBeReturned;
      });
      newUserClass.addMethod(flTokenize("nameit (newName)"), function*(context) {
        var newName;
        yield;
        newName = context.tempVariablesDict[ValidIDfromString("newName")];
        if (typeof this.rename === "function") {
          this.rename(newName.value);
        }
        return this;
      });
      return newUserClass;
    };

    return FLClassClass;

  })(FLClasses);

  FLClass = new FLClassClass(FLClass);

  FLClass.flClass = FLClass;

  FLClass.instanceVariablesDict[ValidIDfromString("class")] = FLClass;

  FLTokenClass = (function(superClass) {
    extend(FLTokenClass, superClass);

    function FLTokenClass() {
      return FLTokenClass.__super__.constructor.apply(this, arguments);
    }

    FLTokenClass.prototype.createNew = function(tokenString) {
      var toBeReturned;
      toBeReturned = FLTokenClass.__super__.createNew.call(this, FLToken);
      toBeReturned.value = tokenString;
      toBeReturned.flToString = function() {
        var toPrint;
        if (/\$STRING_TOKEN_([\$a-zA-Z0-9_]+)/g.test(this.value)) {
          toPrint = "TOKEN:" + injectStrings(this.value);
        } else {
          toPrint = this.value;
        }
        return toPrint;
      };
      toBeReturned.isStatementSeparator = function() {
        return this.value === ";";
      };
      toBeReturned.whichDictionaryContainsToken = function(theContext, definitionContext) {
        var existingLookedUpValuePlace;
        if (tokensDebug) {
          log("evaluation " + indentation() + "finding location of token: " + this.value);
        }
        existingLookedUpValuePlace = theContext.whichDictionaryContainsToken(this);
        if (existingLookedUpValuePlace != null) {
          if (tokensDebug) {
            log("evaluation " + indentation() + "found token " + this.value + " in running context");
          }
          return existingLookedUpValuePlace;
        } else {
          if (tokensDebug) {
            log("evaluation " + indentation() + " not found token " + this.value + " in running context, ...trying in definitionContext");
          }
          existingLookedUpValuePlace = definitionContext != null ? definitionContext.whichDictionaryContainsToken(this) : void 0;
          if (existingLookedUpValuePlace != null) {
            if (tokensDebug) {
              log("evaluation " + indentation() + "found token " + this.value + " in definition context");
            }
            return existingLookedUpValuePlace;
          }
        }
        if (tokensDebug) {
          log("evaluation " + indentation() + "not found token " + this.value + " anywhere");
          log("evaluation " + indentation() + "creating temp token: " + this.value + " at depth: " + theContext.firstNonTransparentContext().depth() + " with self: " + theContext.firstNonTransparentContext().self.flToString());
        }
        return theContext.firstNonTransparentContext().tempVariablesDict;
      };
      toBeReturned.assignValue = function(theContext, definitionContext, valueToAssign) {
        var dictToPutValueIn;
        dictToPutValueIn = this.whichDictionaryContainsToken(theContext, definitionContext);
        dictToPutValueIn[ValidIDfromString(this.value)] = valueToAssign;
        if (tokensDebug) {
          return log("evaluation " + indentation() + "stored value in dictionary");
        }
      };
      toBeReturned.lookupValue = function(theContext, definitionContext) {
        var existingLookedUpValuePlace;
        if (tokensDebug) {
          log("evaluation " + indentation() + "looking up value of token: " + this.value);
        }
        existingLookedUpValuePlace = this.whichDictionaryContainsToken(theContext, definitionContext);
        if (contextDebug) {
          log("evaluation " + indentation() + "lookup: " + this.value + " also known as " + (ValidIDfromString(this.value)));
          log("evaluation " + indentation() + "lookup: value looked up: ");
        }
        return existingLookedUpValuePlace[ValidIDfromString(this.value)];
      };
      toBeReturned["eval"] = function*(theContext, remainingMessage, fromListElementsEvaluation) {
        var lookupValue, ref;
        yield;
        if ((remainingMessage != null) && remainingMessage.flClass === FLList) {
          if (tokensDebug) {
            log("remainingMessage: " + remainingMessage.flToString());
            log("secondElementIsEqual: " + remainingMessage.secondElementIsEqual());
          }
          if (!fromListElementsEvaluation && (remainingMessage.startsWithIncrementOrDecrementOperator() || remainingMessage.startsWithCompoundAssignmentOperator() || remainingMessage.secondElementIsEqual())) {
            return this;
          }
        }
        lookupValue = this.lookupValue(theContext, remainingMessage.definitionContext);
        if (lookupValue != null) {
          return lookupValue;
        } else if (/^[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?$/.test(this.value)) {
          return FLNumber.createNew(this.value);
        } else if (/\$STRING_TOKEN_([\$a-zA-Z0-9_]+)/g.test(this.value)) {
          return FLString.createNew(injectStrings(this.value));
        } else if (/^true$/.test(this.value)) {
          return FLBoolean.createNew(true);
        } else if (/^false$/.test(this.value)) {
          return FLBoolean.createNew(false);
        }
        if (tokensDebug) {
          log("evaluation " + indentation() + "token " + this.value + " contents: " + ((ref = theContext.returned) != null ? ref.value : void 0));
          log("evaluation " + indentation() + "not found temp token: " + this.value);
        }
        return FLNil.createNew();
      };
      return toBeReturned;
    };

    return FLTokenClass;

  })(FLClasses);

  FLToken = new FLTokenClass();

  FLListClass = (function(superClass) {
    extend(FLListClass, superClass);

    function FLListClass() {
      return FLListClass.__super__.constructor.apply(this, arguments);
    }

    FLListClass.prototype.emptyMessage = function() {
      var newMessage;
      newMessage = FLList.createNew().toMessage();
      return newMessage;
    };

    FLListClass.prototype.emptyList = function() {
      var newMessage;
      newMessage = FLList.createNew();
      return newMessage;
    };

    FLListClass.prototype.createNew = function() {
      var toBeReturned;
      toBeReturned = FLListClass.__super__.createNew.call(this, FLList);
      toBeReturned.value = [];
      toBeReturned.cursorStart = 0;
      toBeReturned.cursorEnd = -1;
      toBeReturned.definitionContext = null;
      toBeReturned.toList = function() {
        this.isMessage = false;
        return this;
      };
      toBeReturned.toMessage = function() {
        this.isMessage = true;
        return this;
      };
      toBeReturned.flListImmutablePush = function(theItemToPush) {
        var copy;
        copy = this.shallowCopy();
        copy.value.jsArrayPush(theItemToPush);
        copy.cursorEnd++;
        return copy;
      };
      toBeReturned.mutablePush = function(theItemToPush) {
        this.value.jsArrayPush(theItemToPush);
        this.cursorEnd++;
        return this;
      };
      toBeReturned.elementAt = function(theElementNumber) {
        if (this.value[this.cursorStart + theElementNumber] != null) {
          return this.value[this.cursorStart + theElementNumber];
        } else {
          return FLNil.createNew();
        }
      };
      toBeReturned.elementAtSetMutable = function(theElementNumber, theValue) {
        if (this.isMessage || this.cursorStart !== 0) {
          throw "elementAtSetMutable: you can't set an element of a message";
        }
        this.value[theElementNumber] = theValue;
        this.cursorEnd = this.value.length - 1;
        return this;
      };
      toBeReturned.sortOrderString = function() {
        var element, i, j, paddingLength, ref, sortOrderString;
        sortOrderString = "";
        for (i = j = 0, ref = this.length(); 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          element = this.elementAt(i);
          if (element.flClass === FLToken) {
            sortOrderString += "a";
          }
          if (element.flClass === FLList) {
            if (element.isEvaluatingParam()) {
              sortOrderString += "c";
            } else {
              sortOrderString += "b";
            }
          }
        }
        paddingLength = 10 - sortOrderString.length;
        return sortOrderString += new Array(paddingLength).join('d');
      };
      toBeReturned.giveDefinitionContextToElements = function(context) {
        var i, j, ref, results;
        results = [];
        for (i = j = 0, ref = this.length(); 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          if (listEvaluationsDebug) {
            log("toBeReturned.giveDefinitionContextToElements");
          }
          if ((this.elementAt(i)).flClass === FLList) {
            results.push((this.elementAt(i)).giveDefinitionContextToElements(context));
          } else {
            results.push((this.elementAt(i)).definitionContext = context);
          }
        }
        return results;
      };
      toBeReturned.flToString = function() {
        var i, j, ref, toBePrinted;
        if (this.length() <= 0) {
          return "empty message";
        }
        toBePrinted = "(";
        for (i = j = 0, ref = this.length(); 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          toBePrinted += " " + this.elementAt(i).flToStringForList();
        }
        toBePrinted += " )";
        return toBePrinted;
      };
      toBeReturned.evalFirstListElementAndTurnRestIntoMessage = function*(theContext) {
        var firstElement, restOfMessage;
        firstElement = this.firstElement();
        if (listEvaluationsDebug) {
          log("           " + indentation() + "evaling element " + firstElement.value);
        }
        theContext.returned = (yield* firstElement["eval"](theContext, this));
        restOfMessage = this.restOfMessage();
        return [theContext, restOfMessage];
      };
      toBeReturned.findReceiver = function*(theContext) {
        var receiver, ref, restOfMessage, returnedContext;
        ref = (yield* this.evalFirstListElementAndTurnRestIntoMessage(theContext)), returnedContext = ref[0], restOfMessage = ref[1];
        receiver = returnedContext.returned;
        if (listEvaluationsDebug) {
          log("evaluation " + indentation() + "remaining part of list to be sent as message is: " + restOfMessage.flToString());
        }
        return [returnedContext, restOfMessage, receiver];
      };
      toBeReturned["eval"] = function*(theContext) {
        var ref, ref1, ref2, returnedContext, returnedMessage;
        ref = (yield* this.partialEvalAsMessage(theContext)), returnedContext = ref[0], returnedMessage = ref[1];
        if (listEvaluationsDebug) {
          log("list eval - returned message: " + returnedMessage.flToString());
          log("list eval - returned context: " + (returnedContext != null ? typeof returnedContext.flToString === "function" ? returnedContext.flToString() : void 0 : void 0));
          log("list eval - returnedcontext.returned: " + ((ref1 = returnedContext.returned) != null ? typeof ref1.flToString === "function" ? ref1.flToString() : void 0 : void 0));
          log("list eval - returnedcontext.unparsedMessage: " + ((ref2 = returnedContext.unparsedMessage) != null ? typeof ref2.flToString === "function" ? ref2.flToString() : void 0 : void 0));
        }
        if (!returnedMessage.isEmpty()) {
          if (listEvaluationsDebug) {
            log("list couldn't be fully evaluated: " + this.flToString() + " unexecutable: " + returnedMessage.flToString());
          }
          theContext.throwing = true;
          return FLException.createNew("message was not understood: " + returnedMessage.flToString());
        }
        return returnedContext.returned;
      };
      toBeReturned.partialEvalAsMessage = function*(theContext, priority) {
        var base, eachStatement, j, len, receiver, ref, ref1, restOfMessage, returnedContext, returnedMessage, statements;
        if (listEvaluationsDebug) {
          log("evaluation " + indentation() + "list received empty message, evaluating content of list");
          log("evaluation " + indentation() + "  i.e. " + this.flToString());
        }
        this.toList();
        statements = this.separateStatements();
        for (j = 0, len = statements.length; j < len; j++) {
          eachStatement = statements[j];
          if (listEvaluationsDebug) {
            log("evaluation " + indentation() + "evaluating single statement");
            log("evaluation " + indentation() + "  i.e. " + eachStatement.flToString());
          }
          returnedContext = theContext;
          restOfMessage = eachStatement;
          ref = (yield* restOfMessage.findReceiver(returnedContext)), returnedContext = ref[0], restOfMessage = ref[1], receiver = ref[2];
          if (listEvaluationsDebug) {
            log("found next receiver and now message is: " + restOfMessage.flToString());
            log("3 returnedContext.throwing: " + returnedContext.throwing);
          }
          while (true) {
            if (theContext.throwing || returnedContext.throwing) {
              if (listEvaluationsDebug) {
                log("throw escape");
              }
              if (listEvaluationsDebug) {
                log("context at depth " + theContext.depth() + " with self: " + (typeof (base = theContext.self).flToString === "function" ? base.flToString() : void 0) + " is transparent: " + theContext.isTransparent);
              }
              if (receiver.flClass === FLReturn && !theContext.isTransparent) {
                if (listEvaluationsDebug) {
                  log("got a return!");
                }
                theContext.throwing = false;
                theContext.returned = receiver.value;
              } else {
                if (listEvaluationsDebug) {
                  log(" throwing the receiver up " + receiver.flToString());
                }
                theContext.throwing = true;
                theContext.returned = receiver;
              }
              return [theContext, FLList.emptyMessage()];
            }
            if (listEvaluationsDebug) {
              log("evaluation " + indentation() + "receiver: " + (receiver != null ? typeof receiver.flToString === "function" ? receiver.flToString() : void 0 : void 0));
              log("evaluation " + indentation() + "message: " + restOfMessage.flToString());
            }
            if ((receiver.flClass === FLNumber || receiver.flClass === FLString || receiver.flClass === FLBoolean) && restOfMessage.isEmpty()) {
              returnedContext = theContext;
              returnedMessage = restOfMessage;
              returnedContext.returned = receiver;
              if (listEvaluationsDebug) {
                log("skipping empty evaluation because basic type ");
              }
            } else {
              ref1 = (yield* receiver.findSignatureBindParamsAndMakeCall(restOfMessage, theContext, priority)), returnedContext = ref1[0], returnedMessage = ref1[1];
            }
            if (returnedContext == null) {
              returnedContext = theContext;
              returnedContext.returned = receiver;
              if (listEvaluationsDebug) {
                log("restOfMessage: " + restOfMessage.flToString());
                log("receiver: " + receiver.flToString());
              }
              returnedContext.unparsedMessage = returnedMessage;
              if (returnedMessage.isEmpty()) {
                break;
              }
              return [returnedContext, returnedMessage];
            }
            receiver = returnedContext.returned;
            restOfMessage = returnedMessage;
            if (listEvaluationsDebug) {
              log("evaluation " + indentation() + "list evaluation returned: " + (receiver != null ? typeof receiver.flToString === "function" ? receiver.flToString() : void 0 : void 0));
              log("theContext.throwing: " + theContext.throwing);
              log("returnedContext.throwing: " + returnedContext.throwing);
              log("restOfMessage: " + restOfMessage);
            }
            if (restOfMessage.isEmpty() && !(theContext.throwing || returnedContext.throwing) && !((receiver != null ? receiver.flClass : void 0) === FLException && (receiver != null ? receiver.thrown : void 0)) && !((receiver != null ? receiver.flClass : void 0) === FLIfFallThrough)) {
              if (listEvaluationsDebug) {
                log("breaking and moving on to next statement");
              }
              break;
            }
          }
          if (listEvaluationsDebug) {
            log("evaluation " + indentation() + "list: nothing more to evaluate");
          }
          theContext.returned = receiver;
        }
        if (listEvaluationsDebug) {
          log("evaluation " + indentation() + "list: theContext.returned: " + theContext.returned);
        }
        return [theContext, restOfMessage];
      };
      toBeReturned.length = function() {
        return this.cursorEnd - this.cursorStart + 1;
      };
      toBeReturned.restOfMessage = function() {
        var copy;
        copy = this.copy();
        copy.cursorStart++;
        return copy;
      };
      toBeReturned.firstElement = function() {
        if (this.cursorStart > this.cursorEnd) {
          throw "no first element, array is empty";
        }
        return this.elementAt(0);
      };
      toBeReturned.startsWithCompoundAssignmentOperator = function() {
        if (this.length() >= 2) {
          if ((this.elementAt(1)).flClass === FLToken) {
            if (/([+\-^*\/%_]+=)/g.test((this.elementAt(1)).value)) {
              if (listEvaluationsDebug) {
                log("startsWithCompoundAssignmentOperator: yes");
              }
              return true;
            }
          }
        }
        if (listEvaluationsDebug) {
          log("startsWithCompoundAssignmentOperator: no");
        }
        return false;
      };
      toBeReturned.startsWithIncrementOrDecrementOperator = function() {
        if (this.length() >= 2) {
          if ((this.elementAt(1)).flClass === FLToken) {
            if ((this.elementAt(1)).value === "++" || (this.elementAt(1)).value === "--") {
              if (listEvaluationsDebug) {
                log("startsWithIncrementOrDecrementOperator: yes");
              }
              return true;
            }
          }
        }
        if (listEvaluationsDebug) {
          log("startsWithIncrementOrDecrementOperator: no");
        }
        return false;
      };
      toBeReturned.secondElementIsEqual = function() {
        if (this.length() >= 2) {
          if ((this.elementAt(1)).flClass === FLToken) {
            if ((this.elementAt(1)).value === "=") {
              return true;
            }
          }
        }
        return false;
      };
      toBeReturned.nextElement = function() {
        return [this.firstElement(), this.restOfMessage()];
      };
      toBeReturned.advanceMessageBy = function(numberOfElements) {
        var copy;
        copy = this.copy();
        copy.cursorStart += numberOfElements;
        return copy;
      };
      toBeReturned.isEmpty = function() {
        return this.length() <= 0;
      };
      toBeReturned.copy = function() {
        var copy;
        copy = FLList.createNew();
        copy.value = this.value;
        copy.cursorStart = this.cursorStart;
        copy.cursorEnd = this.cursorEnd;
        copy.isMessage = this.isMessage;
        copy.definitionContext = this.definitionContext;
        return copy;
      };
      toBeReturned.shallowCopy = function() {
        var copy;
        copy = this.copy();
        copy.value = this.value.slice();
        return copy;
      };
      toBeReturned.isEvaluatingParam = function() {
        return this.length() === 1;
      };
      toBeReturned.getParamToken = function() {
        if (this.isEvaluatingParam()) {
          return this.elementAt(0);
        } else {
          return this.elementAt(1);
        }
      };
      toBeReturned.separateStatements = function() {
        var arrayOfStatements, base, base1, base2, i, j, lastStatementEnd, ref, ref1, statementToBeAdded;
        arrayOfStatements = [];
        lastStatementEnd = this.cursorStart - 1;
        for (i = j = ref = this.cursorStart, ref1 = this.cursorEnd; ref <= ref1 ? j <= ref1 : j >= ref1; i = ref <= ref1 ? ++j : --j) {
          if ((typeof (base = this.value[i]).isStatementSeparator === "function" ? base.isStatementSeparator() : void 0) || (i === this.cursorEnd)) {
            statementToBeAdded = this.copy().toList();
            statementToBeAdded.cursorStart = lastStatementEnd + 1;
            statementToBeAdded.cursorEnd = i - 1;
            if (i === this.cursorEnd && !(typeof (base1 = this.value[this.cursorEnd]).isStatementSeparator === "function" ? base1.isStatementSeparator() : void 0)) {
              statementToBeAdded.cursorEnd++;
            }
            lastStatementEnd = i;
            if (!statementToBeAdded.isEmpty() && !(typeof (base2 = statementToBeAdded.firstElement()).isStatementSeparator === "function" ? base2.isStatementSeparator() : void 0)) {
              arrayOfStatements.jsArrayPush(statementToBeAdded);
            }
          }
        }
        return arrayOfStatements;
      };
      return toBeReturned;
    };

    return FLListClass;

  })(FLClasses);

  FLList = new FLListClass();

  FLListLiteralArrayNotationStarterClass = (function(superClass) {
    extend(FLListLiteralArrayNotationStarterClass, superClass);

    function FLListLiteralArrayNotationStarterClass() {
      return FLListLiteralArrayNotationStarterClass.__super__.constructor.apply(this, arguments);
    }

    FLListLiteralArrayNotationStarterClass.prototype.createNew = function() {
      var toBeReturned;
      toBeReturned = FLListLiteralArrayNotationStarterClass.__super__.createNew.call(this, FLListLiteralArrayNotationStarter);
      toBeReturned.value = "[";
      return toBeReturned;
    };

    return FLListLiteralArrayNotationStarterClass;

  })(FLClasses);

  FLListLiteralArrayNotationStarter = new FLListLiteralArrayNotationStarterClass();

  FLListLiteralArrayNotationClass = (function(superClass) {
    extend(FLListLiteralArrayNotationClass, superClass);

    function FLListLiteralArrayNotationClass() {
      return FLListLiteralArrayNotationClass.__super__.constructor.apply(this, arguments);
    }

    FLListLiteralArrayNotationClass.prototype.createNew = function() {
      var toBeReturned;
      toBeReturned = FLListLiteralArrayNotationClass.__super__.createNew.call(this, FLListLiteralArrayNotation);
      toBeReturned.value = FLList.createNew();
      return toBeReturned;
    };

    return FLListLiteralArrayNotationClass;

  })(FLClasses);

  FLListLiteralArrayNotation = new FLListLiteralArrayNotationClass();

  FLQuoteClass = (function(superClass) {
    extend(FLQuoteClass, superClass);

    function FLQuoteClass() {
      return FLQuoteClass.__super__.constructor.apply(this, arguments);
    }

    FLQuoteClass.prototype.createNew = function() {
      return FLQuoteClass.__super__.createNew.call(this, FLQuote);
    };

    return FLQuoteClass;

  })(FLClasses);

  FLQuote = new FLQuoteClass();

  FLBooleanClass = (function(superClass) {
    extend(FLBooleanClass, superClass);

    function FLBooleanClass() {
      return FLBooleanClass.__super__.constructor.apply(this, arguments);
    }

    FLBooleanClass.prototype.createNew = function(value) {
      var toBeReturned;
      toBeReturned = FLBooleanClass.__super__.createNew.call(this, FLBoolean);
      toBeReturned.value = value;
      toBeReturned.flToString = function() {
        return this.value;
      };
      return toBeReturned;
    };

    return FLBooleanClass;

  })(FLClasses);

  FLBoolean = new FLBooleanClass();

  FLIfThenClass = (function(superClass) {
    extend(FLIfThenClass, superClass);

    function FLIfThenClass() {
      return FLIfThenClass.__super__.constructor.apply(this, arguments);
    }

    FLIfThenClass.prototype.createNew = function() {
      return FLIfThenClass.__super__.createNew.call(this, FLIfThen);
    };

    return FLIfThenClass;

  })(FLClasses);

  FLIfThen = new FLIfThenClass();

  FLIfFallThroughClass = (function(superClass) {
    extend(FLIfFallThroughClass, superClass);

    function FLIfFallThroughClass() {
      return FLIfFallThroughClass.__super__.constructor.apply(this, arguments);
    }

    FLIfFallThroughClass.prototype.createNew = function() {
      return FLIfFallThroughClass.__super__.createNew.call(this, FLIfFallThrough);
    };

    return FLIfFallThroughClass;

  })(FLClasses);

  FLIfFallThrough = new FLIfFallThroughClass();

  FLExceptionClass = (function(superClass) {
    extend(FLExceptionClass, superClass);

    function FLExceptionClass() {
      return FLExceptionClass.__super__.constructor.apply(this, arguments);
    }

    FLExceptionClass.prototype.createNew = function(value) {
      var toBeReturned;
      toBeReturned = FLExceptionClass.__super__.createNew.call(this, FLException);
      toBeReturned.value = value;
      toBeReturned.flToString = function() {
        return this.value;
      };
      return toBeReturned;
    };

    return FLExceptionClass;

  })(FLClasses);

  FLException = new FLExceptionClass();

  FLRepeat1Class = (function(superClass) {
    extend(FLRepeat1Class, superClass);

    function FLRepeat1Class() {
      return FLRepeat1Class.__super__.constructor.apply(this, arguments);
    }

    FLRepeat1Class.prototype.createNew = function() {
      return FLRepeat1Class.__super__.createNew.call(this, FLRepeat1);
    };

    return FLRepeat1Class;

  })(FLClasses);

  FLRepeat1 = new FLRepeat1Class();

  FLRepeat2Class = (function(superClass) {
    extend(FLRepeat2Class, superClass);

    function FLRepeat2Class() {
      return FLRepeat2Class.__super__.constructor.apply(this, arguments);
    }

    FLRepeat2Class.prototype.createNew = function() {
      return FLRepeat2Class.__super__.createNew.call(this, FLRepeat2);
    };

    return FLRepeat2Class;

  })(FLClasses);

  FLRepeat2 = new FLRepeat2Class();

  FLForClass = (function(superClass) {
    extend(FLForClass, superClass);

    function FLForClass() {
      return FLForClass.__super__.constructor.apply(this, arguments);
    }

    FLForClass.prototype.createNew = function() {
      return FLForClass.__super__.createNew.call(this, FLFor);
    };

    return FLForClass;

  })(FLClasses);

  FLFor = new FLForClass();

  FLInClass = (function(superClass) {
    extend(FLInClass, superClass);

    function FLInClass() {
      return FLInClass.__super__.constructor.apply(this, arguments);
    }

    FLInClass.prototype.createNew = function() {
      var toBeReturned;
      toBeReturned = FLInClass.__super__.createNew.call(this, FLIn);
      toBeReturned.value = "in";
      return toBeReturned;
    };

    return FLInClass;

  })(FLClasses);

  FLIn = new FLInClass();

  FLTryClass = (function(superClass) {
    extend(FLTryClass, superClass);

    function FLTryClass() {
      return FLTryClass.__super__.constructor.apply(this, arguments);
    }

    FLTryClass.prototype.createNew = function() {
      return FLTryClass.__super__.createNew.call(this, FLTry);
    };

    return FLTryClass;

  })(FLClasses);

  FLTry = new FLTryClass();

  FLThrowClass = (function(superClass) {
    extend(FLThrowClass, superClass);

    function FLThrowClass() {
      return FLThrowClass.__super__.constructor.apply(this, arguments);
    }

    FLThrowClass.prototype.createNew = function() {
      return FLThrowClass.__super__.createNew.call(this, FLThrow);
    };

    return FLThrowClass;

  })(FLClasses);

  FLThrow = new FLThrowClass();

  FLNotClass = (function(superClass) {
    extend(FLNotClass, superClass);

    function FLNotClass() {
      return FLNotClass.__super__.constructor.apply(this, arguments);
    }

    FLNotClass.prototype.createNew = function() {
      return FLNotClass.__super__.createNew.call(this, FLNot);
    };

    return FLNotClass;

  })(FLClasses);

  FLNot = new FLNotClass();

  FLToClass = (function(superClass) {
    extend(FLToClass, superClass);

    function FLToClass() {
      return FLToClass.__super__.constructor.apply(this, arguments);
    }

    FLToClass.prototype.createNew = function() {
      return FLToClass.__super__.createNew.call(this, FLTo);
    };

    return FLToClass;

  })(FLClasses);

  FLTo = new FLToClass();

  FLDoneClass = (function(superClass) {
    extend(FLDoneClass, superClass);

    function FLDoneClass() {
      return FLDoneClass.__super__.constructor.apply(this, arguments);
    }

    FLDoneClass.prototype.createNew = function() {
      var toBeReturned;
      toBeReturned = FLDoneClass.__super__.createNew.call(this, FLDone);
      toBeReturned.value = null;
      return toBeReturned;
    };

    return FLDoneClass;

  })(FLClasses);

  FLDone = new FLDoneClass();

  FLPauseClass = (function(superClass) {
    extend(FLPauseClass, superClass);

    function FLPauseClass() {
      return FLPauseClass.__super__.constructor.apply(this, arguments);
    }

    FLPauseClass.prototype.createNew = function() {
      var toBeReturned;
      toBeReturned = FLPauseClass.__super__.createNew.call(this, FLPause);
      toBeReturned.value = null;
      return toBeReturned;
    };

    return FLPauseClass;

  })(FLClasses);

  FLPause = new FLPauseClass();

  FLBreakClass = (function(superClass) {
    extend(FLBreakClass, superClass);

    function FLBreakClass() {
      return FLBreakClass.__super__.constructor.apply(this, arguments);
    }

    FLBreakClass.prototype.createNew = function() {
      return FLBreakClass.__super__.createNew.call(this, FLBreak);
    };

    return FLBreakClass;

  })(FLClasses);

  FLBreak = new FLBreakClass();

  FLReturnClass = (function(superClass) {
    extend(FLReturnClass, superClass);

    function FLReturnClass() {
      return FLReturnClass.__super__.constructor.apply(this, arguments);
    }

    FLReturnClass.prototype.createNew = function() {
      var toBeReturned;
      toBeReturned = FLReturnClass.__super__.createNew.call(this, FLReturn);
      toBeReturned.value = null;
      return toBeReturned;
    };

    return FLReturnClass;

  })(FLClasses);

  FLReturn = new FLReturnClass();

  FLAccessUpperContextClass = (function(superClass) {
    extend(FLAccessUpperContextClass, superClass);

    function FLAccessUpperContextClass() {
      return FLAccessUpperContextClass.__super__.constructor.apply(this, arguments);
    }

    FLAccessUpperContextClass.prototype.createNew = function() {
      return FLAccessUpperContextClass.__super__.createNew.call(this, FLAccessUpperContext);
    };

    return FLAccessUpperContextClass;

  })(FLClasses);

  FLAccessUpperContext = new FLAccessUpperContextClass();

  FLForeverClass = (function(superClass) {
    extend(FLForeverClass, superClass);

    function FLForeverClass() {
      return FLForeverClass.__super__.constructor.apply(this, arguments);
    }

    FLForeverClass.prototype.createNew = function() {
      return FLForeverClass.__super__.createNew.call(this, FLForever);
    };

    return FLForeverClass;

  })(FLClasses);

  FLForever = new FLForeverClass();

  FLEvaluationsCounterClass = (function(superClass) {
    extend(FLEvaluationsCounterClass, superClass);

    function FLEvaluationsCounterClass() {
      return FLEvaluationsCounterClass.__super__.constructor.apply(this, arguments);
    }

    FLEvaluationsCounterClass.prototype.createNew = function() {
      return FLEvaluationsCounterClass.__super__.createNew.call(this, FLEvaluationsCounter);
    };

    return FLEvaluationsCounterClass;

  })(FLClasses);

  FLEvaluationsCounter = new FLEvaluationsCounterClass();

  FLNumberClass = (function(superClass) {
    extend(FLNumberClass, superClass);

    function FLNumberClass() {
      return FLNumberClass.__super__.constructor.apply(this, arguments);
    }

    FLNumberClass.prototype.createNew = function(value) {
      var toBeReturned;
      toBeReturned = FLNumberClass.__super__.createNew.call(this, FLNumber);
      toBeReturned.value = parseFloat(value + "");
      toBeReturned.flToString = function() {
        return this.value;
      };
      return toBeReturned;
    };

    return FLNumberClass;

  })(FLClasses);

  FLNumber = new FLNumberClass();

  FLUnaryMinusClass = (function(superClass) {
    extend(FLUnaryMinusClass, superClass);

    function FLUnaryMinusClass() {
      return FLUnaryMinusClass.__super__.constructor.apply(this, arguments);
    }

    FLUnaryMinusClass.prototype.createNew = function() {
      var toBeReturned;
      toBeReturned = FLUnaryMinusClass.__super__.createNew.call(this, FLUnaryMinus);
      toBeReturned.value = "-";
      return toBeReturned;
    };

    return FLUnaryMinusClass;

  })(FLClasses);

  FLUnaryMinus = new FLUnaryMinusClass();

  FLNilClass = (function(superClass) {
    extend(FLNilClass, superClass);

    function FLNilClass() {
      return FLNilClass.__super__.constructor.apply(this, arguments);
    }

    FLNilClass.prototype.createNew = function() {
      var toBeReturned;
      toBeReturned = FLNilClass.__super__.createNew.call(this, FLNil);
      toBeReturned.flToString = function() {
        return "nil";
      };
      return toBeReturned;
    };

    return FLNilClass;

  })(FLClasses);

  FLNil = new FLNilClass();

  FLStringClass = (function(superClass) {
    extend(FLStringClass, superClass);

    function FLStringClass() {
      return FLStringClass.__super__.constructor.apply(this, arguments);
    }

    FLStringClass.prototype.createNew = function(value) {
      var toBeReturned;
      toBeReturned = FLStringClass.__super__.createNew.call(this, FLString);
      toBeReturned.value = value + "";
      toBeReturned.flToString = function() {
        return this.value;
      };
      toBeReturned.flToStringForList = function() {
        return '"' + this.value + '"';
      };
      return toBeReturned;
    };

    return FLStringClass;

  })(FLClasses);

  FLString = new FLStringClass();

  FLWorkspaceClass = (function(superClass) {
    extend(FLWorkspaceClass, superClass);

    function FLWorkspaceClass() {
      return FLWorkspaceClass.__super__.constructor.apply(this, arguments);
    }

    FLWorkspaceClass.prototype.createNew = function() {
      return FLWorkspaceClass.__super__.createNew.call(this, FLWorkspace);
    };

    return FLWorkspaceClass;

  })(FLClasses);

  FLWorkspace = new FLWorkspaceClass();

  FLConsoleClass = (function(superClass) {
    extend(FLConsoleClass, superClass);

    function FLConsoleClass() {
      return FLConsoleClass.__super__.constructor.apply(this, arguments);
    }

    FLConsoleClass.prototype.createNew = function() {
      return FLConsoleClass.__super__.createNew.call(this, FLConsole);
    };

    return FLConsoleClass;

  })(FLClasses);

  FLConsole = new FLConsoleClass();

  FLTurtleClass = (function(superClass) {
    extend(FLTurtleClass, superClass);

    function FLTurtleClass() {
      return FLTurtleClass.__super__.constructor.apply(this, arguments);
    }

    FLTurtleClass.prototype.createNew = function() {
      var toBeReturned;
      toBeReturned = FLTurtleClass.__super__.createNew.call(this, FLTurtle);
      toBeReturned.penDown = true;
      toBeReturned.direction = 0;
      toBeReturned.x = 0;
      toBeReturned.y = 0;
      toBeReturned.sendHome = function() {
        if (typeof canvasOutputElement !== "undefined" && canvasOutputElement !== null) {
          this.x = canvasOutputElement.clientWidth / 2;
          this.y = canvasOutputElement.clientHeight / 2;
        }
        return this.direction = 0;
      };
      return toBeReturned;
    };

    return FLTurtleClass;

  })(FLClasses);

  FLTurtle = new FLTurtleClass();

  commonSimpleValueEqualityFunction = function*(context) {
    var toCompare;
    yield;
    toCompare = context.lookupTemp("toCompare");
    if (this.value === toCompare.value) {
      return FLBoolean.createNew(true);
    } else {
      return FLBoolean.createNew(false);
    }
  };

  commonSimpleValueInequalityFunction = function*(context) {
    var toCompare;
    yield;
    toCompare = context.lookupTemp("toCompare");
    if (this.value !== toCompare.value) {
      return FLBoolean.createNew(true);
    } else {
      return FLBoolean.createNew(false);
    }
  };

  addDefaultMethods = function(classToAddThemTo) {
    var commonPropertyAccessFunction, commonPropertyAssignmentFunction;
    classToAddThemTo.addMethod(flTokenize("isPrimitiveType"), flTokenize("if (self.class == Class) or (self.class == String) or (self.class == Number) or (self.class == List) or (self.class == Boolean):\n﹍return true\nelse:\n﹍return false"));
    classToAddThemTo.addMethod(flTokenize("postfixPrint"), function*(context) {
      yield;
      if (methodsExecutionDebug) {
        log("///////// program printout: " + this.flToString());
      }
      rWorkspace.environmentPrintout += this.flToString();
      return this;
    });
    classToAddThemTo.addMethod(flTokenize("toString"), function*(context) {
      yield;
      return FLString.createNew(this.flToString());
    });
    classToAddThemTo.addMethod(flTokenize("whenNew"), function*(context) {
      yield;
      return this;
    });
    classToAddThemTo.addMethod(flTokenize("eval"), function*(context) {
      var base, base1, newContext, toBeReturned;
      context.isTransparent = true;
      if (methodsExecutionDebug) {
        log("context now tramsparent at depth: " + context.depth() + " with self: " + (typeof (base = context.self).flToString === "function" ? base.flToString() : void 0));
      }
      newContext = new FLContext(context);
      newContext.isTransparent = true;
      if (methodsExecutionDebug) {
        log("newContext now tramsparent at depth: " + newContext.depth() + " with self: " + (typeof (base1 = newContext.self).flToString === "function" ? base1.flToString() : void 0));
      }
      toBeReturned = (yield* this["eval"](newContext, this));
      return toBeReturned;
    });
    classToAddThemTo.addMethod(flTokenize("== ( toCompare )"), function*(context) {
      var toCompare;
      yield;
      toCompare = context.lookupTemp("toCompare");
      if (this === toCompare) {
        return FLBoolean.createNew(true);
      } else {
        return FLBoolean.createNew(false);
      }
    }, 7);
    classToAddThemTo.addMethod(flTokenize("!= ( toCompare )"), function*(context) {
      var toCompare;
      yield;
      toCompare = context.lookupTemp("toCompare");
      if (this !== toCompare) {
        return FLBoolean.createNew(true);
      } else {
        return FLBoolean.createNew(false);
      }
    }, 7);
    classToAddThemTo.addMethod(flTokenize("else if ( predicate ): ('trueBranch)"), function*(context) {
      yield;
      return this;
    });
    classToAddThemTo.addMethod(flTokenize("else: ('trueBranch)"), function*(context) {
      yield;
      return this;
    });
    classToAddThemTo.addMethod(flTokenize("catch all : ( ' errorHandle )"), function*(context) {
      yield;
      return this;
    });
    classToAddThemTo.addMethod(flTokenize("catch ( 'theError ) : ( ' errorHandle )"), function*(context) {
      yield;
      return this;
    });
    commonPropertyAssignmentFunction = function*(context) {
      var base, value, variable;
      yield;
      context.isTransparent = true;
      if (methodsExecutionDebug) {
        log("context now tramsparent at depth: " + context.depth() + " with self: " + (typeof (base = context.self).flToString === "function" ? base.flToString() : void 0));
      }
      variable = context.lookupTemp("variable");
      value = context.lookupTemp("value");
      this.instanceVariablesDict[ValidIDfromString(variable.value)] = value;
      return this;
    };
    commonPropertyAccessFunction = function*(context) {
      var base, objectsBeingChecked, variable;
      yield;
      context.isTransparent = true;
      if (methodsExecutionDebug) {
        log("context now tramsparent at depth: " + context.depth() + " with self: " + (typeof (base = context.self).flToString === "function" ? base.flToString() : void 0));
      }
      variable = context.lookupTemp("variable");
      if (methodsExecutionDebug) {
        log(". ('variable) : checking instance variables");
      }
      objectsBeingChecked = this;
      while (true) {
        if (objectsBeingChecked.instanceVariablesDict[ValidIDfromString(variable.value)] != null) {
          if (methodsExecutionDebug) {
            log("yes it's an instance variable: ");
          }
          return objectsBeingChecked.instanceVariablesDict[ValidIDfromString(variable.value)];
        }
        if (objectsBeingChecked === objectsBeingChecked.flClass) {
          break;
        } else {
          objectsBeingChecked = objectsBeingChecked.flClass;
        }
      }
      return FLNil.createNew();
    };
    classToAddThemTo.addMethod(flTokenize(". ('variable) = (value)"), commonPropertyAssignmentFunction);
    classToAddThemTo.addMethod(flTokenize(". ('variable) ← (value)"), commonPropertyAssignmentFunction);
    classToAddThemTo.addMethod(flTokenize(". evaluating (variable)"), commonPropertyAccessFunction);
    classToAddThemTo.addMethod(flTokenize(". ('variable) += (value)"), function*(context) {
      var runThis, toBeReturned, value, variable;
      variable = context.lookupTemp("variable");
      value = context.lookupTemp("value");
      runThis = flTokenize("(self . evaluating variable) += value");
      toBeReturned = (yield* runThis["eval"](context, runThis));
      this.instanceVariablesDict[ValidIDfromString(variable.value)] = toBeReturned;
      return toBeReturned;
    });
    classToAddThemTo.addMethod(flTokenize(". ('variable) *= (value)"), function*(context) {
      var runThis, toBeReturned, value, variable;
      variable = context.lookupTemp("variable");
      value = context.lookupTemp("value");
      runThis = flTokenize("(self . evaluating variable) *= value");
      toBeReturned = (yield* runThis["eval"](context, runThis));
      this.instanceVariablesDict[ValidIDfromString(variable.value)] = toBeReturned;
      return toBeReturned;
    });
    classToAddThemTo.addMethod(flTokenize(". ('variable) ++"), function*(context) {
      var runThis, toBeReturned, variable;
      variable = context.lookupTemp("variable");
      runThis = flTokenize("(self . evaluating variable) ++");
      toBeReturned = (yield* runThis["eval"](context, runThis));
      this.instanceVariablesDict[ValidIDfromString(variable.value)] = toBeReturned;
      return toBeReturned;
    });
    classToAddThemTo.addMethod(flTokenize(". ('variable)"), commonPropertyAccessFunction);
    classToAddThemTo.addMethod(flTokenize("answer: ( 'signature ) by: ( 'methodBody )"), function*(context) {
      var methodBody, signature;
      yield;
      signature = context.lookupTemp("signature");
      methodBody = context.lookupTemp("methodBody");
      if (this.isClass()) {
        this.addMethod(signature, methodBody);
      } else {
        this.flClass.addMethod(signature, methodBody);
      }
      return this;
    });
    classToAddThemTo.addMethod(flTokenize("answerEvalSignatureAndBody ( signature ) by ( methodBody )"), function*(context) {
      var methodBody, signature;
      yield;
      signature = context.lookupTemp("signature");
      methodBody = context.lookupTemp("methodBody");
      log("answer: giving the method body a definitionContext!");
      methodBody.definitionContext = context.previousContext;
      methodBody.giveDefinitionContextToElements(context.previousContext);
      if (this.isClass()) {
        this.addMethod(signature, methodBody);
      } else {
        this.flClass.addMethod(signature, methodBody);
      }
      return this;
    });
    return classToAddThemTo.addMethod(flTokenize("answer with priority (priority) : ( 'signature ) by: ( 'methodBody )"), function*(context) {
      var methodBody, priority, signature;
      yield;
      signature = context.lookupTemp("signature");
      methodBody = context.lookupTemp("methodBody");
      priority = context.lookupTemp("priority");
      if (this.isClass()) {
        this.addMethod(signature, methodBody, priority.value);
      } else {
        this.flClass.addMethod(signature, methodBody, priority.value);
      }
      return this;
    });
  };

  bootClasses = allClasses.slice();

  clearClasses = function() {
    var eachClass, j, len;
    for (j = 0, len = bootClasses.length; j < len; j++) {
      eachClass = bootClasses[j];
      eachClass.resetInstanceVariables();
      eachClass.resetMethods();
    }
    return allClasses = [];
  };

  initBootClasses = function() {
    var BaseDivideFunction, BaseFloorDivisionFunction, BaseMinusFunction, BaseMultiplyFunction, BasePercentFunction, BasePlusFunction, commonClassCreationFunction, eachClass, j, len, pauseFunctionContinuation;
    for (j = 0, len = bootClasses.length; j < len; j++) {
      eachClass = bootClasses[j];
      addDefaultMethods(eachClass);
    }
    FLToken.addMethod(flTokenize("← ( valueToAssign )"), function*(context, definitionContext) {
      var assigneeTokenString, base, valueToAssign;
      yield;
      valueToAssign = context.lookupTemp("valueToAssign");
      assigneeTokenString = this.value;
      if (methodsExecutionDebug) {
        log("evaluation " + indentation() + "assignment to token " + assigneeTokenString);
        log("evaluation " + indentation() + "value to assign to token: " + assigneeTokenString + " : " + valueToAssign.value);
        log("context now tramsparent at depth: " + context.depth() + " with self: " + (typeof (base = context.self).flToString === "function" ? base.flToString() : void 0));
      }
      context.isTransparent = true;
      this.assignValue(context, definitionContext, valueToAssign);
      context.isTransparent = false;
      return valueToAssign;
    });
    FLToken.addMethod(flTokenize("= ( valueToAssign )"), function*(context, definitionContext) {
      var assigneeTokenString, base, valueToAssign;
      yield;
      valueToAssign = context.lookupTemp("valueToAssign");
      assigneeTokenString = this.value;
      if (methodsExecutionDebug) {
        log("evaluation " + indentation() + "assignment to token " + assigneeTokenString);
        log("evaluation " + indentation() + "value to assign to token: " + assigneeTokenString + " : " + valueToAssign.value);
        log("context now tramsparent at depth: " + context.depth() + " with self: " + (typeof (base = context.self).flToString === "function" ? base.flToString() : void 0));
      }
      context.isTransparent = true;
      this.assignValue(context, definitionContext, valueToAssign);
      context.isTransparent = false;
      return valueToAssign;
    });
    commonClassCreationFunction = function*(context, definitionContext, assigneeToken, className) {
      var base, valueToAssign;
      yield;
      valueToAssign = FLClass.createNew(className);
      if (methodsExecutionDebug) {
        log("evaluation " + indentation() + "assignment to token " + assigneeToken.value);
        log("evaluation " + indentation() + "value to assign to token: " + assigneeToken.value + " : " + valueToAssign.value);
        log("context now tramsparent at depth: " + context.depth() + " with self: " + (typeof (base = context.self).flToString === "function" ? base.flToString() : void 0));
      }
      context.isTransparent = true;
      assigneeToken.assignValue(context, definitionContext, valueToAssign);
      return valueToAssign;
    };
    FLToken.addMethod(flTokenize("= Class new"), function*(context, definitionContext) {
      var toBeReturned;
      toBeReturned = (yield* commonClassCreationFunction(context, definitionContext, this, this.value));
      return toBeReturned;
    });
    FLToken.addMethod(flTokenize("= Class new named (theName)"), function*(context, definitionContext) {
      var theName, toBeReturned;
      theName = context.lookupTemp("theName");
      toBeReturned = (yield* commonClassCreationFunction(context, definitionContext, this, theName.value));
      return toBeReturned;
    });
    FLToken.addMethod(flTokenize("+= ( operandum )"), flTokenize("self ← self eval + operandum"));
    FLToken.addMethod(flTokenize("*= ( operandum )"), flTokenize("self ← self eval * operandum"));
    FLToken.addMethod(flTokenize("++"), flTokenize("self ← self eval + 1"));
    FLNil.addMethod(flTokenize("== ( toCompare )"), function*(context) {
      var toCompare;
      yield;
      toCompare = context.lookupTemp("toCompare");
      if (toCompare.flClass === FLNil) {
        return FLBoolean.createNew(true);
      } else {
        return FLBoolean.createNew(false);
      }
    }, 7);
    FLIn.addMethod(flTokenize("(object) do ('code)"), function*(context) {
      var code, newContext, object, toBeReturned;
      object = context.lookupTemp("object");
      code = context.lookupTemp("code");
      newContext = new FLContext(context, object);
      toBeReturned = (yield* code["eval"](newContext, code));
      return toBeReturned;
    });
    FLTo.addMethod(flTokenize("( ' functionObjectName ) : ( 'signature ) do: ( 'functionBody )"), flTokenize("accessUpperContext\nif (nil == functionObjectName eval) or (functionObjectName eval isPrimitiveType):\n﹍'TempClass ← Class new\n﹍TempClass nameit \"Class_of_\" + functionObjectName\n﹍functionObjectName ← TempClass new\n﹍TempClass answerEvalSignatureAndBody (signature) by (functionBody)\nfunctionObjectName eval answerEvalSignatureAndBody (signature) by (functionBody)"));
    FLTo.addMethod(flTokenize("( ' functionObjectName ) : ( 'functionBody )"), flTokenize("accessUpperContext\nif (nil == functionObjectName eval) or (functionObjectName eval isPrimitiveType):\n﹍'TempClass ← Class new\n﹍TempClass nameit \"Class_of_\" + functionObjectName\n﹍functionObjectName ← TempClass new\nfunctionObjectName eval answerEvalSignatureAndBody: () by (functionBody)"));
    FLClass.addMethod(flTokenize("new"), function*(context) {
      yield;
      if (methodsExecutionDebug) {
        log("///////// creating a new class for the user!");
      }
      return this.createNew();
    });
    FLException.addMethod(flTokenize("new"), function*(context) {
      yield;
      return this.createNew("");
    });
    FLException.addMethod(flTokenize("initWith ( errorMessage )"), function*(context) {
      var errorMessage;
      yield;
      errorMessage = context.lookupTemp("errorMessage");
      this.value = errorMessage.value;
      return this;
    });
    FLException.addMethod(flTokenize("catch all : ( ' errorHandle )"), function*(context) {
      var errorHandle, toBeReturned;
      errorHandle = context.lookupTemp("errorHandle");
      if (methodsExecutionDebug) {
        log("catch: being thrown? " + context.throwing);
        log("catch: got right exception, catching it");
      }
      if (this.thrown) {
        toBeReturned = (yield* errorHandle["eval"](context, errorHandle));
      } else {
        toBeReturned = this;
      }
      return toBeReturned;
    });
    FLException.addMethod(flTokenize("catch ( 'theError ) : ( ' errorHandle )"), function*(context) {
      var errorHandle, theError, toBeReturned;
      yield;
      theError = context.lookupTemp("theError");
      errorHandle = context.lookupTemp("errorHandle");
      theError = (yield* theError["eval"](context, theError));
      if (methodsExecutionDebug) {
        log("catch: same as one to catch?" + (this === theError) + " being thrown? " + context.throwing);
      }
      if (this === theError) {
        if (methodsExecutionDebug) {
          log("catch: got right exception, catching it");
        }
        if (this.thrown) {
          toBeReturned = (yield* errorHandle["eval"](context, errorHandle));
        } else {
          toBeReturned = this;
        }
      } else {
        if (methodsExecutionDebug) {
          log("catch: got wrong exception, propagating it");
        }
        toBeReturned = this;
      }
      return toBeReturned;
    });
    FLException.addMethod(FLList.emptyMessage(), function*(context) {
      yield;
      if (this.thrown) {
        context.throwing = true;
      }
      return this;
    });
    FLString.addMethod(flTokenize("new"), function*(context) {
      yield;
      return this.createNew("");
    });
    FLString.addMethod(flTokenize("+ ( stringToBeAppended )"), function*(context) {
      var stringToBeAppended;
      yield;
      stringToBeAppended = context.lookupTemp("stringToBeAppended");
      return FLString.createNew(this.value + stringToBeAppended.flToString());
    }, 4);
    FLString.addMethod(flTokenize("== ( toCompare )"), commonSimpleValueEqualityFunction, 7);
    FLString.addMethod(flTokenize("!= ( toCompare )"), commonSimpleValueInequalityFunction, 7);
    FLNumber.addMethod(flTokenize("new"), function*(context) {
      yield;
      return this.createNew(0);
    });
    FLNumber.addMethod(flTokenize("anotherPrint"), flTokenize("console print self"));
    FLNumber.addMethod(flTokenize("doublePrint"), flTokenize("console print(console print self)"));
    FLNumber.addMethod(flTokenize("incrementInPlace"), flTokenize("self ← self + 1"));
    FLNumber.addMethod(flTokenize("factorialtwo"), flTokenize("if self == 0: ( 1 ) else: (self * ( ( self minus 1 ) factorialtwo ))"));
    FLNumber.addMethod(flTokenize("factorialthree"), flTokenize("if self == 0: ( 1 ) else: ('temp ← self;console print temp; ( self minus 1 ) factorialthree * temp )"));
    FLNumber.addMethod(flTokenize("factorialfour"), flTokenize("if self == 0: ( 1 ) else: ('temp ← self;( self minus 1 ) factorialfour * temp )"));
    FLNumber.addMethod(flTokenize("factorialfive"), flTokenize("if self == 0: ( 1 ) else: (1 + 1;'temp ← self;( self minus 1 ) factorialfive * temp )"));
    FLNumber.addMethod(flTokenize("factorialsix"), flTokenize("if self == 0: ( 1 ) else: (( self minus 1 ) factorialsix * self)"));
    FLNumber.addMethod(flTokenize("amIZero"), flTokenize("self == 0"));
    FLNumber.addMethod(flTokenize("printAFromDeeperCall"), flTokenize("console print a"));
    FLNumber.addMethod(flTokenize("...(endRange)"), function*(context) {
      var endRange, i, l, listToBeReturned, ref, ref1;
      yield;
      endRange = context.lookupTemp("endRange");
      listToBeReturned = FLList.createNew();
      for (i = l = ref = this.value, ref1 = endRange.value; ref <= ref1 ? l <= ref1 : l >= ref1; i = ref <= ref1 ? ++l : --l) {
        listToBeReturned.value.jsArrayPush(FLNumber.createNew(i));
        listToBeReturned.cursorEnd++;
      }
      return listToBeReturned;
    }, 5);
    BasePlusFunction = function*(context) {
      var operandum;
      yield;
      operandum = context.lookupTemp("operandum");
      if (operandum.flClass === FLString) {
        return FLString.createNew(this.value + operandum.value);
      } else {
        return FLNumber.createNew(this.value + operandum.value);
      }
    };
    FLNumber.addMethod(flTokenize("$plus_binary_default ( operandum )"), BasePlusFunction);
    FLNumber.addMethod(flTokenize("+ ( operandum )"), flTokenize("self $plus_binary_default operandum"), 4);
    FLNumber.addMethod(flTokenize("++"), flTokenize("self + 1"));
    FLNumber.addMethod(flTokenize("+= (value)"), flTokenize("self + value"));
    BasePercentFunction = function*(context) {
      var operandum;
      yield;
      operandum = context.lookupTemp("operandum");
      return FLNumber.createNew(this.value % operandum.value);
    };
    FLNumber.addMethod(flTokenize("$percent_binary_default ( operandum )"), BasePercentFunction);
    FLNumber.addMethod(flTokenize("% ( operandum )"), flTokenize("self $percent_binary_default operandum"), 3);
    BaseFloorDivisionFunction = function*(context) {
      var operandum;
      yield;
      operandum = context.lookupTemp("operandum");
      return FLNumber.createNew(Math.floor(this.value / operandum.value));
    };
    FLNumber.addMethod(flTokenize("$floordivision_binary_default ( operandum )"), BaseFloorDivisionFunction);
    FLNumber.addMethod(flTokenize("/_ ( operandum )"), flTokenize("self $floordivision_binary_default operandum"), 3);
    BaseMinusFunction = function*(context) {
      var operandum;
      yield;
      operandum = context.lookupTemp("operandum");
      return FLNumber.createNew(this.value - operandum.value);
    };
    FLNumber.addMethod(flTokenize("$minus_binary_default ( operandum )"), BaseMinusFunction);
    FLNumber.addMethod(flTokenize("- ( operandum )"), flTokenize("self $minus_binary_default operandum"), 4);
    BaseDivideFunction = function*(context) {
      var operandum;
      yield;
      operandum = context.lookupTemp("operandum");
      return FLNumber.createNew(this.value / operandum.value);
    };
    FLNumber.addMethod(flTokenize("$divide_binary_default ( operandum )"), BaseDivideFunction);
    FLNumber.addMethod(flTokenize("/ ( operandum )"), flTokenize("self $divide_binary_default operandum"), 3);
    BaseMultiplyFunction = function*(context) {
      var operandum;
      yield;
      operandum = context.lookupTemp("operandum");
      return FLNumber.createNew(this.value * operandum.value);
    };
    FLNumber.addMethod(flTokenize("$multiply_binary_default ( operandum )"), BaseMultiplyFunction);
    FLNumber.addMethod(flTokenize("* ( operandum )"), flTokenize("self $multiply_binary_default operandum"), 3);
    FLNumber.addMethod(flTokenize("*= (value)"), flTokenize("self * value"));
    FLNumber.addMethod(flTokenize("minus ( operandum )"), function*(context) {
      var operandum;
      yield;
      operandum = context.lookupTemp("operandum");
      return FLNumber.createNew(this.value - operandum.value);
    });
    FLNumber.addMethod(flTokenize("selftimesminusone"), flTokenize("self * self minus 1"));
    FLNumber.addMethod(flTokenize("times ( ' loopCode )"), function*(context) {
      var i, l, loopCode, ref, toBeReturned;
      loopCode = context.lookupTemp("loopCode");
      if (methodsExecutionDebug) {
        log("FLNumber: times loop code is: " + loopCode.flToString());
      }
      for (i = l = 0, ref = this.value; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
        toBeReturned = (yield* loopCode["eval"](context, loopCode));
        if (toBeReturned != null) {
          if (context.throwing && (toBeReturned.flClass === FLDone || toBeReturned.flClass === FLBreak)) {
            context.throwing = false;
            if (toBeReturned.value != null) {
              toBeReturned = toBeReturned.value;
            }
            if (methodsExecutionDebug) {
              log("times loop exited with Done ");
            }
            break;
          }
          if (context.throwing && toBeReturned.flClass === FLReturn) {
            if (methodsExecutionDebug) {
              log("times loop exited with Return ");
            }
            break;
          }
        }
      }
      return toBeReturned;
    });
    FLNumber.addMethod(flTokenize("== ( toCompare )"), commonSimpleValueEqualityFunction, 7);
    FLNumber.addMethod(flTokenize("!= ( toCompare )"), commonSimpleValueInequalityFunction, 7);
    FLNumber.addMethod(flTokenize("< ( toCompare )"), function*(context) {
      var toCompare;
      yield;
      toCompare = context.lookupTemp("toCompare");
      if (this.value < toCompare.value) {
        return FLBoolean.createNew(true);
      } else {
        return FLBoolean.createNew(false);
      }
    }, 6);
    FLNumber.addMethod(flTokenize("> ( toCompare )"), function*(context) {
      var toCompare;
      yield;
      toCompare = context.lookupTemp("toCompare");
      if (this.value > toCompare.value) {
        return FLBoolean.createNew(true);
      } else {
        return FLBoolean.createNew(false);
      }
    }, 6);
    FLNumber.addMethod(flTokenize("← ( valueToAssign )"), function*(context) {
      var valueToAssign;
      yield;
      if (methodsExecutionDebug) {
        log("evaluation " + indentation() + "assigning to number! ");
      }
      valueToAssign = context.lookupTemp("valueToAssign");
      this.value = valueToAssign.value;
      return this;
    });
    FLBoolean.addMethod(flTokenize("negate"), function*(context) {
      yield;
      return FLBoolean.createNew(!this.value);
    });
    FLBoolean.addMethod(flTokenize("and ( operandum )"), function*(context) {
      var operandum;
      yield;
      operandum = context.lookupTemp("operandum");
      return FLBoolean.createNew(this.value && operandum.value);
    });
    FLBoolean.addMethod(flTokenize("or ( operandum )"), function*(context) {
      var operandum;
      yield;
      if (methodsExecutionDebug) {
        log("executing an or! ");
      }
      operandum = context.lookupTemp("operandum");
      return FLBoolean.createNew(this.value || operandum.value);
    });
    FLBoolean.addMethod(flTokenize("== ( toCompare )"), commonSimpleValueEqualityFunction, 7);
    FLBoolean.addMethod(flTokenize("!= ( toCompare )"), commonSimpleValueInequalityFunction, 7);
    FLQuote.addMethod(flTokenize("( ' operandum )"), function*(context) {
      var operandum;
      yield;
      operandum = context.lookupTemp("operandum");
      if (operandum.flClass === FLList) {
        log("list quote, giving it a definitionContext!");
        operandum.definitionContext = context.previousContext;
        operandum.giveDefinitionContextToElements(context.previousContext);
      }
      return operandum;
    });
    FLNot.addMethod(flTokenize("( operandum )"), flTokenize("operandum negate"));
    FLUnaryMinus.addMethod(flTokenize("( operandum )"), flTokenize("0 - operandum", 4));
    FLListLiteralArrayNotationStarter.addMethod(flTokenize("]"), function*(context) {
      yield;
      return FLList.createNew();
    });
    FLListLiteralArrayNotationStarter.addMethod(flTokenize("( elementToBeAppended )"), function*(context) {
      var elementToBeAppended, toBeReturned;
      yield;
      elementToBeAppended = context.lookupTemp("elementToBeAppended");
      toBeReturned = FLListLiteralArrayNotation.createNew();
      toBeReturned.value.mutablePush(elementToBeAppended);
      return toBeReturned;
    });
    FLListLiteralArrayNotation.addMethod(flTokenize("]"), function*(context) {
      yield;
      return this.value;
    });
    FLListLiteralArrayNotation.addMethod(flTokenize(", ( elementToBeAppended )"), function*(context) {
      var elementToBeAppended;
      yield;
      elementToBeAppended = context.lookupTemp("elementToBeAppended");
      this.value.mutablePush(elementToBeAppended);
      return this;
    });
    FLList.addMethod(flTokenize("new"), function*(context) {
      yield;
      return this.createNew();
    });
    FLList.addMethod(flTokenize("+ ( elementToBeAppended )"), function*(context) {
      var elementToBeAppended;
      yield;
      elementToBeAppended = context.lookupTemp("elementToBeAppended");
      if (methodsExecutionDebug) {
        log("appending element to: " + this.flToString() + " : " + elementToBeAppended.toString());
      }
      return this.flListImmutablePush(elementToBeAppended);
    }, 4);
    FLList.addMethod(flTokenize("length"), function*(context) {
      yield;
      return FLNumber.createNew(this.length());
    });
    FLList.addMethod(flTokenize("[ (indexValue) ] = (value)"), function*(context) {
      var indexValue, value;
      yield;
      indexValue = context.lookupTemp("indexValue");
      value = context.lookupTemp("value");
      return this.elementAtSetMutable(indexValue.value - 1, value);
    });
    FLList.addMethod(flTokenize("[ (indexValue) ] += (value)"), function*(context) {
      var indexValue, runThis, toBeReturned, value;
      indexValue = context.lookupTemp("indexValue");
      value = context.lookupTemp("value");
      runThis = flTokenize("(self [indexValue]) += value");
      toBeReturned = (yield* runThis["eval"](context, runThis));
      this.elementAtSetMutable(indexValue.value - 1, toBeReturned);
      return toBeReturned;
    });
    FLList.addMethod(flTokenize("[ (indexValue) ] *= (value)"), function*(context) {
      var indexValue, runThis, toBeReturned, value;
      indexValue = context.lookupTemp("indexValue");
      value = context.lookupTemp("value");
      runThis = flTokenize("(self [indexValue]) *= value");
      toBeReturned = (yield* runThis["eval"](context, runThis));
      this.elementAtSetMutable(indexValue.value - 1, toBeReturned);
      return toBeReturned;
    });
    FLList.addMethod(flTokenize("[ (indexValue) ] ++"), function*(context) {
      var indexValue, runThis, toBeReturned;
      indexValue = context.lookupTemp("indexValue");
      runThis = flTokenize("(self [indexValue]) ++");
      toBeReturned = (yield* runThis["eval"](context, runThis));
      this.elementAtSetMutable(indexValue.value - 1, toBeReturned);
      return toBeReturned;
    });
    FLList.addMethod(flTokenize("[ (indexValue) ]"), function*(context) {
      var indexValue;
      yield;
      indexValue = context.lookupTemp("indexValue");
      return this.elementAt(indexValue.value - 1);
    });
    FLList.addMethod(flTokenize("each ( ' variable ) do ( ' code )"), function*(context) {
      var code, i, l, newContext, ref, toBeReturned, variable;
      variable = context.lookupTemp("variable");
      code = context.lookupTemp("code");
      if (methodsExecutionDebug) {
        log("FLList each do ");
      }
      newContext = new FLContext(context);
      for (i = l = 0, ref = this.value.length; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
        newContext.tempVariablesDict[ValidIDfromString(variable.value)] = this.elementAt(i);
        toBeReturned = (yield* code["eval"](newContext, code));
        if (toBeReturned != null) {
          if (context.throwing && (toBeReturned.flClass === FLDone || toBeReturned.flClass === FLBreak)) {
            context.throwing = false;
            if (toBeReturned.value != null) {
              toBeReturned = toBeReturned.value;
            }
            if (methodsExecutionDebug) {
              log("list-each-do loop exited with Done ");
            }
            break;
          }
          if (context.throwing && toBeReturned.flClass === FLReturn) {
            if (methodsExecutionDebug) {
              log("list-each-do loop exited with Return ");
            }
            break;
          }
        }
      }
      return toBeReturned;
    });
    FLAccessUpperContext.addMethod(FLList.emptyMessage(), function*(context) {
      var base;
      yield;
      if (methodsExecutionDebug) {
        log("FLAccessUpperContext running emptyMessage");
        log("context.previousContext now tramsparent at depth: " + context.previousContext.depth() + " with self: " + (typeof (base = context.previousContext.self).flToString === "function" ? base.flToString() : void 0));
      }
      context.previousContext.isTransparent = true;
      return this;
    });
    FLConsole.addMethod(flTokenize("print ( thingToPrint )"), function*(context) {
      var stringToPrint, thingToPrint;
      yield;
      thingToPrint = context.lookupTemp("thingToPrint");
      stringToPrint = thingToPrint.flToString();
      if (methodsExecutionDebug) {
        log("///////// program printout: " + stringToPrint);
      }
      if (typeof textOutputElement !== "undefined" && textOutputElement !== null) {
        textOutputElement.value += stringToPrint;
      }
      rWorkspace.environmentPrintout += stringToPrint;
      return thingToPrint;
    });
    FLTurtle.addMethod(flTokenize("home"), function*(context) {
      yield;
      this.sendHome();
      return this;
    });
    FLTurtle.addMethod(flTokenize("forward ( distance )"), function*(context) {
      var canvasContext, distance, radians;
      yield;
      distance = context.lookupTempValue("distance");
      if (typeof canvasOutputElement !== "undefined" && canvasOutputElement !== null) {
        canvasContext = canvasOutputElement.getContext("2d");
        canvasContext.strokeStyle = "#000";
        canvasContext.lineWidth = 1;
        radians = this.direction * Math.PI / 180.0;
        if (this.penDown) {
          canvasContext.beginPath();
          canvasContext.moveTo(this.x, this.y);
        }
        this.x += distance * Math.sin(radians);
        this.y -= distance * Math.cos(radians);
        if (this.penDown) {
          canvasContext.lineTo(this.x, this.y);
          canvasContext.stroke();
        }
      }
      return this;
    });
    FLTurtle.addMethod(flTokenize("right ( degrees )"), function*(context) {
      var degrees;
      yield;
      degrees = context.lookupTempValue("degrees");
      this.direction += degrees;
      this.direction = this.direction % 360;
      return this;
    });
    FLTurtle.addMethod(flTokenize("left ( degrees )"), function*(context) {
      var degrees;
      yield;
      degrees = context.lookupTempValue("degrees");
      this.direction += 360 - degrees;
      this.direction = this.direction % 360;
      return this;
    });
    FLDone.addMethod(flTokenize("with ( valueToReturn )"), function*(context) {
      var valueToReturn;
      yield;
      valueToReturn = context.lookupTemp("valueToReturn");
      if (methodsExecutionDebug) {
        log("Done_object thrown with return value: " + valueToReturn.flToString());
      }
      this.value = valueToReturn;
      context.throwing = true;
      this.thrown = true;
      return this;
    });
    FLDone.addMethod(FLList.emptyMessage(), function*(context) {
      yield;
      if (methodsExecutionDebug) {
        log("Done_object running emptyMessage");
      }
      context.throwing = true;
      this.thrown = true;
      return this;
    });
    FLBreak.addMethod(FLList.emptyMessage(), function*(context) {
      yield;
      if (methodsExecutionDebug) {
        log("Break_object");
      }
      context.throwing = true;
      return this;
    });
    FLReturn.addMethod(flTokenize("( valueToReturn )"), function*(context) {
      var valueToReturn;
      yield;
      valueToReturn = context.lookupTemp("valueToReturn");
      if (methodsExecutionDebug) {
        log("Return_object running a value");
      }
      this.value = valueToReturn;
      context.throwing = true;
      return this;
    });
    FLReturn.addMethod(FLList.emptyMessage(), function*(context) {
      yield;
      if (methodsExecutionDebug) {
        log("Return_object running emptyMessage");
      }
      context.throwing = true;
      this.value = FLNil.createNew();
      return this;
    });
    FLRepeat1.addMethod(flTokenize("( ' loopCode )"), function*(context) {
      var base, loopCode, toBeReturned;
      context.isTransparent = true;
      if (methodsExecutionDebug) {
        log("context now tramsparent at depth: " + context.depth() + " with self: " + (typeof (base = context.self).flToString === "function" ? base.flToString() : void 0));
        log("FLRepeat1 ⇒ loop code is: " + loopCode.flToString());
      }
      loopCode = context.lookupTemp("loopCode");
      while (true) {
        context.throwing = false;
        toBeReturned = (yield* loopCode["eval"](context, loopCode));
        if (methodsExecutionDebug) {
          log("Repeat1 ⇒ returning result after loop cycle: " + toBeReturned);
          log("Repeat1 ⇒ returning result CLASS after loop cycle: ");
          log("Repeat1 ⇒ remaining message after loop cycle: ");
          log("Repeat1 ⇒ message length:  ");
          log("Repeat1 ⇒ did I receive a Done? " + ((toBeReturned != null ? toBeReturned.flClass : void 0) === FLDone ? "yes" : "no"));
        }
        if (toBeReturned != null) {
          if (context.throwing && (toBeReturned.flClass === FLDone || toBeReturned.flClass === FLBreak)) {
            context.throwing = false;
            if (toBeReturned.value != null) {
              toBeReturned = toBeReturned.value;
            }
            if (methodsExecutionDebug) {
              log("Repeat1 ⇒ the loop exited with Done at context depth " + context.depth());
            }
            break;
          }
          if (context.throwing && toBeReturned.flClass === FLReturn) {
            if (methodsExecutionDebug) {
              log("Repeat1 ⇒ the loop exited with Return ");
            }
            break;
          }
        }
      }
      return toBeReturned;
    });
    repeatFunctionContinuation = function*(context) {
      var base, howManyTimes, i, l, limit, loopCode, ref, toBeReturned;
      context.isTransparent = true;
      if (methodsExecutionDebug) {
        log("context now tramsparent at depth: " + context.depth() + " with self: " + (typeof (base = context.self).flToString === "function" ? base.flToString() : void 0));
      }
      howManyTimes = context.lookupTemp("howManyTimes");
      loopCode = context.lookupTemp("loopCode");
      if (methodsExecutionDebug) {
        log("FLRepeat2 ⇒ loop code is: " + loopCode.flToString());
      }
      if (howManyTimes.flClass === FLForever) {
        limit = Number.MAX_SAFE_INTEGER;
      } else {
        limit = howManyTimes.value;
      }
      for (i = l = 0, ref = limit; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
        yield "from repeatFunctionContinuation";
        if (methodsExecutionDebug) {
          log("Repeat2 ⇒ starting a(nother) cycle: ");
        }
        toBeReturned = (yield* loopCode["eval"](context, loopCode));
        if (methodsExecutionDebug) {
          log("Repeat2 ⇒ returning result after loop cycle: " + toBeReturned);
          log("Repeat2 ⇒ returning result CLASS after loop cycle: ");
          log("Repeat2 ⇒ remaining message after loop cycle: ");
          log("Repeat2 ⇒ message length:  ");
          log("Repeat2 ⇒ did I receive a Done? " + ((toBeReturned != null ? toBeReturned.flClass : void 0) === FLDone ? "yes" : "no"));
          log("Repeat2 ⇒ did I receive a thrown object? " + (context.throwing ? "yes" : "no"));
        }
        if (toBeReturned != null) {
          if (context.throwing && (toBeReturned.flClass === FLDone || toBeReturned.flClass === FLBreak)) {
            context.throwing = false;
            if (toBeReturned.value != null) {
              toBeReturned = toBeReturned.value;
            }
            if (methodsExecutionDebug) {
              log("Repeat2 ⇒ the loop exited with Done at context depth " + context.depth());
            }
            break;
          }
          if (context.throwing && toBeReturned.flClass === FLReturn) {
            if (methodsExecutionDebug) {
              log("Repeat2 ⇒ the loop exited with Return ");
            }
            break;
          }
        }
      }
      return toBeReturned;
    };
    FLRepeat2.addMethod(flTokenize("(howManyTimes) :( ' loopCode )"), repeatFunctionContinuation);
    FLEvaluationsCounter.addMethod(FLList.emptyMessage(), function*(context) {
      var stringToPrint;
      yield;
      stringToPrint = "EvaluationsCounter running the \"empty\" method // ";
      if (methodsExecutionDebug) {
        log(stringToPrint);
      }
      rWorkspace.environmentPrintout += stringToPrint;
      return this;
    });
    FLThrow.addMethod(flTokenize("( theError )"), function*(context) {
      var theError;
      yield;
      theError = context.lookupTemp("theError");
      theError.thrown = true;
      if (methodsExecutionDebug) {
        log("throwing an error: " + theError.value);
      }
      context.throwing = true;
      return theError;
    });
    FLIfThen.addMethod(flTokenize("( predicate ) : ('trueBranch)"), function*(context) {
      var base, predicate, toBeReturned, trueBranch;
      yield;
      context.isTransparent = true;
      if (methodsExecutionDebug) {
        log("context now tramsparent at depth: " + context.depth() + " with self: " + (typeof (base = context.self).flToString === "function" ? base.flToString() : void 0));
      }
      predicate = context.lookupTemp("predicate");
      trueBranch = context.lookupTemp("trueBranch");
      if (methodsExecutionDebug) {
        log("FLIfThen: predicate value is: " + predicate.value);
      }
      if (predicate.value) {
        if (methodsExecutionDebug) {
          log("FLIfThen: evaling true branch at depth " + context.depth());
        }
        toBeReturned = (yield* trueBranch["eval"](context, trueBranch));
      } else {
        toBeReturned = FLIfFallThrough.createNew();
      }
      return toBeReturned;
    });
    FLIfFallThrough.addMethod(FLList.emptyMessage(), function*(context) {
      yield;
      if (methodsExecutionDebug) {
        log("no more cases for the if");
      }
      return FLNil.createNew();
    });
    FLIfFallThrough.addMethod(flTokenize("else if ( predicate ): ('trueBranch)"), function*(context) {
      var base, predicate, toBeReturned, trueBranch;
      yield;
      context.isTransparent = true;
      if (methodsExecutionDebug) {
        log("context now tramsparent at depth: " + context.depth() + " with self: " + (typeof (base = context.self).flToString === "function" ? base.flToString() : void 0));
      }
      predicate = context.lookupTemp("predicate");
      trueBranch = context.lookupTemp("trueBranch");
      if (methodsExecutionDebug) {
        log("FLIfFallThrough: predicate value is: " + predicate.value);
        log("FLIfFallThrough: true branch is: " + trueBranch.flToString());
      }
      if (predicate.value) {
        toBeReturned = (yield* trueBranch["eval"](context, trueBranch));
      } else {
        toBeReturned = FLIfFallThrough.createNew();
      }
      return toBeReturned;
    });
    FLIfFallThrough.addMethod(flTokenize("else: ('trueBranch)"), function*(context) {
      var base, toBeReturned, trueBranch;
      if (methodsExecutionDebug) {
        log("FLIfFallThrough else: case ");
        log("context now tramsparent at depth: " + context.depth() + " with self: " + (typeof (base = context.self).flToString === "function" ? base.flToString() : void 0));
      }
      context.isTransparent = true;
      trueBranch = context.lookupTemp("trueBranch");
      if (methodsExecutionDebug) {
        log("FLIfFallThrough else: evalling code ");
      }
      toBeReturned = (yield* trueBranch["eval"](context, trueBranch));
      return toBeReturned;
    });
    FLTry.addMethod(flTokenize(": ( ' code )"), function*(context) {
      var code, toBeReturned;
      code = context.lookupTemp("code");
      toBeReturned = (yield* code["eval"](context, code));
      context.throwing = false;
      return toBeReturned;
    });
    pauseFunctionContinuation = function*(context) {
      var endTime, remainingTime, seconds, startTime;
      yield;
      seconds = context.lookupTemp("seconds");
      startTime = new Date().getTime();
      endTime = startTime + seconds.value * 1000;
      while ((remainingTime = new Date().getTime() - endTime) < 0) {
        yield remainingTime;
        "do nothing";
      }
      return this;
    };
    FLPause.addMethod(flTokenize("( seconds )"), pauseFunctionContinuation);
    FLFor.addMethod(flTokenize("( ' loopVar ) from ( startIndex ) to ( endIndex ) : ( 'loopCode )"), function*(context) {
      var base, endIndex, forContext, i, l, loopCode, loopVar, loopVarName, ref, ref1, startIndex, toBeReturned;
      context.isTransparent = true;
      if (methodsExecutionDebug) {
        log("context now tramsparent at depth: " + context.depth() + " with self: " + (typeof (base = context.self).flToString === "function" ? base.flToString() : void 0));
      }
      loopVar = context.lookupTemp("loopVar");
      startIndex = context.lookupTemp("startIndex");
      endIndex = context.lookupTemp("endIndex");
      loopCode = context.lookupTemp("loopCode");
      loopVarName = loopVar.value;
      forContext = new FLContext(context);
      forContext.isTransparent = true;
      if (methodsExecutionDebug) {
        log("FLFor ⇒ loop code is: " + loopCode.flToString());
      }
      for (i = l = ref = startIndex.value, ref1 = endIndex.value; ref <= ref1 ? l <= ref1 : l >= ref1; i = ref <= ref1 ? ++l : --l) {
        if (methodsExecutionDebug) {
          log("FLFor ⇒ loop iterating variable to " + i);
        }
        forContext.tempVariablesDict[ValidIDfromString(loopVarName)] = FLNumber.createNew(i);
        toBeReturned = (yield* loopCode["eval"](forContext, loopCode));
        if (toBeReturned != null) {
          if (context.throwing && (toBeReturned.flClass === FLDone || toBeReturned.flClass === FLBreak)) {
            context.throwing = false;
            if (toBeReturned.value != null) {
              toBeReturned = toBeReturned.value;
            }
            if (methodsExecutionDebug) {
              log("For ⇒ the loop exited with Done ");
            }
            break;
          }
          if (context.throwing && toBeReturned.flClass === FLReturn) {
            if (methodsExecutionDebug) {
              log("For ⇒ the loop exited with Return ");
            }
            break;
          }
        }
      }
      return toBeReturned;
    });
    return FLFor.addMethod(flTokenize("each ( ' variable ) in: ( theList ) do: ( 'code )"), function*(context) {
      var base, code, forContext, i, l, ref, theList, toBeReturned, variable;
      yield;
      context.isTransparent = true;
      if (methodsExecutionDebug) {
        log("context now tramsparent at depth: " + context.depth() + " with self: " + (typeof (base = context.self).flToString === "function" ? base.flToString() : void 0));
      }
      variable = context.lookupTemp("variable");
      theList = context.lookupTemp("theList");
      code = context.lookupTemp("code");
      if (theList.flClass !== FLList) {
        context.throwing = true;
        return FLException.createNew("for...each expects a list");
      }
      if (theList.isEmpty()) {
        return theList;
      }
      if (methodsExecutionDebug) {
        log("FLEach do on the list: " + theList.flToString());
      }
      forContext = new FLContext(context);
      forContext.isTransparent = true;
      for (i = l = 0, ref = theList.value.length; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
        forContext.throwing = false;
        if (methodsExecutionDebug) {
          log("FLEach element at " + i + " : " + (theList.elementAt(i)).flToString());
        }
        forContext.tempVariablesDict[ValidIDfromString(variable.value)] = theList.elementAt(i);
        if (methodsExecutionDebug) {
          log("FLEach do evaling...: " + code.flToString());
        }
        toBeReturned = (yield* code["eval"](forContext, code));
        if (toBeReturned != null) {
          if (context.throwing && (toBeReturned.flClass === FLDone || toBeReturned.flClass === FLBreak)) {
            context.throwing = false;
            if (toBeReturned.value != null) {
              toBeReturned = toBeReturned.value;
            }
            if (methodsExecutionDebug) {
              log("for-each-in-list loop exited with Done ");
            }
            break;
          }
          if (context.throwing && toBeReturned.flClass === FLReturn) {
            if (methodsExecutionDebug) {
              log("for-each-in-list loop exited with Return ");
            }
            break;
          }
        }
      }
      return toBeReturned;
    });
  };

  mainTurtle = null;

  initContext = function(context) {
    var itsInitialisation, j, keyword, keywords, keywordsAndTheirInit, ref, ref1, results;
    keywordsAndTheirInit = ["WorkSpace", FLWorkspace, "Class", FLClass, "List", FLList, "String", FLString, "Exception", FLException, "Number", FLNumber, "Boolean", FLBoolean, "Console", FLConsole, "Turtle", FLTurtle, "not", FLNot.createNew(), "true", FLBoolean.createNew(true), "false", FLBoolean.createNew(false), "for", FLFor.createNew(), "repeat1", FLRepeat1.createNew(), "done", FLDone.createNew(), "break", FLBreak.createNew(), "return", FLReturn.createNew(), "if", FLIfThen.createNew(), "forever", FLForever.createNew(), "repeat", FLRepeat2.createNew(), "try", FLTry.createNew(), "throw", FLThrow.createNew(), "to", FLTo.createNew(), "in", FLIn.createNew(), "accessUpperContext", FLAccessUpperContext.createNew(), "evaluationsCounter", FLEvaluationsCounter.createNew(), "nil", FLNil.createNew(), "console", FLConsole.createNew(), "turtle", (mainTurtle = FLTurtle.createNew()), "pause", FLPause.createNew(), "'", FLQuote.createNew(), ":", FLQuote.createNew(), "-", FLUnaryMinus.createNew(), "[", FLListLiteralArrayNotationStarter.createNew()];
    results = [];
    for (keywords = j = 0, ref = keywordsAndTheirInit.length; j < ref; keywords = j += 2) {
      ref1 = keywordsAndTheirInit.slice(keywords, +(keywords + 1) + 1 || 9e9), keyword = ref1[0], itsInitialisation = ref1[1];
      results.push(context.tempVariablesDict[ValidIDfromString(keyword)] = itsInitialisation);
    }
    return results;
  };

  quickReset = function() {
    var eachClass, j, len, results;
    rWorkspace = FLWorkspace.createNew();
    rWorkspace.environmentPrintout = "";
    console.log("resetting rWorkspace.environmentErrors");
    rWorkspace.environmentErrors = "";
    outerMostContext = new FLContext(null, rWorkspace);
    initContext(outerMostContext);
    mainTurtle.sendHome();
    allClasses = bootClasses.slice();
    results = [];
    for (j = 0, len = allClasses.length; j < len; j++) {
      eachClass = allClasses[j];
      results.push(eachClass.resetInstanceVariables());
    }
    return results;
  };

  reset = function() {
    clearClasses();
    initBootClasses();
    rWorkspace = FLWorkspace.createNew();
    rWorkspace.environmentPrintout = "";
    console.log("resetting rWorkspace.environmentErrors");
    rWorkspace.environmentErrors = "";
    outerMostContext = new FLContext(null, rWorkspace);
    initContext(outerMostContext);
    return mainTurtle.sendHome();
  };

  textOutputElement = null;

  canvasOutputElement = null;

  devicePixelRatio = 1;

  Fizzylogo.init = function(textOutElem, canvasOutElem, devPixRatio) {
    if (textOutElem != null) {
      log = function() {};
      dir = function() {};
    }
    textOutputElement = textOutElem;
    canvasOutputElement = canvasOutElem;
    devicePixelRatio = devPixRatio;
    if (canvasOutputElement != null) {
      canvasOutputElement.getContext('2d').scale(devicePixelRatio, devicePixelRatio);
    }
    return reset();
  };

  Fizzylogo.runOneStep = function*(code) {
    var parsed, returned;
    quickReset();
    parsed = flTokenize(code);
    log("evaluation " + indentation() + "messaging workspace with " + parsed.flToString());
    returned = (yield* parsed["eval"](outerMostContext, parsed));
    outerMostContext.returned = returned;
    console.log("evaluation " + indentation() + "end of workspace evaluation");
    console.log("rWorkspace.environmentPrintout " + rWorkspace.environmentPrintout);
    console.log("rWorkspace.environmentErrors " + rWorkspace.environmentErrors);
    if (outerMostContext.throwing && outerMostContext.returned.flClass === FLException) {
      log("evaluation " + indentation() + "exception: " + outerMostContext.returned.value);
      rWorkspace.environmentErrors += "! exception: " + outerMostContext.returned.value;
      log("rWorkspace.environmentErrors " + rWorkspace.environmentErrors);
      if (textOutputElement != null) {
        textOutputElement.value += rWorkspace.environmentErrors + "\n";
      }
    }
    return null;
  };

  run = function(code) {
    var gen, parsed, ret, yieldMode;
    quickReset();
    parsed = flTokenize(code);
    log("evaluation " + indentation() + "messaging workspace with " + parsed.flToString());
    yieldMode = false;
    yieldMode = true;
    if (yieldMode) {
      gen = parsed["eval"](outerMostContext, parsed);
      while (!(ret = gen.next()).done) {
        if (ret.value != null) {
          log("obtained: " + ret.value);
        }
        log("obtained: yieldingfromtoplevel");
      }
      outerMostContext.returned = ret.value;
    } else {
      outerMostContext.returned = parsed["eval"](outerMostContext, parsed);
    }
    log("evaluation " + indentation() + "end of workspace evaluation");
    console.log("rWorkspace.environmentErrors " + rWorkspace.environmentErrors);
    if (outerMostContext.throwing && outerMostContext.returned.flClass === FLException) {
      log("evaluation " + indentation() + "exception: " + outerMostContext.returned.value);
      rWorkspace.environmentErrors += "! exception: " + outerMostContext.returned.value;
      log("rWorkspace.environmentErrors " + rWorkspace.environmentErrors);
    }
    return null;
  };

}).call(this);
