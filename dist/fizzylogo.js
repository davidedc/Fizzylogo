// Generated by CoffeeScript 2.3.2
(function() {
  var ASSOCIATIVITY_RIGHT_TO_LEFT, DEBUG_STRINGIFICATION_CHECKS, FAILs, FLAccessUpperContext, FLAccessUpperContextClass, FLBoolean, FLBooleanClass, FLBreak, FLBreakClass, FLClass, FLClassClass, FLClasses, FLConsole, FLConsoleClass, FLContext, FLDone, FLDoneClass, FLEvaluationsCounter, FLEvaluationsCounterClass, FLException, FLExceptionClass, FLFor, FLForClass, FLForever, FLForeverClass, FLIfFallThrough, FLIfFallThroughClass, FLIfThen, FLIfThenClass, FLIn, FLInClass, FLList, FLListClass, FLListLiteralArrayNotation, FLListLiteralArrayNotationClass, FLListLiteralArrayNotationStarter, FLListLiteralArrayNotationStarterClass, FLNil, FLNilClass, FLNot, FLNotClass, FLNumber, FLNumberClass, FLObjects, FLPause, FLPauseClass, FLQuote, FLQuoteClass, FLRepeat1, FLRepeat1Class, FLRepeat2, FLRepeat2Class, FLReturn, FLReturnClass, FLString, FLStringClass, FLThrow, FLThrowClass, FLTo, FLToClass, FLToken, FLTokenClass, FLTry, FLTryClass, FLTurtle, FLTurtleClass, FLUnaryMinus, FLUnaryMinusClass, FLWorkspace, FLWorkspaceClass, Fizzylogo, OKs, StringFromValidID, ValidIDfromString, addDefaultMethods, allClasses, bootClasses, canvasOutputElement, clearClasses, commonSimpleValueEqualityFunction, commonSimpleValueInequalityFunction, contextDebug, devicePixelRatio, dir, flClassesDebug, flTokenize, i, indentation, initBootClasses, initContext, injectStrings, j, keyStr, linearize, listEvaluationsDebug, log, mainTurtle, methodsExecutionDebug, objectFindSignatureMakeCallDebug, outerMostContext, quickReset, rWorkspace, ref, ref1, removeComments, removeStatementSeparatorsBeforeAlignedConstructs, removeStrings, repeatFunctionContinuation, reset, run, sortFirstArrayAccordingToSecond, stringsTable_TO_CHECK_CONVERTIONS, testBody, testBodyMultiline, testResult, tests, textOutputElement, tokenizeCommand, tokenizerDebug, tokensDebug;

  Fizzylogo = {};

  // export as a global, whether it's in node or in the browser
  (typeof exports !== "undefined" && exports !== null ? exports : this).Fizzylogo = Fizzylogo;

  // Debug logging flags
  objectFindSignatureMakeCallDebug = false;

  listEvaluationsDebug = false;

  tokensDebug = false;

  tokenizerDebug = false;

  contextDebug = false;

  flClassesDebug = false;

  methodsExecutionDebug = false;

  ASSOCIATIVITY_RIGHT_TO_LEFT = true;

  rWorkspace = null;

  log = console.log;

  dir = console.dir;

  repeatFunctionContinuation = null;

  outerMostContext = null;

  DEBUG_STRINGIFICATION_CHECKS = false;

  if (DEBUG_STRINGIFICATION_CHECKS) {
    stringsTable_TO_CHECK_CONVERTIONS = {};
  }

  indentation = function() {
    //return " ".repeat(flContexts.length * 2)
    return "";
  };

  // to disambiguate between when we are operating
  // on JS arrays from when we are operating
  // on fizzylogo lists.
  Array.prototype.jsArrayPush = function(element) {
    return this.push(element);
  };

  // variation of base64, generates valid IDs from
  // an arbitrary string. Little known fact, javascript
  // IDs can start with and have some pretty wild chars
  // see https://stackoverflow.com/questions/1661197/what-characters-are-valid-for-javascript-variable-names
  keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789Γಠ_';

  ValidIDfromString = function(input) {
    var chr1, chr2, chr3, enc1, enc2, enc3, enc4, i, output, utf8_encode;
    //log "ValidIDfromString encoding: " + input
    if (/^([A-Z_][0-9A-Z_$]*)$/gi.test(input)) {
      //log "ValidIDfromString encoded as: " + input
      return input;
    }
    utf8_encode = function(string) {
      var c, n, utftext;
      string = string.replace(/\r\n/g, '\n');
      utftext = '';
      n = 0;
      while (n < string.length) {
        c = string.charCodeAt(n);
        if (c < 128) {
          utftext += String.fromCharCode(c);
        } else if (c > 127 && c < 2048) {
          utftext += String.fromCharCode(c >> 6 | 192);
          utftext += String.fromCharCode(c & 63 | 128);
        } else {
          utftext += String.fromCharCode(c >> 12 | 224);
          utftext += String.fromCharCode(c >> 6 & 63 | 128);
          utftext += String.fromCharCode(c & 63 | 128);
        }
        n++;
      }
      return utftext;
    };
    output = '';
    i = 0;
    input = utf8_encode(input);
    while (i < input.length) {
      chr1 = input.charCodeAt(i++);
      chr2 = input.charCodeAt(i++);
      chr3 = input.charCodeAt(i++);
      enc1 = chr1 >> 2;
      enc2 = (chr1 & 3) << 4 | chr2 >> 4;
      enc3 = (chr2 & 15) << 2 | chr3 >> 6;
      enc4 = chr3 & 63;
      if (isNaN(chr2)) {
        enc3 = enc4 = 64;
      } else if (isNaN(chr3)) {
        enc4 = 64;
      }
      output = output + keyStr.charAt(enc1) + keyStr.charAt(enc2) + keyStr.charAt(enc3) + keyStr.charAt(enc4);
    }
    //log "ValidIDfromString encoded as: " + "$" + output
    return "$" + output;
  };

  StringFromValidID = function(input) {
    var a, b, c, d, e, f, g, i, output, utf8_decode;
    if (/^([A-Z_][0-9A-Z_$]*)$/gi.test(input)) {
      return input;
    }
    utf8_decode = function(string) {
      var charCode, i, output;
      output = '';
      i = 0;
      charCode = 0;
      while (i < string.length) {
        charCode = string.charCodeAt(i);
        if (charCode < 128) {
          output += String.fromCharCode(charCode);
          i++;
        } else if (charCode > 191 && charCode < 224) {
          output += String.fromCharCode((charCode & 31) << 6 | string.charCodeAt(i + 1) & 63);
          i += 2;
        } else {
          output += String.fromCharCode((charCode & 15) << 12 | (string.charCodeAt(i + 1) & 63) << 6 | string.charCodeAt(i + 2) & 63);
          i += 3;
        }
      }
      return output;
    };
    input = input.replace(/[^ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789Γಠ_]/g, '');
    input = input.replace(/^\$/, '');
    //log "StringFromValidID decoding: " + input
    output = '';
    i = 0;
    while (i < input.length) {
      d = keyStr.indexOf(input.charAt(i++));
      e = keyStr.indexOf(input.charAt(i++));
      f = keyStr.indexOf(input.charAt(i++));
      g = keyStr.indexOf(input.charAt(i++));
      a = d << 2 | e >> 4;
      b = (e & 15) << 4 | f >> 2;
      c = (f & 3) << 6 | g;
      output += String.fromCharCode(a);
      if (f !== 64) {
        output += String.fromCharCode(b);
      }
      if (g !== 64) {
        output += String.fromCharCode(c);
      }
    }
    return utf8_decode(output);
  };

  sortFirstArrayAccordingToSecond = function(targetData, refData) {
    var indices, ref;
    // create an array of indices [0, 1, ... targetData.length] and
    // sort those specularly to refData
    indices = (function() {
      var results = [];
      for (var j = 0, ref = targetData.length; 0 <= ref ? j < ref : j > ref; 0 <= ref ? j++ : j--){ results.push(j); }
      return results;
    }).apply(this);
    // Sort array of indices according to the reference data.
    indices.sort(function(indexA, indexB) {
      if (refData[indexA] < refData[indexB]) {
        //log "refData[indexA] < refData[indexB] " + refData[indexA]  + " " + refData[indexB]
        return -1;
      } else if (refData[indexA] > refData[indexB]) {
        //log "refData[indexA] > refData[indexB] " + refData[indexA]  + " " + refData[indexB]
        return 1;
      }
      //log "refData[indexA] = refData[indexB] " + refData[indexA]  + " " + refData[indexB]
      return 0;
    });
    // Map array of indices to corresponding values of the target array.
    return indices.map(function(index) {
      return targetData[index];
    });
  };

  allClasses = [];

  tokenizeCommand = function(command) {
    // we can just use the dot instead of 's.
    // Using 's would make things more complicated
    // because we also use ' as quote symbol
    command = command.replace(/'[ ]*s[\s]/g, ".");
    // separate parens
    command = command.replace(/\(/g, " ( ");
    command = command.replace(/\)/g, " ) ");
    command = command.replace(/\[/g, " [ ");
    command = command.replace(/\]/g, " ] ");
    // also "," which is used in list literals
    // (i.e. the "array form" way of initialising a list)
    // separates anything before or after
    command = command.replace(/,/g, " , ");
    // this is the statement separator
    command = command.replace(/;/g, " ; ");
    // @ as shorthand for "self." or "self", à la coffeescript:
    // any @ that is just before something that is not a closing delimiter
    // is a field access. Note that there must be no space, so:

    //    @print // is a field access

    //  ...is different from:

    //    @ print // not a field access

    // any other @ (i.e. next to a space or a closing delimeter) is just
    // "self" like in the second case.
    command = command.replace(/@([^\]);\s])/g, " self . $1");
    command = command.replace(/@/g, " self ");
    
    // separate numbers and punctuation from anything else
    // note that:
    // 1) numbers and punctuation are dealt together because
    // otherwise something like 3.14 is separated into 3 . 14
    // so we need to handle them both here so we get that floating
    // point case before we separate the dots

    // 2) consecutive operators like ++, --, +=, **
    // ^^ are left untouched, so you can give good meaning to them
    // for example this:
    //   a++ +
    // becomes
    //   a ++ +
    // so the spacing between the operators can be significant

    // see this playground with an example:
    // https://regex101.com/r/LRqxeN/3

    command = command.replace(/([0-9]*\.[0-9]+([eE][- ]?[0-9]*)?)|([^+\-^*\/<>()\[\]=←.!%])([+\-^*\/<>()\[\]=←.!%]+)/g, "$1$3 $4 ");
    // separates the *end* of a sequence of punctuations from what
    // comes after. e.g. 3.14 =a becomes 3.14 = a
    // not that we can't/don't need to do that with the dot because
    // a) it was already done by the regex above and
    // b) it would wreck floating point numbers
    command = command.replace(/([+\-^*\/<>()\[\]=←!%])([^+\-^*\/<>()\[\]=←!%])/g, "$1 $2");
    // things that are now a / _2 become a /_ 2
    // this is so we can have an "underscore" version of
    // an operator, in this case floor division
    command = command.replace(/([+\-^*\/<>=←!%_])[ ]+_/g, "$1_ ");
    // separate the minuses from everything else other than
    // the decrement case "--". This is so we can make sense
    // of things like "1*-2" like most language can
    command = command.replace(/([+\-^*\/<>()\[\]=←!%])-/g, "$1 -");
    command = command.replace(/- -/g, "--");
    command = command.replace(/'/g, " ' ");
    command = command.replace(/:/g, " : ");
    // quote symbol used by Rosetta Smalltalk
    // while we use the standard ' i.e. "quote"
    //command = command.replace /@/g, " @ "

    // collapse all multiple spaces to one
    command = command.replace(/[ ]+/g, " ");
    return command = command.trim();
  };

  removeComments = function(code) {
    // this fizzylogo is empty-line sensitive, this regex is custom
    // and also properly removes the lines where there are comments
    // (i.e. it doesn't just strip the comment leaving empty the line
    // where it was)

    // 1st part: multi-line comments starting with new line
    // 2nd part: multi-line comments NOT starting with new line
    // 3rd part: single-line comments starting with new line
    // 4th part: single-line comments NOT starting with new line
    // 5th part: multi-line comment at the end of the text
    // 6th part: single-line comment at the end of the text

    // see: https://regex101.com/r/U5pYX4/1
    return code.replace(/(^)\/\*[\s\S]*?\*\/\n?|([^\\\n])\/\*[\s\S]*?\*\/|(^)\/\/.*$\n|([^\\\n])\/\/.*$|\n\/\/.*$|\n\/\*[\s\S]*?\*\n/gm, "$1$2$3$4");
  };

  // replace all the strings with
  // references to a table, which we'll replace back
  // later with string objects.
  removeStrings = function(code) {
    var codeWithoutStrings;
    codeWithoutStrings = code.replace(/"((?:[^"\\\n]|\\.)*)"/g, function(all, quoted) {
      if (DEBUG_STRINGIFICATION_CHECKS) {
        stringsTable_TO_CHECK_CONVERTIONS[ValidIDfromString(quoted)] = quoted;
      }
      //log "$STRING_TOKEN_" + (ValidIDfromString quoted) + " i.e." + quoted
      return "$STRING_TOKEN_" + (ValidIDfromString(quoted));
    });
    return codeWithoutStrings;
  };

  // replaces strings and regexs keyed by index with an array of strings
  // see "removeStrings" function
  injectStrings = function(code) {
    code = code.replace(/\$STRING_TOKEN_([\$a-zA-Z0-9_]+)/g, function(all, index) {
      var val;
      val = StringFromValidID(index);
      if (DEBUG_STRINGIFICATION_CHECKS) {
        if (val !== stringsTable_TO_CHECK_CONVERTIONS[index]) {
          throw "ERROR cannot get back string from ID, got back: " + StringFromValidID(index);
        }
      }
      //log "INJECTING $STRING_TOKEN_" + index
      //log "INJECTING i.e. " +  val
      return val;
    });
    return code;
  };

  // transform indentations into brackets
  // it tries to be smart, so you can add "innocuous" extra
  // indentation.
  // Typical innocuous indentations that is useful to add
  // is the kind that transforms things like this:

  //    for each word in
  //    ﹍myList
  //    do
  //    ﹍codeToBeRun eval
  //    something else

  // into this:

  //    for each word in
  //    ﹍﹍myList            // still "under the umbrella" of for
  //    ﹍do                  // still "under the umbrella" of for
  //    ﹍﹍codeToBeRun eval  // still "under the umbrella" of do
  //    something else       // NOT "under the umbrella" of do anymore
  //                         // BUT it's still "under the umbrella" of
  //                            for so it's OK

  // basically you can add tabs within reason if you preserve
  // the logical alignment of things, i.e. if a line is still
  // "under the umbrella of" or "aligned to" the same line
  // then it's OK.

  // It works this way:
  //   1) for any jump "inside" of more
  //      than one tab is corrected to a jump of one tab.
  //   2) for any jump outside:
  //      the current line is checked for the fist line above
  //      that is either aligned with it or to the left of it.
  //      Since we keep the correct identation for all
  //      lines above, we pick the "correct" tab
  //      of the current line to be the tab of the found
  //      one above.
  //   3) once the "correct" tab of this line is found
  //      as per 1) and 2), we just add and remove
  //      () based on the difference in the "correct"
  //      tab numbers.
  linearize = function(code) {
    var actualLineTabs, correctedIndentationDifference, correctedLineTabs, eachLine, j, k, l, leftOrRightOrAligned, line, linesWithBlockStart, match, outputSource, ref, ref1, rx, sourceByLine, startOfPreviousLine, startOfThisLine, unclosedParens;
    code = code.replace(/﹍/g, " ");
    // remove all empty lines,
    // because we really don't want
    // to have the length of empty lines to
    // be meaningful. That would be really cruel,
    // since they are invisible,
    // so to avoid any such situation we just remove empty
    // lines here so that we are forced to give the user
    // alternative ways.
    code = code.replace(/^\s*[\r\n]/gm, "");
    sourceByLine = code.split("\n");
    startOfPreviousLine = "";
    linesWithBlockStart = [];
    unclosedParens = 0;
    outputSource = "";
    actualLineTabs = [];
    correctedLineTabs = [];
    for (eachLine = j = 0, ref = sourceByLine.length; (0 <= ref ? j < ref : j > ref); eachLine = 0 <= ref ? ++j : --j) {
      line = sourceByLine[eachLine];
      //log "checking " + line
      rx = RegExp("^([ ]*)", 'gm');
      match = rx.exec(line);
      if (eachLine === 0) {
        outputSource += " " + line;
        actualLineTabs.push(0);
        correctedLineTabs.push(0);
        continue;
      }
      startOfThisLine = match[1];
      //log "start of line: >" + startOfThisLine + "<"

      // leftOrRightOrAligned is only used to understand if the current
      // line if to the left, to the right or aligned. The actual
      // correct difference in indentation is calculated later.
      leftOrRightOrAligned = startOfThisLine.length - actualLineTabs[actualLineTabs.length - 1];
      actualLineTabs.push(startOfThisLine.length);
      if (tokenizerDebug) {
        log("linearize startOfThisLine: " + startOfThisLine + " " + startOfThisLine.length + " difference in alignment: " + leftOrRightOrAligned + " content: " + line);
      }
      if (leftOrRightOrAligned === 0) {
        correctedIndentationDifference = 0;
        // this is the statement separator
        outputSource += " ; " + line;
      } else if (leftOrRightOrAligned > 0) {
        correctedIndentationDifference = 1;
        if (tokenizerDebug) {
          log("linearize adding a ( ");
        }
        outputSource += (Array(correctedIndentationDifference + 1).join("(")) + line; // leftOrRightOrAligned < 0
      } else {
        for (k = l = ref1 = actualLineTabs.length - 2; (ref1 <= 0 ? l <= 0 : l >= 0); k = ref1 <= 0 ? ++l : --l) {
          if (tokenizerDebug) {
            log(" k: " + k + " checking line " + sourceByLine[k] + " for alignment ");
          }
          if (actualLineTabs[k] <= startOfThisLine.length) {
            if (tokenizerDebug) {
              log("line " + sourceByLine[k] + " is aligned with me and the corrected tabs for that were: " + correctedLineTabs[k]);
            }
            correctedIndentationDifference = correctedLineTabs[k] - correctedLineTabs[correctedLineTabs.length - 1];
            break;
          }
        }
        if (tokenizerDebug) {
          log("linearize adding " + (-correctedIndentationDifference) + " ) ");
        }
        
        // if a line is aligned exactly with a line above,
        // then we add a ";" as well. So for example in

        //   if a==5:
        //   ﹍console print "yes a is 5"
        //   else:
        //   ﹍console print "no a is not 5"
        //   console print ". the end."

        // the if, the else and the last line are all separated by
        // ";"
        // However, we make some tokens "eat up" the previous ";" in
        // via the "removeStatementSeparatorsBeforeAlignedConstructs"
        // function, in this case the "else" eats up the ";" separator
        // before it, so the if/else construction can work
        // properly.
        // This is the best way I found to have the "if/else-if/else"
        // construct to behave like an expression, and in the process
        // I could also get rid of the fakeCatch and fakeElse
        // tricks.
        if (actualLineTabs[k] === startOfThisLine.length) {
          outputSource += (Array(-correctedIndentationDifference + 1).join(")")) + " ; " + line;
        } else {
          outputSource += (Array(-correctedIndentationDifference + 1).join(")")) + line;
        }
      }
      unclosedParens += correctedIndentationDifference;
      correctedLineTabs.push(unclosedParens);
    }
    // final close-off of pending parens
    outputSource += Array(unclosedParens + 1).join(")");
    //log "code length at identifyBlockStarts: " + code.split("\n").length
    if (tokenizerDebug) {
      log("linearized program: " + outputSource.replace(/^[ ]*/g, ""));
    }
    return outputSource.replace(/^[ ]*/g, "");
  };

  // since we separate with ";" all aligned lines, we need
  // a way to make the program "flow" again in some cases,
  // so here we go. Note that this is not strictly necessary,
  // you can always indent in non-aligned way, for example
  // in the case of the "do" one could write:

  //    for each word in
  //    ﹍﹍myList
  //    ﹍do
  //    ﹍﹍codeToBeRun eval
  //    something else

  // and that needs no fixing by this function. However,
  // it's rather unconventional to have that second line
  // to have TWO tabs, expecially in some cases such as
  // if/else-if/else , where you'd have to write:

  //   if a==5:
  //   ﹍﹍console print "yes a is 5"
  //   ﹍else:
  //   ﹍﹍console print "no a is not 5"
  //   console print ". the end."

  // which is somewhat unconventional.
  // Hence, we apply this trick here.
  removeStatementSeparatorsBeforeAlignedConstructs = function(command) {
    var eachToken, j, len, ref;
    ref = ["else", "catch"];
    for (j = 0, len = ref.length; j < len; j++) {
      eachToken = ref[j];
      command = command.replace(new RegExp("[; ]*(" + eachToken + "[ \n])", "g"), " $1");
    }
    command = command.replace(/[ ]+/g, " ");
    command = command.trim();
    return command;
  };

  flTokenize = function(command) {
    var eachToken, j, len, listsStack, nestedList, simpleTokenization;
    listsStack = [];
    listsStack.jsArrayPush(FLList.createNew());
    // join the multi-line first before we do the strings
    command = command.replace(/\\\n[ ]*/g, " ");
    // remove comments first, so we can ignore
    // any strings that might be in them
    command = removeComments(command);
    command = removeStrings(command);
    if (tokenizerDebug) {
      log("codeWithoutStrings: " + command);
    }
    command = linearize(command);
    if (tokenizerDebug) {
      log("linearized command: " + command);
    }
    // let's normalise the input string so we can
    // tokenise it just by looking at the spaces.
    if (tokenizerDebug) {
      log("command before replacements: " + command);
    }
    command = tokenizeCommand(command);
    if (tokenizerDebug) {
      log("command after replacements: " + command);
    }
    //log "obtained: command after replacements: " + command
    command = removeStatementSeparatorsBeforeAlignedConstructs(command);
    if (tokenizerDebug) {
      log("removed statement separators before aligned constructs: " + command);
    }
    simpleTokenization = command.split(" ");
    for (j = 0, len = simpleTokenization.length; j < len; j++) {
      eachToken = simpleTokenization[j];
      if (tokenizerDebug) {
        log("eachToken: " + eachToken);
      }
      if (/\$STRING_TOKEN_([\$a-zA-Z0-9_]+)/g.test(eachToken)) {
        if (tokenizerDebug) {
          log(eachToken + " is a string literal");
        }
        listsStack[listsStack.length - 1] = listsStack[listsStack.length - 1].flListImmutablePush(FLToken.createNew(eachToken));
      } else if (/^\($/.test(eachToken)) {
        nestedList = FLList.createNew();
        listsStack.jsArrayPush(nestedList);
      } else if (/^\)$/.test(eachToken)) {
        nestedList = listsStack.pop();
        listsStack[listsStack.length - 1] = listsStack[listsStack.length - 1].flListImmutablePush(nestedList);
      } else {
        if (tokenizerDebug) {
          log(eachToken + " is something else");
        }
        listsStack[listsStack.length - 1] = listsStack[listsStack.length - 1].flListImmutablePush(FLToken.createNew(eachToken));
      }
    }
    return listsStack[listsStack.length - 1];
  };

  FLObjects = (function() {
    class FLObjects {
      constructor(flClass) {
        this.flClass = flClass;
        this.instanceVariablesDict = {};
        this.instanceVariablesDict[ValidIDfromString("class")] = this.flClass;
      }

      isClass() {
        return this.name != null;
      }

      // this is needed because you want, say, "6" to find its
      // methods in its class Number, but you want Number to
      // find its methods in Number, not in Class. That's
      // a problem in the case of user classes, when you do

      //   myClass = Class new; myObject = myClass new

      // you really want the "new" of myClass to be found in
      // myClass, not in Class.
      methodsHolder() {
        if (this.isClass()) {
          return this;
        } else {
          return this.flClass;
        }
      }

      flToString() {
        if (this.isClass()) {
          if (this.name === "") {
            return "[anonymous class (an object of class Class)]";
          } else {
            return "[class \"" + this.name + "\" (an object of class Class)]";
          }
        } else if (this.flClass.name !== "") {
          return "[object of class \"" + this.flClass.name + "\"]";
        } else {
          return "[object of anonymous class]";
        }
      }

      flToStringForList() {
        return this.flToString();
      }

      eval(theContext) {
        //yield
        return this;
      }

      // Note that only part of the message might be consumed
      // "self" remains the same since we are still in the
      // same "method call" and the same "object". I.e. this
      // is not a method call (although it might lead to one),
      // this is progressing within an existing call
      findSignatureBindParamsAndMakeCall(methodInvocationToBeChecked, theContext, previousPriority, previousAssociativity, previousReceiver, previousSignature) {
        var classContainingMethods, contextToBeReturned, eachAssociativity, eachElementOfInvocation, eachElementOfSignature, eachPriority, eachSignature, eachSignatureIndex, goodMatchSoFar, j, methodInvocation, newContext, originalMethodInvocationStart, paramToken, ref, returnedContext, valueToBeBound;
        if (objectFindSignatureMakeCallDebug) {
          log("object findSignature+makeCall: looking up method invocation " + methodInvocationToBeChecked.flToString() + " with signatures!");
          log("object findSignature+makeCall: looking up method invocation, is method empty? " + methodInvocationToBeChecked.isEmpty());
          log("object findSignature+makeCall: I am: " + this.value);
        }
        // fake context push so that we can make
        // the context stack handling easier
        // the for loop
        // TODO check that this is not left hanging
        //flContexts.jsArrayPush null
        classContainingMethods = this.methodsHolder();
//log "evaluation - message patterns: -------------> "
//for eachClassPattern in classContainingMethods.msgPatterns
//  log "evaluation - message patterns: " + indentation() + eachClassPattern.flToString()
//log "evaluation - message patterns: <------------- "
        for (eachSignatureIndex = j = 0, ref = classContainingMethods.msgPatterns.length; (0 <= ref ? j < ref : j > ref); eachSignatureIndex = 0 <= ref ? ++j : --j) {
          eachSignature = classContainingMethods.msgPatterns[eachSignatureIndex];
          eachPriority = classContainingMethods.priorities[eachSignatureIndex];
          eachAssociativity = classContainingMethods.associativities[eachSignatureIndex];
          goodMatchSoFar = true;
          //if eachSignature.flToString() == "( + ( operandum ) )"
          //  log "obtained eachPriority: " + eachPriority
          if (objectFindSignatureMakeCallDebug) {
            log("object findSignature+makeCall: signature: " + eachSignature.flToString());
            log("object findSignature+makeCall: previousPriority, eachPriority: " + previousPriority + " , " + eachPriority);
            log("object findSignature+makeCall: previousAssociativity, eachAssociativity: " + previousAssociativity + " , " + eachAssociativity);
          }
          if ((previousPriority != null) && (eachPriority != null)) {
            if (previousPriority < eachPriority) {
              if (objectFindSignatureMakeCallDebug) {
                log("breaking matching due to priority going up: previousPriority, eachPriority: " + previousPriority + " , " + eachPriority);
              }
              goodMatchSoFar = false;
            // IF there is a case of same-priority, then we need to check
            // whether we are in a case of right-to-left associativity
            // such as in the case of "not not tue" and "- - 2"
            // in which case we don't want to break, we want to continue
            } else if (previousPriority === eachPriority) {
              if (objectFindSignatureMakeCallDebug) {
                log("object findSignature+makeCall: eachAssociativity != ASSOCIATIVITY_RIGHT_TO_LEFT: " + (eachAssociativity !== ASSOCIATIVITY_RIGHT_TO_LEFT));
                log("object findSignature+makeCall: previousReceiver.flClass != @flClass: " + (previousReceiver.flClass !== this.flClass));
                log("object findSignature+makeCall: eachSignature.flToString() != previousSignature.flToString(): " + (eachSignature.flToString() !== previousSignature.flToString()));
                log("object findSignature+makeCall: eachSignature.flToString(), previousSignature.flToString(): " + eachSignature.flToString() + " , " + previousSignature.flToString());
              }
              // turns out that it's useful to lump together many operators
              // that start with the same token when we consider their
              // right-associativity, depending on just the first token.
              // For example, "^" and "^ -" should be lumped together, and same for
              // all assignment methods all starting with "="
              // (although we get right-associativity for "=" by just leaving its
              // precedence to null for the time being)
              if (eachAssociativity !== ASSOCIATIVITY_RIGHT_TO_LEFT || previousReceiver.flClass !== this.flClass || eachSignature.firstElement().flToString() !== previousSignature.firstElement().flToString()) {
                goodMatchSoFar = false;
              }
            }
          }
          //log "evaluation " + indentation() + "  matching - checking if this signature matches: " + eachSignature.flToString()
          methodInvocation = methodInvocationToBeChecked;
          // remove the previous context because it was a
          // botched attempt to match a signature
          //flContexts.pop()
          //log "evaluation " + indentation() + "  ////////////////////////////////////// CREATING NEW CONTEXT WITH NEW SELF " + @

          // this is the ONLY place where we change self!
          newContext = new FLContext(theContext, this);
          //flContexts.jsArrayPush newContext
          //log "evaluation " + indentation() + "  matching - checking if signature matches this invocation " + methodInvocation.flToString()
          //log "evaluation " + indentation() + "  matching - checking if signature matches this invocation " + methodInvocation.flToString()
          originalMethodInvocationStart = methodInvocation.cursorStart;
          if (goodMatchSoFar) {
            while (!(eachSignature.isEmpty() || methodInvocation.isEmpty())) {
              if (objectFindSignatureMakeCallDebug) {
                log("evaluation " + indentation() + "  matching: - next signature piece: " + eachSignature.flToString() + " is token: " + " with: " + methodInvocation.flToString());
              }
              [eachElementOfSignature, eachSignature] = eachSignature.nextElement();
              
              // the element of a signature can only be of two kinds:
              // a token or an FLList containing one parameter (with
              // prepended "@" in case the parameter doesn't require
              // evaluation)
              if (eachElementOfSignature.flClass !== FLList && eachElementOfSignature.flClass !== FLToken) {
                theContext.throwing = true;
                // TODO this error should really be a stock error referanceable
                // from the workspace because someone might want to catch it.
                theContext.returned = FLException.createNew("signature of a method should only contain tokens or lists. Found instead: " + eachElementOfSignature.flToString() + " . Perhaps some variable in the signature has been closed?");
                return [theContext, methodInvocationToBeChecked];
              }
              if (eachElementOfSignature.flClass === FLToken) {
                // if the signature contains a token, the message
                // must contain the same token, otherwise we don't
                // have a match.
                [eachElementOfInvocation, methodInvocation] = methodInvocation.nextElement();
                //log "evaluation " + indentation() + "  matching tokens: - next signature piece: " + eachElementOfSignature.flToString() + " is token: " + (eachElementOfSignature.flClass == FLToken) + " with: " + eachElementOfInvocation.flToString()

                // ok at least the message contains a token, but
                // now we have to check that they spell the same
                if (objectFindSignatureMakeCallDebug) {
                  log("******* evaluation " + indentation() + "  matching tokens: - next signature piece: " + eachElementOfSignature.flToString() + " is token: " + (eachElementOfSignature.flClass === FLToken) + " with: " + eachElementOfInvocation.flToString());
                }
                if (eachElementOfSignature.value === eachElementOfInvocation.value) {
                  if (objectFindSignatureMakeCallDebug) {
                    log("evaluation " + indentation() + "  matching - token matched: " + eachElementOfSignature.flToString());
                  }
                  // OK good match of tokens,
                  // check the next token in the signature
                  continue;
                } else {
                  // no match between the tokens, check next signature
                  goodMatchSoFar = false;
                  break;
                }
              } else {
                // the signature has a param. we have to check if
                // it requires an evaluation or not
                if (objectFindSignatureMakeCallDebug) {
                  log("evaluation " + indentation() + "  matching - getting the token inside the parameter: " + eachElementOfSignature.flToString());
                }
                paramToken = eachElementOfSignature.getParamToken();
                //dir paramToken
                if (objectFindSignatureMakeCallDebug) {
                  log("evaluation " + indentation() + "  matching - token inside the parameter: " + paramToken.flToString());
                }
                if (eachElementOfSignature.isEvaluatingParam()) {
                  if (objectFindSignatureMakeCallDebug) {
                    log("evaluation " + indentation() + "  matching - need to evaluate next msg element from invocation: " + methodInvocation.flToString() + " and bind to: " + paramToken.flToString());
                  }
                  // note how we need to evaluate the params in a context that has the
                  // same SELF as the calling one, not the new one that
                  // we are creating with the new SELF of the callee, otherwise, say,
                  // passing self, self would always bind
                  // to the receiver, which we don't want
                  // like in "7 * self" we don't want to bind self to 7

                  // yield from
                  [returnedContext, methodInvocation] = methodInvocation.partialEvalAsMessage(theContext, eachPriority, eachAssociativity, this, classContainingMethods.msgPatterns[eachSignatureIndex]);
                  valueToBeBound = returnedContext.returned;
                } else {
                  // don't need to evaluate the parameter
                  if (objectFindSignatureMakeCallDebug) {
                    log("evaluation " + indentation() + "  matching - need to get next msg element from invocation: " + methodInvocation.flToString() + " and bind to: " + paramToken.flToString());
                  }
                  [valueToBeBound, methodInvocation] = methodInvocation.nextElement();
                }
                if (objectFindSignatureMakeCallDebug) {
                  log("evaluation " + indentation() + "  matching - adding paramater " + paramToken.flToString() + " to tempVariables dictionary in current frame");
                }
                newContext.tempVariablesDict[ValidIDfromString(paramToken.value)] = valueToBeBound;
                // ok we matched a paramenter, now let's keep matching further
                // parts of the signature
                continue;
              }
            }
          }
          // ok we took a signature, and now here it either matched or it didn't,
          // as indicated by the goodMatchSoFar flag
          if (eachSignature.isEmpty() && goodMatchSoFar) {
            // now, the correct PC that we need to report is
            // the original plus what we consumed from matching the
            // signature.
            if (objectFindSignatureMakeCallDebug) {
              log("evaluation " + indentation() + "  matching - consumed from matching this sig: " + (methodInvocation.cursorStart - originalMethodInvocationStart));
              log("evaluation " + indentation() + "             methodInvocation: " + methodInvocation.flToString() + " cursor start: " + methodInvocation.cursorStart + " original methodInvocation start: " + originalMethodInvocationStart);
              log("methodInvocation.cursorStart - originalMethodInvocationStart: " + " " + methodInvocation.cursorStart + " " + originalMethodInvocationStart);
              log("theContext method invocation after: " + methodInvocation.flToString());
            }
            theContext.unparsedMessage = null;
            // yield from
            contextToBeReturned = this.methodCall(classContainingMethods.methodBodies[eachSignatureIndex], newContext, methodInvocationToBeChecked.definitionContext);
            return [contextToBeReturned, methodInvocation];
          }
        }
        // we are still here trying to match but
        // there are no signatures left, time to give up.
        if (objectFindSignatureMakeCallDebug) {
          log("evaluation " + indentation() + "  matching - no match found");
        }
        return [null, methodInvocationToBeChecked];
      }

      // this could be native, in which case it's a JS call,
      // or non-native, in which case it will result into
      // evaluation of the message that makes up the body.
      methodCall(methodBody, theContext, definitionContext) {
        var contextToBeReturned;
        //yield
        // note that this doesn't consume from the calling
        // context, because from the caller perspective it only matters
        // what we consume from the invocation, which we accounted
        // for already in the process of finding the signature and
        // binding the parameters.
        // i.e. we just consume
        // while we matched the correct method, which we account for
        // when we do the matching, not here after the matching happened.

        // However we do affect the PC of the callee context.
        if (methodBody.flClass === FLList) {
          if (objectFindSignatureMakeCallDebug) {
            log("evaluation " + indentation() + "  matching - method body: " + methodBody.flToString());
          }
          // non-native method, i.e. further fizzylogo code
          // creates a context and evals the message in it
          // the rest of the message is not used because all of the list should
          // be run, no remains from the message body should overspill
          // into the calling context.
          // yield from
          theContext.returned = methodBody.eval(theContext, methodBody);
        } else {
          if (objectFindSignatureMakeCallDebug) {
            log("evaluation " + indentation() + "  matching - NATIVE method body: " + methodBody);
          }
          // native method, i.e. coffeescript/javascript code
          // note that in the yielding version, these must all
          // be generator functions
          // yield from
          theContext.returned = methodBody.call(this, theContext, definitionContext);
        }
        contextToBeReturned = theContext;
        return contextToBeReturned;
      }

    };

    FLObjects.prototype.flClass = null; // the class it belongs to

    FLObjects.prototype.instanceVariablesDict = null; // a JS dictionary

    return FLObjects;

  }).call(this);

  FLContext = (function() {
    // Notes on the scope mechanics:
    // tokens are always looked-up in the temp variables.
    // temp variables are local to the context, _however_
    // if you open a context (with the accessUpperContext) command
    // then you can see and influence the context(s) above.
    // So, in a normal method invocation the new context is sealed,
    // but other constructs such as the _for_ construct
    // create an "open" context
    // i.e. the tokens can also be looked up in the context(s) above
    // as well and
    // the newly created variables are visible from above.
    // (however note that the for construct creates the loop
    // variable in its context so not to clobber existing
    // ones and not to leak the loop variable).
    // to access fields of an object, the "."... methods are used
    // , which explicitely use the following atems to look up
    // the dictionaries of the receiver, no reference to temp
    // variables in the context is made in those cases.
    class FLContext {
      // contexts should only be created when "self" changes
      // (on method invocation), or when you want to
      // "seal" some temporary variables that might
      // be needed/created (e.g. the "for" case).
      constructor(previousContext, newSelf) {
        this.previousContext = previousContext;
        if (newSelf) {
          this.self = newSelf;
        } else {
          this.self = this.previousContext.self;
        }
        this.tempVariablesDict = {};
      }

      //log "evaluation " + indentation() + "######### constructing new context at depth: " + @depth() + " with message: " + @message.flToString()
      depth() {
        var ascendingTheContext, depthCount;
        depthCount = 0;
        ascendingTheContext = this.previousContext;
        while (ascendingTheContext != null) {
          depthCount++;
          ascendingTheContext = ascendingTheContext.previousContext;
        }
        return depthCount;
      }

      // climbs up the context chain
      firstNonTransparentContext() {
        var ascendingTheContext, base, base1;
        ascendingTheContext = this;
        // the top-most context is NOT transparent,
        // so we know this loop will never go "beyond" the top
        while (ascendingTheContext.isTransparent) {
          if (contextDebug) {
            log("evaluation " + indentation() + "firstNonTransparentContext: context is transparent at depth " + ascendingTheContext.depth() + " with self: " + (typeof (base = ascendingTheContext.self).flToString === "function" ? base.flToString() : void 0));
          }
          ascendingTheContext = ascendingTheContext.previousContext;
        }
        if (contextDebug) {
          log("first non-transparent context is the one at depth: " + ascendingTheContext.depth() + " with self: " + (typeof (base1 = ascendingTheContext.self).flToString === "function" ? base1.flToString() : void 0));
        }
        return ascendingTheContext;
      }

      lookupTemp(variableNameAsString) {
        return this.tempVariablesDict[ValidIDfromString(variableNameAsString)];
      }

      lookupTempValue(variableNameAsString) {
        return (this.lookupTemp(variableNameAsString)).value;
      }

      // from here, a Token matches a temp variable, which could be
      // in this context, or further up across transparent contexts,
      // OR at the top level context.
      whichDictionaryContainsToken(theToken) {
        var base, base1, contextBeingSearched, tokenString;
        contextBeingSearched = this;
        tokenString = theToken.value;
        if (tokenString === "self") {
          return this.firstNonTransparentContext();
        }
        while (true) {
          //log "evaluation " + indentation() + "context temps: " 
          //for keys of contextBeingSearched.tempVariablesDict
          //  log keys

          // check if temp variable is in current context.
          if (contextBeingSearched.tempVariablesDict[ValidIDfromString(tokenString)] != null) {
            if (contextDebug) {
              log("evaluation " + indentation() + "lookup: found in context at depth " + contextBeingSearched.depth() + " with self: " + (typeof (base = contextBeingSearched.self).flToString === "function" ? base.flToString() : void 0));
            }
            return contextBeingSearched.tempVariablesDict;
          }
          // nothing found from this context, move up
          // to the sender (i.e. the callee)
          if (contextDebug) {
            log("evaluation " + indentation() + "lookup: not found in context at depth " + contextBeingSearched.depth() + " with self: " + (typeof (base1 = contextBeingSearched.self).flToString === "function" ? base1.flToString() : void 0));
          }
          if (contextBeingSearched.isTransparent) {
            if (contextDebug) {
              log("evaluation " + indentation() + "lookup: ... this context is transparent so I can go up");
            }
            contextBeingSearched = contextBeingSearched.previousContext;
          } else {
            break;
          }
        }
        // check if temp variable is in the outer-most context
        if (outerMostContext.tempVariablesDict[ValidIDfromString(tokenString)] != null) {
          return outerMostContext.tempVariablesDict;
        }
        if (contextDebug) {
          log("evaluation " + indentation() + "lookup: " + tokenString + " not found!");
        }
        return null;
      }

    };

    FLContext.prototype.self = null; // a FLObject

    FLContext.prototype.tempVariablesDict = null; // a JS dictionary

    FLContext.prototype.previousContext = null;

    FLContext.prototype.returned = null;

    FLContext.prototype.isTransparent = false;

    return FLContext;

  }).call(this);

  FLClasses = (function() {
    class FLClasses extends FLObjects {
      
      // this is when you create a new class, e.g.
      // Number, String, or custom user-made classes.
      constructor(name) {
        super(name);
        this.name = name;
        this.flClass = FLClass;
        this.resetInstanceVariables();
        
        // this is useful because then we can compare classes
        // (i.e. Number == String)
        // using the usual value check
        this.value = this;
        if (!this.isClass()) {
          this.name = this.constructor.name;
          this.name = this.name.substr(2, this.name.length - 7);
        }
        this.resetMethods();
        // the temp variables contents
        // are in the context, not here in the class
        // similarly, the instance variables contents
        // are in the object, not here in the class
        allClasses.push(this);
      }

      rename(newName) {
        return this.name = newName;
      }

      resetMethods() {
        this.msgPatterns = [];
        this.methodBodies = [];
        this.priorities = [];
        return this.associativities = [];
      }

      resetInstanceVariables() {
        this.instanceVariablesDict = {};
        return this.instanceVariablesDict[ValidIDfromString("class")] = FLClass;
      }

      // this is when you create a new instance of this class,
      // for example a new number or a new string or a new
      // object from custom user-made classes.
      // as you see, classes are objects.
      createNew(theClass) {
        var toBeReturned;
        // turn things like "flNumberClass" into "Number"
        //log "class name: " + @name
        toBeReturned = new FLObjects(theClass);
        return toBeReturned;
      }

      addMethod(signature, methodBody, priority, associativity) {
        var eachSignature, i, j, ref, sortOrderStrings;
//log "adding method " + signature.flToString() + " to: " + @flToString()
//log "sort order: " + signature.sortOrderString()
        for (i = j = 0, ref = this.msgPatterns.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
          eachSignature = this.msgPatterns[i];
          //dir eachSignature
          if (eachSignature.flToString() === signature.flToString()) {
            this.msgPatterns[i] = signature;
            this.methodBodies[i] = methodBody;
            this.priorities[i] = priority;
            this.associativities[i] = associativity;
            if (flClassesDebug) {
              log("adding method  signature (replacing): " + signature.flToString() + " body: " + (typeof methodBody.flToString === "function" ? methodBody.flToString() : void 0));
            }
            return;
          }
        }
        if (flClassesDebug) {
          log("adding method  signature (appending): " + signature.flToString() + " body: " + (typeof methodBody.flToString === "function" ? methodBody.flToString() : void 0));
        }
        this.msgPatterns.jsArrayPush(signature);
        this.methodBodies.jsArrayPush(methodBody);
        this.priorities.jsArrayPush(priority);
        this.associativities.jsArrayPush(associativity);
        // sort all signatures in order of increasing genericity i.e.
        // more generic matches will be done last. See "sortOrderString"
        // method for more details.
        sortOrderStrings = this.msgPatterns.map(function(elem) {
          return elem.sortOrderString();
        });
        this.msgPatterns = sortFirstArrayAccordingToSecond(this.msgPatterns, sortOrderStrings);
        this.methodBodies = sortFirstArrayAccordingToSecond(this.methodBodies, sortOrderStrings);
        this.priorities = sortFirstArrayAccordingToSecond(this.priorities, sortOrderStrings);
        return this.associativities = sortFirstArrayAccordingToSecond(this.associativities, sortOrderStrings);
      }

    };

    FLClasses.prototype.name = null; // a standard JS string

    FLClasses.prototype.msgPatterns = null; // an array of FLLists

    FLClasses.prototype.methodBodies = null; // an array of FLLists

    FLClasses.prototype.priorities = null; // an array of JS Numbers

    FLClasses.prototype.associativities = null; // JS Array

    return FLClasses;

  }).call(this);

  //for i in [0...@msgPatterns.length]
  //  log "msgPatterns ordered " + sortOrderStrings[i] + " : " + @msgPatterns[i].flToString()
  //log "-------------------- "

  // class "Class". Like all classes, it's an object, and there
  // is only one of its kind, because this one Class object will be used to
  // create other classes, i.e. special objects that can
  // create further objects.
  FLClassClass = class FLClassClass extends FLClasses {
    // create new classes e.g. myClass = Class new
    createNew(theName = "") {
      var newUserClass;
      newUserClass = new FLClasses(theName);
      addDefaultMethods(newUserClass);
      // the class we are creating has a "new"
      // so user can create objects for it
      newUserClass.addMethod(flTokenize("new"), function(context) {
        var objectTBR, returnedContext, toBeReturned;
        //yield
        log("///////// creating a new object from a user class!");
        objectTBR = newUserClass.createNew();
        objectTBR.flClass = newUserClass;
        objectTBR.instanceVariablesDict[ValidIDfromString("class")] = newUserClass;
        log("///////// creating a new object from a user class - user class of object: " + objectTBR.flClass.flToString());
        log("///////// creating a new object from a user class - objectTBR: " + objectTBR.flToString());
        log("///////// creating a new object from a user class - making space for instanceVariables");
        // we give the chance to automatically execute some initialisation code,
        // but without any parameters. For example drawing a box, giving a message,
        // initing some default values.
        // However for initialisations that _requires_ parameters, the user
        // will have to use a method call such as the "initWith" in FLException.
        // The reasoning is that if the user is bothering with initing with
        // parameters, then it might as well bother with sticking an
        // "initWith" method call in front of them.
        // Passing parameters to whenNew (and consuming them) from in here
        // defies the whole architecture of the mechanism.
        log("invoking whenNew");
        // yield from
        returnedContext = objectTBR.findSignatureBindParamsAndMakeCall(flTokenize("whenNew"), context);
        returnedContext = returnedContext[0];
        toBeReturned = returnedContext.returned;
        return toBeReturned;
      });
      // also all user classes can change their name
      newUserClass.addMethod(flTokenize("nameit (newName)"), function(context) {
        var newName;
        //yield
        newName = context.tempVariablesDict[ValidIDfromString("newName")];
        if (typeof this.rename === "function") {
          this.rename(newName.value);
        }
        return this;
      });
      return newUserClass;
    }

  };

  FLClass = new FLClassClass(FLClass);

  FLClass.flClass = FLClass;

  FLClass.instanceVariablesDict[ValidIDfromString("class")] = FLClass;

  FLTokenClass = class FLTokenClass extends FLClasses {
    createNew(tokenString) {
      var toBeReturned;
      toBeReturned = super.createNew(FLToken);
      toBeReturned.value = tokenString;
      toBeReturned.flToString = function() {
        var toPrint;
        if (/\$STRING_TOKEN_([\$a-zA-Z0-9_]+)/g.test(this.value)) {
          toPrint = "TOKEN:" + injectStrings(this.value);
        } else {
          toPrint = this.value;
        }
        return toPrint;
      };
      toBeReturned.isStatementSeparator = function() {
        return this.value === ";";
      };
      // check if temp variable is visible in either the running context or the
      // definition context.
      // if not, create it as a temp variable in the current running context
      toBeReturned.whichDictionaryContainsToken = function(theContext, definitionContext) {
        var existingLookedUpValuePlace;
        if (tokensDebug) {
          log("evaluation " + indentation() + "finding location of token: " + this.value);
        }
        existingLookedUpValuePlace = theContext.whichDictionaryContainsToken(this);
        if (existingLookedUpValuePlace != null) {
          if (tokensDebug) {
            log("evaluation " + indentation() + "found token " + this.value + " in running context");
          }
          return existingLookedUpValuePlace;
        } else {
          if (tokensDebug) {
            log("evaluation " + indentation() + " not found token " + this.value + " in running context, ...trying in definitionContext");
          }
          existingLookedUpValuePlace = definitionContext != null ? definitionContext.whichDictionaryContainsToken(this) : void 0;
          if (existingLookedUpValuePlace != null) {
            if (tokensDebug) {
              log("evaluation " + indentation() + "found token " + this.value + " in definition context");
            }
            return existingLookedUpValuePlace;
          }
        }
        if (tokensDebug) {
          log("evaluation " + indentation() + "not found token " + this.value + " anywhere");
          log("evaluation " + indentation() + "creating temp token: " + this.value + " at depth: " + theContext.firstNonTransparentContext().depth() + " with self: " + theContext.firstNonTransparentContext().self.flToString());
        }
        // no such variable, hence we create it as temp, but
        // we can't create them in this very call context, that would
        // be useless, we place it in the context of the _previous_ context
        // note that this means that any construct that creates a new context
        // will seal the temp variables in it. For example "for" loops. This
        // is like the block scoping of C or Java. If you want function scoping, it
        // could be achieved for example by marking in a special way contexts
        // that have been created because of method calls and climbing back
        // to the last one of those...
        return theContext.firstNonTransparentContext().tempVariablesDict;
      };
      toBeReturned.assignValue = function(theContext, definitionContext, valueToAssign) {
        var dictToPutValueIn;
        dictToPutValueIn = this.whichDictionaryContainsToken(theContext, definitionContext);
        dictToPutValueIn[ValidIDfromString(this.value)] = valueToAssign;
        if (tokensDebug) {
          return log("evaluation " + indentation() + "stored value in dictionary");
        }
      };
      toBeReturned.lookupValue = function(theContext, definitionContext) {
        var existingLookedUpValuePlace;
        if (tokensDebug) {
          log("evaluation " + indentation() + "looking up value of token: " + this.value);
        }
        existingLookedUpValuePlace = this.whichDictionaryContainsToken(theContext, definitionContext);
        if (contextDebug) {
          //log "evaluation " + indentation() + "lookup: " + @value + " found dictionary and it contains:"
          //dir existingLookedUpValuePlace
          log("evaluation " + indentation() + "lookup: " + this.value + " also known as " + (ValidIDfromString(this.value)));
          log("evaluation " + indentation() + "lookup: value looked up: ");
        }
        //dir existingLookedUpValuePlace[ValidIDfromString @value]
        return existingLookedUpValuePlace[ValidIDfromString(this.value)];
      };
      toBeReturned.eval = function(theContext, remainingMessage, fromListElementsEvaluation) {
        var lookupValue, ref;
        //yield
        // shortcut: instead of using "@a←5"
        // one can now just use "a=5"
        if ((remainingMessage != null) && remainingMessage.flClass === FLList) {
          if (tokensDebug) {
            log("remainingMessage: " + remainingMessage.flToString());
            log("secondElementIsEqual: " + remainingMessage.secondElementIsEqual());
          }
          if (!fromListElementsEvaluation && (remainingMessage.startsWithIncrementOrDecrementOperator() || remainingMessage.startsWithCompoundAssignmentOperator() || remainingMessage.secondElementIsEqual())) {
            return this;
          }
        }
        // first always look up if there is a value for anything
        // if there is, that wins all the times, so you could
        // have an exotic value for "false", or "2" that is completely
        // different from what it would naturally be.
        lookupValue = this.lookupValue(theContext, remainingMessage.definitionContext);
        if (lookupValue != null) {
          return lookupValue;
        // you could match the leading "+" or "-", however this would
        // be uneven with the general case of handling leading + and - 
        //else if /^[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?$/.test @value
        } else if (/^[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?$/.test(this.value)) {
          return FLNumber.createNew(this.value);
        } else if (/\$STRING_TOKEN_([\$a-zA-Z0-9_]+)/g.test(this.value)) {
          //log "token eval returning string: " + injectStrings @value 
          return FLString.createNew(injectStrings(this.value));
        } else if (/^true$/.test(this.value)) {
          return FLBoolean.createNew(true);
        } else if (/^false$/.test(this.value)) {
          return FLBoolean.createNew(false);
        }
        if (tokensDebug) {
          log("evaluation " + indentation() + "token " + this.value + " contents: " + ((ref = theContext.returned) != null ? ref.value : void 0));
          log("evaluation " + indentation() + "not found temp token: " + this.value);
        }
        // if we are here it means that we can't find any
        // meaning for this token,
        // which is something that we are going to report.
        // We might even try to send a message to it, in which
        // case we'll report that too.
        // rWorkspace.lastUndefinedAtom = @

        //log "token eval returning nil"
        return FLNil.createNew();
      };
      return toBeReturned;
    }

  };

  FLToken = new FLTokenClass();

  FLListClass = class FLListClass extends FLClasses {
    // A note about messages, which are special lists.
    // ...a fizzylogo message is just an FLList which is meant to
    // be used as a message only, which means that:
    //    - its elements don't change
    //    - because the underlying elements don't change, it can be
    //      copied quickly (keeping reference to old values)  
    //    - it can be split ( "." splits statements)
    //    - we can "consume" one or more elements
    //    - we don't need messages to be fizzylogo objects,
    //      they are part of the runtime and invisible to
    //      the user.
    //    - a message is never sent a message, because
    //      a message is not a fizzylogo object

    // So we try to make some of these operations more efficient
    // for messages, since all operations don't modify the elements
    // we can do splits and we can consume things just by moving
    // around a start index and an end index of an unchanging
    // array of elements.

    // Basically we can navigate/consume the program without
    // copying around the elements.

    // The alternative would be to use no indexes and just
    // do shallow copies at any change. That would be fine for performance
    // but there is just something about the constant shallow copying
    // during interpretation that looks like it's a quadratic
    // operation, so we say no to that.
    emptyMessage() {
      var newMessage;
      newMessage = FLList.createNew().toMessage();
      return newMessage;
    }

    // unused at the moment
    emptyList() {
      var newMessage;
      newMessage = FLList.createNew();
      return newMessage;
    }

    createNew() {
      var toBeReturned;
      toBeReturned = super.createNew(FLList);
      toBeReturned.value = [];
      // these are only used for messages, which
      // are special kinds of lists
      toBeReturned.cursorStart = 0;
      toBeReturned.cursorEnd = -1;
      toBeReturned.definitionContext = null;
      // nothing much to do, but it makes it more
      // clear in the code to show "how"
      // one is using the message/list
      toBeReturned.toList = function() {
        this.isMessage = false;
        return this;
      };
      // nothing much to do, but it makes it more
      // clear in the code to show "how"
      // one is using the message/list
      toBeReturned.toMessage = function() {
        this.isMessage = true;
        return this;
      };
      toBeReturned.flListImmutablePush = function(theItemToPush) {
        var copy;
        copy = this.shallowCopy();
        copy.value.jsArrayPush(theItemToPush);
        copy.cursorEnd++;
        return copy;
      };
      toBeReturned.mutablePush = function(theItemToPush) {
        this.value.jsArrayPush(theItemToPush);
        this.cursorEnd++;
        return this;
      };
      toBeReturned.elementAt = function(theElementNumber) {
        if (this.value[this.cursorStart + theElementNumber] != null) {
          return this.value[this.cursorStart + theElementNumber];
        } else {
          return FLNil.createNew();
        }
      };
      toBeReturned.elementAtSetMutable = function(theElementNumber, theValue) {
        if (this.isMessage || this.cursorStart !== 0) {
          throw "elementAtSetMutable: you can't set an element of a message";
        }
        this.value[theElementNumber] = theValue;
        this.cursorEnd = this.value.length - 1;
        return this;
      };
      // creates a string for a matcher signature, such that
      // when these strings are ordered alphabetically, the
      // matchers are ordered from more specific to more
      // generic.

      // This is done like so:
      //  a token generates an 'a'
      //  a non-evaluating param generates 'b'
      //  evaluating param generates 'c'
      //  empty slot generates 'd'
      //  the string is then padded with 'd' up to 10 places

      // in this way, anything starting with a token will come
      // first, and longer token matches will prevail.
      // the empty signature will always go last, and more empty
      // slots will generate more 'd', so shorter signatures will
      // tend to be last.
      toBeReturned.sortOrderString = function() {
        var element, i, j, paddingLength, ref, sortOrderString;
        sortOrderString = "";
        for (i = j = 0, ref = this.length(); (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
          element = this.elementAt(i);
          if (element.flClass === FLToken) {
            sortOrderString += "a";
          }
          if (element.flClass === FLList) {
            if (element.isEvaluatingParam()) {
              sortOrderString += "c";
            } else {
              sortOrderString += "b";
            }
          }
        }
        paddingLength = 10 - sortOrderString.length;
        return sortOrderString += new Array(paddingLength).join('d');
      };
      toBeReturned.giveDefinitionContextToElements = function(context) {
        var i, j, ref, results;
        results = [];
        for (i = j = 0, ref = this.length(); (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
          if (listEvaluationsDebug) {
            log("toBeReturned.giveDefinitionContextToElements");
          }
          if ((this.elementAt(i)).flClass === FLList) {
            results.push((this.elementAt(i)).giveDefinitionContextToElements(context));
          } else {
            results.push((this.elementAt(i)).definitionContext = context);
          }
        }
        return results;
      };
      toBeReturned.flToString = function() {
        var i, j, ref, toBePrinted;
        //log "@value:" + @value
        //log "list print: length: " + @length()
        if (this.length() <= 0) {
          return "empty message";
        }
        toBePrinted = "(";
        for (i = j = 0, ref = this.length(); (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
          //log "@value element " + i + " : " + @value[i]
          //log "@value element " + i + " content: " + @value[i].value
          toBePrinted += " " + this.elementAt(i).flToStringForList();
        }
        toBePrinted += " )";
        return toBePrinted;
      };
      toBeReturned.evalFirstListElementAndTurnRestIntoMessage = function(theContext) {
        var firstElement, restOfMessage;
        firstElement = this.firstElement();
        if (listEvaluationsDebug) {
          log("           " + indentation() + "evaling element " + firstElement.value);
        }
        // yield from
        theContext.returned = firstElement.eval(theContext, this);
        restOfMessage = this.restOfMessage();
        return [theContext, restOfMessage];
      };
      toBeReturned.findReceiver = function(theContext) {
        var receiver, restOfMessage, returnedContext;
        // yield from
        [returnedContext, restOfMessage] = this.evalFirstListElementAndTurnRestIntoMessage(theContext);
        receiver = returnedContext.returned;
        if (listEvaluationsDebug) {
          log("evaluation " + indentation() + "remaining part of list to be sent as message is: " + restOfMessage.flToString());
        }
        return [returnedContext, restOfMessage, receiver];
      };
      // this eval requires that the whole list is consumed
      toBeReturned.eval = function(theContext) {
        var ref, ref1, returnedContext, returnedMessage;
        // yield from
        [returnedContext, returnedMessage] = this.partialEvalAsMessage(theContext);
        if (listEvaluationsDebug) {
          log("list eval - returned message: " + returnedMessage.flToString());
          log("list eval - returned context: " + (returnedContext != null ? typeof returnedContext.flToString === "function" ? returnedContext.flToString() : void 0 : void 0));
          log("list eval - returnedcontext.returned: " + ((ref = returnedContext.returned) != null ? typeof ref.flToString === "function" ? ref.flToString() : void 0 : void 0));
          log("list eval - returnedcontext.unparsedMessage: " + ((ref1 = returnedContext.unparsedMessage) != null ? typeof ref1.flToString === "function" ? ref1.flToString() : void 0 : void 0));
        }
        if (!returnedMessage.isEmpty()) {
          if (listEvaluationsDebug) {
            log("list couldn't be fully evaluated: " + this.flToString() + " unexecutable: " + returnedMessage.flToString());
          }
          theContext.throwing = true;
          return FLException.createNew("message was not understood: " + returnedMessage.flToString());
        }
        return returnedContext.returned;
      };
      // this eval doesn't require that the whole list is consumed,
      // it just consumes what it can
      toBeReturned.partialEvalAsMessage = function(theContext, priority, associativity, theReceiver, theSignature) {
        var base, eachStatement, j, len, receiver, restOfMessage, returnedContext, returnedMessage, statements;
        // a list without any messages just evaluates itself, which
        // consists of the following:
        //  a) separate all the statements (parts separated by ";")
        //  b) for each statement, evaluate its first element as the receiver
        //  c) send to the receiver the remaining part of the statement, as the message
        if (listEvaluationsDebug) {
          log("evaluation " + indentation() + "list received empty message, evaluating content of list");
          log("evaluation " + indentation() + "  i.e. " + this.flToString());
        }
        // todo this doesn't seem to be needed
        this.toList();
        statements = this.separateStatements();
        for (j = 0, len = statements.length; j < len; j++) {
          eachStatement = statements[j];
          if (listEvaluationsDebug) {
            log("evaluation " + indentation() + "evaluating single statement");
            log("evaluation " + indentation() + "  i.e. " + eachStatement.flToString());
          }
          returnedContext = theContext;
          restOfMessage = eachStatement;
          // yield from
          [returnedContext, restOfMessage, receiver] = restOfMessage.findReceiver(returnedContext);
          if (listEvaluationsDebug) {
            log("found next receiver and now message is: " + restOfMessage.flToString());
            //dir receiver
            log("3 returnedContext.throwing: " + returnedContext.throwing);
          }
          while (true) {
            // where we detect an exception being thrown
            // works as follows: now that we found the first receiver,
            // we send it the rest of the original message hence getting a
            // new receiver, whom we send again the rest of the message
            // and so and and so forth. We keep using the same context, so we
            // accrete the state changes to the same context i.e. the one we
            // are running the method body in.

            // we'll exit this loop in a number of ways:
            //  - no more messages to consume
            //  - exceptions being thrown or done/return objects
            //  - the message is not understood
            if (theContext.throwing || returnedContext.throwing) {
              if (listEvaluationsDebug) {
                log("throw escape");
              }
              // the return is a special type of exception that
              // we can catch before doing the next "method call"
              // so we catch it here. We have to go up a level
              // while the context is transparent, because "proper"
              // method calls are done in a non-transparent context
              if (listEvaluationsDebug) {
                log("context at depth " + theContext.depth() + " with self: " + (typeof (base = theContext.self).flToString === "function" ? base.flToString() : void 0) + " is transparent: " + theContext.isTransparent);
              }
              if (receiver.flClass === FLReturn && !theContext.isTransparent) {
                if (listEvaluationsDebug) {
                  log("got a return!");
                }
                theContext.throwing = false;
                theContext.returned = receiver.value;
              } else {
                if (listEvaluationsDebug) {
                  log(" throwing the receiver up " + receiver.flToString());
                }
                theContext.throwing = true;
                theContext.returned = receiver;
              }
              return [theContext, FLList.emptyMessage()];
            }
            if (listEvaluationsDebug) {
              log("evaluation " + indentation() + "receiver: " + (receiver != null ? typeof receiver.flToString === "function" ? receiver.flToString() : void 0 : void 0));
              log("evaluation " + indentation() + "message: " + restOfMessage.flToString());
            }
            // now actually send the message to the receiver. Note that
            // only part of the message might be consumed, in which case
            // we'll have to find the result from what we can consume and then
            // send the remaining part to such result. This is why
            // we have to keep iterating until the whole message is consumed
            if ((receiver.flClass === FLNumber || receiver.flClass === FLString || receiver.flClass === FLBoolean) && restOfMessage.isEmpty()) {
              returnedContext = theContext;
              returnedMessage = restOfMessage;
              returnedContext.returned = receiver;
              if (listEvaluationsDebug) {
                log("skipping empty evaluation because basic type ");
              }
            } else {
              // yield from
              [returnedContext, returnedMessage] = receiver.findSignatureBindParamsAndMakeCall(restOfMessage, theContext, priority, associativity, theReceiver, theSignature);
            }
            if (returnedContext == null) {
              returnedContext = theContext;
              returnedContext.returned = receiver;
              if (listEvaluationsDebug) {
                log("restOfMessage: " + restOfMessage.flToString());
                log("receiver: " + receiver.flToString());
              }
              returnedContext.unparsedMessage = returnedMessage;
              // if the object was sent the empty message and it wasn't
              // understood, and there is nothing after the object,
              // then we move on to the next statement rather than
              // quitting altogether
              if (returnedMessage.isEmpty()) {
                break;
              }
              return [returnedContext, returnedMessage];
            }
            receiver = returnedContext.returned;
            restOfMessage = returnedMessage;
            if (listEvaluationsDebug) {
              log("evaluation " + indentation() + "list evaluation returned: " + (receiver != null ? typeof receiver.flToString === "function" ? receiver.flToString() : void 0 : void 0));
              log("theContext.throwing: " + theContext.throwing);
              log("returnedContext.throwing: " + returnedContext.throwing);
              log("restOfMessage: " + restOfMessage);
            }
            if (restOfMessage.isEmpty() && (returnedContext.justDidAFieldOrArrayAccess == null) && !(theContext.throwing || returnedContext.throwing) && !((receiver != null ? receiver.flClass : void 0) === FLException && (receiver != null ? receiver.thrown : void 0)) && !((receiver != null ? receiver.flClass : void 0) === FLIfFallThrough)) {
              if (listEvaluationsDebug) {
                log("breaking and moving on to next statement");
              }
              break;
            }
          }
          if (listEvaluationsDebug) {
            log("evaluation " + indentation() + "list: nothing more to evaluate");
          }
          theContext.returned = receiver;
        }
        if (listEvaluationsDebug) {
          log("evaluation " + indentation() + "list: theContext.returned: " + theContext.returned);
        }
        //dir theContext.returned
        //flContexts.pop()
        return [theContext, restOfMessage];
      };
      toBeReturned.length = function() {
        return this.cursorEnd - this.cursorStart + 1;
      };
      toBeReturned.restOfMessage = function() {
        var copy;
        copy = this.copy();
        copy.cursorStart++;
        return copy;
      };
      toBeReturned.firstElement = function() {
        if (this.cursorStart > this.cursorEnd) {
          throw "no first element, array is empty";
        }
        return this.elementAt(0);
      };
      toBeReturned.startsWithCompoundAssignmentOperator = function() {
        if (this.length() >= 2) {
          if ((this.elementAt(1)).flClass === FLToken) {
            // test for things like "+=", "*=" etc.
            if (/([+\-^*\/%_]+=)/g.test((this.elementAt(1)).value)) {
              if (listEvaluationsDebug) {
                log("startsWithCompoundAssignmentOperator: yes");
              }
              return true;
            }
          }
        }
        if (listEvaluationsDebug) {
          log("startsWithCompoundAssignmentOperator: no");
        }
        return false;
      };
      toBeReturned.startsWithIncrementOrDecrementOperator = function() {
        if (this.length() >= 2) {
          if ((this.elementAt(1)).flClass === FLToken) {
            if ((this.elementAt(1)).value === "++" || (this.elementAt(1)).value === "--") {
              if (listEvaluationsDebug) {
                log("startsWithIncrementOrDecrementOperator: yes");
              }
              return true;
            }
          }
        }
        if (listEvaluationsDebug) {
          log("startsWithIncrementOrDecrementOperator: no");
        }
        return false;
      };
      toBeReturned.secondElementIsEqual = function() {
        if (this.length() >= 2) {
          if ((this.elementAt(1)).flClass === FLToken) {
            if ((this.elementAt(1)).value === "=") {
              return true;
            }
          }
        }
        return false;
      };
      // returns the first element and returns
      // a copy of the rest of the message
      toBeReturned.nextElement = function() {
        return [this.firstElement(), this.restOfMessage()];
      };
      toBeReturned.advanceMessageBy = function(numberOfElements) {
        var copy;
        
        //if numberOfElements > @length()
        //  return FLList.emptyMessage()
        copy = this.copy();
        copy.cursorStart += numberOfElements;
        return copy;
      };
      toBeReturned.isEmpty = function() {
        return this.length() <= 0;
      };
      toBeReturned.copy = function() {
        var copy;
        copy = FLList.createNew();
        copy.value = this.value;
        copy.cursorStart = this.cursorStart;
        copy.cursorEnd = this.cursorEnd;
        copy.isMessage = this.isMessage;
        copy.definitionContext = this.definitionContext;
        return copy;
      };
      toBeReturned.shallowCopy = function() {
        var copy;
        copy = this.copy();
        copy.value = this.value.slice();
        return copy;
      };
      toBeReturned.isEvaluatingParam = function() {
        return this.length() === 1;
      };
      toBeReturned.getParamToken = function() {
        if (this.isEvaluatingParam()) {
          return this.elementAt(0);
        } else {
          return this.elementAt(1);
        }
      };
      toBeReturned.separateStatements = function() {
        var arrayOfStatements, base, base1, base2, i, j, lastStatementEnd, ref, ref1, statementToBeAdded;
        //log "evaluation " + indentation() + "separating statements   start: " + @flToString()
        arrayOfStatements = [];
        lastStatementEnd = this.cursorStart - 1;
        for (i = j = ref = this.cursorStart, ref1 = this.cursorEnd; (ref <= ref1 ? j <= ref1 : j >= ref1); i = ref <= ref1 ? ++j : --j) {
          if ((typeof (base = this.value[i]).isStatementSeparator === "function" ? base.isStatementSeparator() : void 0) || (i === this.cursorEnd)) {
            statementToBeAdded = this.copy().toList();
            statementToBeAdded.cursorStart = lastStatementEnd + 1;
            statementToBeAdded.cursorEnd = i - 1;
            if (i === this.cursorEnd && !(typeof (base1 = this.value[this.cursorEnd]).isStatementSeparator === "function" ? base1.isStatementSeparator() : void 0)) {
              //log " last char: " + @value[@cursorEnd].flToString()
              statementToBeAdded.cursorEnd++;
            }
            lastStatementEnd = i;
            if (!statementToBeAdded.isEmpty() && !(typeof (base2 = statementToBeAdded.firstElement()).isStatementSeparator === "function" ? base2.isStatementSeparator() : void 0)) {
              //log " adding: " + statementToBeAdded.flToString()
              arrayOfStatements.jsArrayPush(statementToBeAdded);
            }
          }
        }
        //log "evaluation " + indentation() + "separating statements isolated new statement " + statementToBeAdded.flToString()
        return arrayOfStatements;
      };
      return toBeReturned;
    }

  };

  FLList = new FLListClass();

  // an ListLiteralArrayNotationStarter is needed to
  // start creation of FizzyLogo Lists with a traditional "array literal"
  // syntax i.e. with elements that are separated by commas, and
  // each element is evaluated
  // e.g.:
  //  a = [someVariable, 1+2, "a" + "b", -2, - 2, 1-2]
  FLListLiteralArrayNotationStarterClass = class FLListLiteralArrayNotationStarterClass extends FLClasses {
    createNew() {
      var toBeReturned;
      toBeReturned = super.createNew(FLListLiteralArrayNotationStarter);
      toBeReturned.value = "[";
      return toBeReturned;
    }

  };

  FLListLiteralArrayNotationStarter = new FLListLiteralArrayNotationStarterClass();

  // a ListLiteralArrayNotation is just a temporary object to create
  // a FizzyLogo List.

  // Note that there are no "Array"s in FL, everything is done
  // via FizzyLogo "List"s, we call this ListLiteralArrayNotation
  // because it looks like an array literal but it's not, it's
  // a List literal in the form of a traditional "array notation"
  // of other languages.

  // A ListLiteralArrayNotation will resolve itself to a List
  // when the closing "]" is found.

  // Contrary to lists, an ListLiteralArrayNotation accepts the
  // ", (elementToBeAdded)" message to add
  // elements to the list, and as indicated by the
  // signature each element is evaluated before being
  // added.

  // So, all of this is so we can initiate Lists
  // of evaluated elements with a
  // "standard" notation like:

  //   myList = [someVariable, 1+2, "a" + "b", -2, - 2, 1-2]

  // Note how the "," is now needed (it wasn't needed for
  // normal lists) so we can initialise things like

  //   myList = [ 1 , - 2 ]

  // which would have a different result without the ","

  // This sorts of assignments would be impossible to do
  // with the standard List assignment like so:

  //   myList = '(2+2)

  // ...since this "quoted List assignment" doesn't quite
  // evaluate the elements, it rather preserves the
  // structure so for example the "+" is preserved.
  // (however, this "quoted List assignment"
  // is useful as it is since this is how we can store code
  // using Lists).
  FLListLiteralArrayNotationClass = class FLListLiteralArrayNotationClass extends FLClasses {
    createNew() {
      var toBeReturned;
      toBeReturned = super.createNew(FLListLiteralArrayNotation);
      toBeReturned.value = FLList.createNew();
      return toBeReturned;
    }

  };

  FLListLiteralArrayNotation = new FLListLiteralArrayNotationClass();

  FLQuoteClass = class FLQuoteClass extends FLClasses {
    createNew() {
      return super.createNew(FLQuote);
    }

  };

  FLQuote = new FLQuoteClass();

  FLBooleanClass = class FLBooleanClass extends FLClasses {
    createNew(value) {
      var toBeReturned;
      toBeReturned = super.createNew(FLBoolean);
      toBeReturned.value = value;
      toBeReturned.flToString = function() {
        return this.value;
      };
      return toBeReturned;
    }

  };

  FLBoolean = new FLBooleanClass();

  // If-then-elseif-else structures require a little
  // trick to work well with the "chaining" mechanics of
  // fizzylogo.

  // First off, the first taken branch mandates another
  // receiver to be found, so that we can follow
  // an if-then-elseif-else structure immediately with
  // another command.

  // Secondly, whenever a branch is taken, the
  // following elses all play out as objects, and
  // they all do nothing, they just eat up the branches.
  // So, whenever a branch is taken, all the following
  // branches are eaten up and do nothing, and again we
  // end up executing the command after the structure.

  // Thirdly, all the starting non-taken branches
  // (i.e. all the non-taken branches before the taken one)
  // all reply with an IfFallThough object, which becomes the
  // receiver, and either:
  //  - is followed by else-if and else, in which case it
  //    does the predicate checks and takes the branch
  //    (in which case it mandates another receiver and all
  //    the rest of the structure is eaten up), or not
  //    (replying itself, to check for the following cases),
  //    or
  //  - if anything else other than "else-if" or "else"
  //    is sent to it, it just mandates a new receiver.
  //    This happens when it reaches the end of the
  //    if-then-elseif-else structure, after which
  //    the next commands can follow right away.

  // This is similar to the try-catch mechanism, but there
  // an "exception" falls through the catchers.
  FLIfThenClass = class FLIfThenClass extends FLClasses {
    createNew() {
      return super.createNew(FLIfThen);
    }

  };

  FLIfThen = new FLIfThenClass();

  // See IfThen class for explanation.
  FLIfFallThroughClass = class FLIfFallThroughClass extends FLClasses {
    createNew() {
      return super.createNew(FLIfFallThrough);
    }

  };

  FLIfFallThrough = new FLIfFallThroughClass();

  FLExceptionClass = class FLExceptionClass extends FLClasses {
    // value is the error message as a string
    createNew(value) {
      var toBeReturned;
      toBeReturned = super.createNew(FLException);
      toBeReturned.value = value;
      toBeReturned.flToString = function() {
        return this.value;
      };
      return toBeReturned;
    }

  };

  FLException = new FLExceptionClass();

  FLRepeat1Class = class FLRepeat1Class extends FLClasses {
    createNew() {
      return super.createNew(FLRepeat1);
    }

  };

  FLRepeat1 = new FLRepeat1Class();

  FLRepeat2Class = class FLRepeat2Class extends FLClasses {
    createNew() {
      return super.createNew(FLRepeat2);
    }

  };

  FLRepeat2 = new FLRepeat2Class();

  FLForClass = class FLForClass extends FLClasses {
    createNew() {
      return super.createNew(FLFor);
    }

  };

  FLFor = new FLForClass();

  FLInClass = class FLInClass extends FLClasses {
    createNew() {
      var toBeReturned;
      toBeReturned = super.createNew(FLIn);
      toBeReturned.value = "in";
      return toBeReturned;
    }

  };

  FLIn = new FLInClass();

  FLTryClass = class FLTryClass extends FLClasses {
    createNew() {
      return super.createNew(FLTry);
    }

  };

  FLTry = new FLTryClass();

  FLThrowClass = class FLThrowClass extends FLClasses {
    createNew() {
      return super.createNew(FLThrow);
    }

  };

  FLThrow = new FLThrowClass();

  FLNotClass = class FLNotClass extends FLClasses {
    createNew() {
      return super.createNew(FLNot);
    }

  };

  FLNot = new FLNotClass();

  FLToClass = class FLToClass extends FLClasses {
    createNew() {
      return super.createNew(FLTo);
    }

  };

  FLTo = new FLToClass();

  FLDoneClass = class FLDoneClass extends FLClasses {
    createNew() {
      var toBeReturned;
      toBeReturned = super.createNew(FLDone);
      toBeReturned.value = null;
      return toBeReturned;
    }

  };

  FLDone = new FLDoneClass();

  FLPauseClass = class FLPauseClass extends FLClasses {
    createNew() {
      var toBeReturned;
      toBeReturned = super.createNew(FLPause);
      toBeReturned.value = null;
      return toBeReturned;
    }

  };

  FLPause = new FLPauseClass();

  FLBreakClass = class FLBreakClass extends FLClasses {
    createNew() {
      return super.createNew(FLBreak);
    }

  };

  FLBreak = new FLBreakClass();

  FLReturnClass = class FLReturnClass extends FLClasses {
    createNew() {
      var toBeReturned;
      toBeReturned = super.createNew(FLReturn);
      toBeReturned.value = null;
      return toBeReturned;
    }

  };

  FLReturn = new FLReturnClass();

  FLAccessUpperContextClass = class FLAccessUpperContextClass extends FLClasses {
    createNew() {
      return super.createNew(FLAccessUpperContext);
    }

  };

  FLAccessUpperContext = new FLAccessUpperContextClass();

  FLForeverClass = class FLForeverClass extends FLClasses {
    createNew() {
      return super.createNew(FLForever);
    }

  };

  FLForever = new FLForeverClass();

  // a class that prints explicitly the "eval"s and the
  // invocations of the empty method,
  // so one can see more explicitly what happens.
  FLEvaluationsCounterClass = class FLEvaluationsCounterClass extends FLClasses {
    createNew() {
      return super.createNew(FLEvaluationsCounter);
    }

  };

  FLEvaluationsCounter = new FLEvaluationsCounterClass();

  FLNumberClass = class FLNumberClass extends FLClasses {
    createNew(value) {
      var toBeReturned;
      toBeReturned = super.createNew(FLNumber);
      toBeReturned.value = parseFloat(value + "");
      toBeReturned.flToString = function() {
        return this.value;
      };
      return toBeReturned;
    }

  };

  FLNumber = new FLNumberClass();

  FLUnaryMinusClass = class FLUnaryMinusClass extends FLClasses {
    createNew() {
      var toBeReturned;
      toBeReturned = super.createNew(FLUnaryMinus);
      toBeReturned.value = "-";
      return toBeReturned;
    }

  };

  FLUnaryMinus = new FLUnaryMinusClass();

  FLNilClass = class FLNilClass extends FLClasses {
    createNew() {
      var toBeReturned;
      toBeReturned = super.createNew(FLNil);
      toBeReturned.flToString = function() {
        return "nil";
      };
      return toBeReturned;
    }

  };

  FLNil = new FLNilClass();

  FLStringClass = class FLStringClass extends FLClasses {
    createNew(value) {
      var toBeReturned;
      toBeReturned = super.createNew(FLString);
      toBeReturned.value = value + "";
      toBeReturned.flToString = function() {
        return this.value;
      };
      toBeReturned.flToStringForList = function() {
        return '"' + this.value + '"';
      };
      return toBeReturned;
    }

  };

  FLString = new FLStringClass();

  FLWorkspaceClass = class FLWorkspaceClass extends FLClasses {
    createNew() {
      return super.createNew(FLWorkspace);
    }

  };

  FLWorkspace = new FLWorkspaceClass(); // this is a class

  FLConsoleClass = class FLConsoleClass extends FLClasses {
    createNew() {
      return super.createNew(FLConsole);
    }

  };

  FLConsole = new FLConsoleClass();

  FLTurtleClass = class FLTurtleClass extends FLClasses {
    createNew() {
      var toBeReturned;
      toBeReturned = super.createNew(FLTurtle);
      toBeReturned.penDown = true;
      toBeReturned.direction = 0;
      toBeReturned.x = 0;
      toBeReturned.y = 0;
      toBeReturned.sendHome = function() {
        if (typeof canvasOutputElement !== "undefined" && canvasOutputElement !== null) {
          this.x = canvasOutputElement.clientWidth / 2;
          this.y = canvasOutputElement.clientHeight / 2;
        }
        return this.direction = 0;
      };
      return toBeReturned;
    }

  };

  FLTurtle = new FLTurtleClass();

  // Overall comments -------------------------------------------

  // ----
  // in the "for" and in the "repeat" and in all the branches in the if-then-else,
  // the loopCode/branch is passed as UNevaluated.
  // This is because if it were passed as evaluated, it'd have to be passed as
  //   repeat 3 'code
  // which would turn it into a closure.
  // Since out closures are read-only, that usually creates chaos, because
  // you are very likely to reference several variables from outside the
  // loop, and "closing" those as read only is problematic for example
  // this never ends, because the "a" inside the branch "a=a minus 1" is
  // replaced with a 5 when closed, so it never decreases to zero!

  //  a=5

  //  repeat forever:
  //  ﹍if a==0:
  //  ﹍﹍done
  //  ﹍else:
  //  ﹍﹍a=a minus 1
  //  console print a

  // On the other hand, in "to" and "answer", the code block is passed as
  // evaluated so it's actually closed (in read-only mode). This is
  // because in those cases one is less prone towards changing variables
  // from the outer scope. You can read them, but you can't write them.

  // ---
  // For the precedence, we use the same numbers as here
  // https://en.wikipedia.org/wiki/Order_of_operations
  // (plus the the power operator which has precedence 1)
  commonSimpleValueEqualityFunction = function(context) {
    var toCompare;
    //yield
    toCompare = context.lookupTemp("toCompare");
    if (this.value === toCompare.value) {
      return FLBoolean.createNew(true);
    } else {
      return FLBoolean.createNew(false);
    }
  };

  commonSimpleValueInequalityFunction = function(context) {
    var toCompare;
    //yield
    toCompare = context.lookupTemp("toCompare");
    if (this.value !== toCompare.value) {
      return FLBoolean.createNew(true);
    } else {
      return FLBoolean.createNew(false);
    }
  };

  // helper to add default methods -------------------------------------------
  addDefaultMethods = function(classToAddThemTo) {
    var commonPropertyAccessFunction, commonPropertyAssignmentFunction;
    classToAddThemTo.addMethod(flTokenize("isPrimitiveType"), flTokenize("if (self.class == Class) or (self.class == String) or (self.class == Number) or (self.class == List) or (self.class == Boolean):\n﹍return true\nelse:\n﹍return false"));
    classToAddThemTo.addMethod(flTokenize("postfixPrint"), function(context) {
      //yield
      if (methodsExecutionDebug) {
        log("///////// program printout: " + this.flToString());
      }
      rWorkspace.environmentPrintout += this.flToString();
      return this;
    });
    classToAddThemTo.addMethod(flTokenize("toString"), function(context) {
      //yield
      return FLString.createNew(this.flToString());
    });
    classToAddThemTo.addMethod(flTokenize("whenNew"), function(context) {
      //yield
      return this;
    });
    classToAddThemTo.addMethod(flTokenize("eval"), function(context) {
      var base, base1, newContext, toBeReturned;
      context.isTransparent = true;
      if (methodsExecutionDebug) {
        log("context now tramsparent at depth: " + context.depth() + " with self: " + (typeof (base = context.self).flToString === "function" ? base.flToString() : void 0));
      }
      newContext = new FLContext(context);
      newContext.isTransparent = true;
      if (methodsExecutionDebug) {
        log("newContext now tramsparent at depth: " + newContext.depth() + " with self: " + (typeof (base1 = newContext.self).flToString === "function" ? base1.flToString() : void 0));
      }
      //flContexts.jsArrayPush newContext
      // yield from
      toBeReturned = this.eval(newContext, this);
      //flContexts.pop()
      return toBeReturned;
    });
    // this is the common object identity function
    // strings, numbers and booleans override this
    // by just comparing the values.
    classToAddThemTo.addMethod(flTokenize("== ( toCompare )"), function(context) {
      var toCompare;
      //yield
      toCompare = context.lookupTemp("toCompare");
      if (this === toCompare) {
        return FLBoolean.createNew(true);
      } else {
        return FLBoolean.createNew(false);
      }
    }, 7);
    // this is the common object identity function
    // strings, numbers and booleans override this
    // by just comparing the values.
    classToAddThemTo.addMethod(flTokenize("!= ( toCompare )"), function(context) {
      var toCompare;
      //yield
      toCompare = context.lookupTemp("toCompare");
      if (this !== toCompare) {
        return FLBoolean.createNew(true);
      } else {
        return FLBoolean.createNew(false);
      }
    }, 7);
    classToAddThemTo.addMethod(flTokenize("else if ( predicate ): ('trueBranch)"), function(context) {
      //yield
      return this;
    });
    classToAddThemTo.addMethod(flTokenize("else: ('trueBranch)"), function(context) {
      //yield
      return this;
    });
    classToAddThemTo.addMethod(flTokenize("catch all : ( ' errorHandle )"), function(context) {
      //yield
      return this;
    });
    classToAddThemTo.addMethod(flTokenize("catch ( 'theError ) : ( ' errorHandle )"), function(context) {
      //yield
      return this;
    });
    commonPropertyAssignmentFunction = function(context) {
      var base, value, variable;
      //yield
      context.isTransparent = true;
      if (methodsExecutionDebug) {
        log("context now tramsparent at depth: " + context.depth() + " with self: " + (typeof (base = context.self).flToString === "function" ? base.flToString() : void 0));
      }
      variable = context.lookupTemp("variable");
      value = context.lookupTemp("value");
      this.instanceVariablesDict[ValidIDfromString(variable.value)] = value;
      return this;
    };
    commonPropertyAccessFunction = function(context) {
      var base, objectsBeingChecked, variable;
      //yield
      context.isTransparent = true;
      if (methodsExecutionDebug) {
        log("context now tramsparent at depth: " + context.depth() + " with self: " + (typeof (base = context.self).flToString === "function" ? base.flToString() : void 0));
      }
      variable = context.lookupTemp("variable");
      if (methodsExecutionDebug) {
        log(". ('variable) : checking instance variables");
      }
      // somewhat similar to Javascript, the lookup starts at the object
      // and climbs up to its class.
      objectsBeingChecked = this;
      while (true) {
        if (objectsBeingChecked.instanceVariablesDict[ValidIDfromString(variable.value)] != null) {
          if (methodsExecutionDebug) {
            log("yes it's an instance variable: ");
          }
          //dir objectsBeingChecked.instanceVariablesDict[ValidIDfromString variable.value]
          context.justDidAFieldOrArrayAccess = true;
          return objectsBeingChecked.instanceVariablesDict[ValidIDfromString(variable.value)];
        }
        if (objectsBeingChecked === objectsBeingChecked.flClass) {
          break;
        } else {
          objectsBeingChecked = objectsBeingChecked.flClass;
        }
      }
      return FLNil.createNew();
    };
    classToAddThemTo.addMethod(flTokenize(". ('variable) = (value)"), commonPropertyAssignmentFunction);
    classToAddThemTo.addMethod(flTokenize(". ('variable) ← (value)"), commonPropertyAssignmentFunction);
    classToAddThemTo.addMethod(flTokenize(". evaluating (variable)"), commonPropertyAccessFunction);
    classToAddThemTo.addMethod(flTokenize(". ('variable) += (value)"), function(context) {
      var runThis, toBeReturned, value, variable;
      // this is a token
      variable = context.lookupTemp("variable");
      value = context.lookupTemp("value");
      runThis = flTokenize("(self . evaluating variable) += value");
      // yield from
      toBeReturned = runThis.eval(context, runThis);
      this.instanceVariablesDict[ValidIDfromString(variable.value)] = toBeReturned;
      return toBeReturned;
    });
    classToAddThemTo.addMethod(flTokenize(". ('variable) *= (value)"), function(context) {
      var runThis, toBeReturned, value, variable;
      // this is a token
      variable = context.lookupTemp("variable");
      value = context.lookupTemp("value");
      runThis = flTokenize("(self . evaluating variable) *= value");
      // yield from
      toBeReturned = runThis.eval(context, runThis);
      this.instanceVariablesDict[ValidIDfromString(variable.value)] = toBeReturned;
      return toBeReturned;
    });
    classToAddThemTo.addMethod(flTokenize(". ('variable) ++"), function(context) {
      var runThis, toBeReturned, variable;
      // this is a token
      variable = context.lookupTemp("variable");
      runThis = flTokenize("(self . evaluating variable) ++");
      // yield from
      toBeReturned = runThis.eval(context, runThis);
      this.instanceVariablesDict[ValidIDfromString(variable.value)] = toBeReturned;
      return toBeReturned;
    });
    classToAddThemTo.addMethod(flTokenize(". ('variable)"), commonPropertyAccessFunction);
    // we DON't want the signature to be "closed", so we use
    //  (flTokenize "answer : ( 'signature ) by ( methodBody )"),
    // however then we need another variant of "answer" called "answerEvalSignatureAndBody"
    // that can take an evaluated parameter, because the implementation for
    // "to" needs it.

    // Note that you can call "answer" on both a Class or on any instance
    // of any class. In the second case, you'll still have to add the method
    // to the class, not to the instance.
    classToAddThemTo.addMethod(flTokenize("answer: ( 'signature ) by: ( 'methodBody )"), function(context) {
      var methodBody, signature;
      //yield
      signature = context.lookupTemp("signature");
      methodBody = context.lookupTemp("methodBody");
      if (this.isClass()) {
        this.addMethod(signature, methodBody);
      } else {
        this.flClass.addMethod(signature, methodBody);
      }
      return this;
    });
    classToAddThemTo.addMethod(flTokenize("answerEvalSignatureAndBody ( signature ) by ( methodBody )"), function(context) {
      var methodBody, signature;
      //yield
      signature = context.lookupTemp("signature");
      methodBody = context.lookupTemp("methodBody");
      log("answer: giving the method body a definitionContext!");
      methodBody.definitionContext = context.previousContext;
      methodBody.giveDefinitionContextToElements(context.previousContext);
      if (this.isClass()) {
        this.addMethod(signature, methodBody);
      } else {
        this.flClass.addMethod(signature, methodBody);
      }
      return this;
    });
    classToAddThemTo.addMethod(flTokenize("answer with priority (priority) : ( 'signature ) by: ( 'methodBody )"), function(context) {
      var methodBody, priority, signature;
      //yield
      signature = context.lookupTemp("signature");
      methodBody = context.lookupTemp("methodBody");
      priority = context.lookupTemp("priority");
      if (this.isClass()) {
        this.addMethod(signature, methodBody, priority.value);
      } else {
        this.flClass.addMethod(signature, methodBody, priority.value);
      }
      return this;
    });
    return classToAddThemTo.addMethod(flTokenize("answer with priority (priority) associativeRightToLeft: ( 'signature ) by: ( 'methodBody )"), function(context) {
      var methodBody, priority, signature;
      //yield
      signature = context.lookupTemp("signature");
      methodBody = context.lookupTemp("methodBody");
      priority = context.lookupTemp("priority");
      if (this.isClass()) {
        this.addMethod(signature, methodBody, priority.value, ASSOCIATIVITY_RIGHT_TO_LEFT);
      } else {
        this.flClass.addMethod(signature, methodBody, priority.value, ASSOCIATIVITY_RIGHT_TO_LEFT);
      }
      return this;
    });
  };

  // with time, allClasses contains all the classes
  // (boot classes and user-defined classes), but right
  // now only the boot classes (i.e. primitive classes +
  // helper classes such as FLForClass, etc.) have been defined
  // We call this set the "bootClasses"
  bootClasses = allClasses.slice();

  clearClasses = function() {
    var eachClass, j, len;
// user might have modified some methods in the boot
// classes.
    for (j = 0, len = bootClasses.length; j < len; j++) {
      eachClass = bootClasses[j];
      eachClass.resetInstanceVariables();
      eachClass.resetMethods();
    }
    return allClasses = [];
  };

  initBootClasses = function() {
    var BaseDivideFunction, BaseFloorDivisionFunction, BaseMinusFunction, BaseMultiplyFunction, BasePercentFunction, BasePlusFunction, BasePowerFunction, commonClassCreationFunction, eachClass, j, len, pauseFunctionContinuation;
// Common to all -------------------------------------------------------------------
// first, add the methods common to them all
// then we'll proceed to add the class-specific classes
    for (j = 0, len = bootClasses.length; j < len; j++) {
      eachClass = bootClasses[j];
      addDefaultMethods(eachClass);
    }
    // WorkSpace -----------------------------------------------------------------------

    // Token ---------------------------------------------------------------------------
    FLToken.addMethod(flTokenize("← ( valueToAssign )"), function(context, definitionContext) {
      var assigneeTokenString, base, valueToAssign;
      //yield
      valueToAssign = context.lookupTemp("valueToAssign");
      assigneeTokenString = this.value;
      if (methodsExecutionDebug) {
        log("evaluation " + indentation() + "assignment to token " + assigneeTokenString);
        log("evaluation " + indentation() + "value to assign to token: " + assigneeTokenString + " : " + valueToAssign.value);
        log("context now tramsparent at depth: " + context.depth() + " with self: " + (typeof (base = context.self).flToString === "function" ? base.flToString() : void 0));
      }
      context.isTransparent = true;
      this.assignValue(context, definitionContext, valueToAssign);
      context.isTransparent = false;
      return valueToAssign;
    });
    FLToken.addMethod(flTokenize("= ( valueToAssign )"), function(context, definitionContext) {
      var assigneeTokenString, base, valueToAssign;
      //yield
      valueToAssign = context.lookupTemp("valueToAssign");
      assigneeTokenString = this.value;
      if (methodsExecutionDebug) {
        log("evaluation " + indentation() + "assignment to token " + assigneeTokenString);
        log("evaluation " + indentation() + "value to assign to token: " + assigneeTokenString + " : " + valueToAssign.value);
        log("context now tramsparent at depth: " + context.depth() + " with self: " + (typeof (base = context.self).flToString === "function" ? base.flToString() : void 0));
      }
      context.isTransparent = true;
      this.assignValue(context, definitionContext, valueToAssign);
      context.isTransparent = false;
      return valueToAssign;
    });
    commonClassCreationFunction = function(context, definitionContext, assigneeToken, className) {
      var base, valueToAssign;
      //yield
      valueToAssign = FLClass.createNew(className);
      if (methodsExecutionDebug) {
        log("evaluation " + indentation() + "assignment to token " + assigneeToken.value);
        log("evaluation " + indentation() + "value to assign to token: " + assigneeToken.value + " : " + valueToAssign.value);
        log("context now tramsparent at depth: " + context.depth() + " with self: " + (typeof (base = context.self).flToString === "function" ? base.flToString() : void 0));
      }
      context.isTransparent = true;
      assigneeToken.assignValue(context, definitionContext, valueToAssign);
      return valueToAssign;
    };
    FLToken.addMethod(flTokenize("= Class new"), function(context, definitionContext) {
      var toBeReturned;
      // yield from
      toBeReturned = commonClassCreationFunction(context, definitionContext, this, this.value);
      return toBeReturned;
    });
    FLToken.addMethod(flTokenize("= Class new named (theName)"), function(context, definitionContext) {
      var theName, toBeReturned;
      theName = context.lookupTemp("theName");
      // yield from
      toBeReturned = commonClassCreationFunction(context, definitionContext, this, theName.value);
      return toBeReturned;
    });
    FLToken.addMethod(flTokenize("+= ( operandum )"), flTokenize("self ← self eval + operandum"));
    FLToken.addMethod(flTokenize("*= ( operandum )"), flTokenize("self ← self eval * operandum"));
    FLToken.addMethod(flTokenize("++"), flTokenize("self ← self eval + 1"));
    // Nil ---------------------------------------------------------------------------
    FLNil.addMethod(flTokenize("== ( toCompare )"), function(context) {
      var toCompare;
      //yield
      toCompare = context.lookupTemp("toCompare");
      if (toCompare.flClass === FLNil) {
        return FLBoolean.createNew(true);
      } else {
        return FLBoolean.createNew(false);
      }
    }, 7);
    // In ---------------------------------------------------------------------------
    FLIn.addMethod(flTokenize("(object) do ('code)"), function(context) {
      var code, newContext, object, toBeReturned;
      object = context.lookupTemp("object");
      code = context.lookupTemp("code");
      newContext = new FLContext(context, object);
      // yield from
      toBeReturned = code.eval(newContext, code);
      return toBeReturned;
    });
    // To -------------------------------------------------------------------------

    // TODO it'd be nice if there was a way not to leak the TempClass
    // Note 1----
    // we DON't want the signature to be "closed", so we use
    //  (flTokenize "( ' functionObjectName ) : ( 'signature ) do: ( 'functionBody )"),
    // however at that point we also had to adjust the signature in
    // "answer" otherwise you
    // have a discrepancy, and "answer" needs an additional version
    // that evaluates the signature because it needs
    // a version where the signature is evalled exactly to implement the "to"
    // here below.

    // Note 2----
    // the "functionObjectName" is not evalled to keep definitions more logo-like
    // otherwise if you want to eval it you need to have it on its own line
    // otherwise its evaluation might eat up the signature definition that
    // follows it.
    // The drawback is that you can't conditionally name a functionObjectName
    // but that's not that common in other languages either.
    // functionObjectName contains a token i.e.
    // it's a pointer. So to put something inside the
    // variable *it's pointing at*,
    // you need to do "functionObjectName eval"

    // we take the "if" when the token is completely new, or if it's
    // a string or a number for example, because it's clear that we don't
    // want to add new methods to String or Number using "to" in
    // that way. So we create a temp class and put a single instance
    // of such class in the token.

    // we skip the "if" when the token is bound to anything else other than
    // a primitive type. In that case we just add/replace the
    // method to whatever the token is bound to
    FLTo.addMethod(flTokenize("( ' functionObjectName ) : ( 'signature ) do: ( 'functionBody )"), flTokenize("accessUpperContext\nif (nil == functionObjectName eval) or (functionObjectName eval isPrimitiveType):\n﹍'TempClass ← Class new\n﹍TempClass nameit \"Class_of_\" + functionObjectName\n﹍functionObjectName ← TempClass new\n﹍TempClass answerEvalSignatureAndBody (signature) by (functionBody)\nfunctionObjectName eval answerEvalSignatureAndBody (signature) by (functionBody)"));
    // TODO it'd be nice if there was a way not to leak the TempClass
    // see comments in method definition above
    FLTo.addMethod(flTokenize("( ' functionObjectName ) : ( 'functionBody )"), flTokenize("accessUpperContext\nif (nil == functionObjectName eval) or (functionObjectName eval isPrimitiveType):\n﹍'TempClass ← Class new\n﹍TempClass nameit \"Class_of_\" + functionObjectName\n﹍functionObjectName ← TempClass new\nfunctionObjectName eval answerEvalSignatureAndBody: () by (functionBody)"));
    // Class -------------------------------------------------------------------------

    // Class. Like all classes, it's also an object, but it's the only object
    // in the system that has the capacity to create
    // new classes, via the "new" message below.
    FLClass.addMethod(flTokenize("new"), function(context) {
      //yield
      if (methodsExecutionDebug) {
        log("///////// creating a new class for the user!");
      }
      return this.createNew();
    });
    // Exception -------------------------------------------------------------------------
    FLException.addMethod(flTokenize("new"), function(context) {
      //yield
      return this.createNew("");
    });
    FLException.addMethod(flTokenize("initWith ( errorMessage )"), function(context) {
      var errorMessage;
      //yield
      errorMessage = context.lookupTemp("errorMessage");
      this.value = errorMessage.value;
      return this;
    });
    FLException.addMethod(flTokenize("catch all : ( ' errorHandle )"), function(context) {
      var errorHandle, toBeReturned;
      errorHandle = context.lookupTemp("errorHandle");
      if (methodsExecutionDebug) {
        log("catch: being thrown? " + context.throwing);
        log("catch: got right exception, catching it");
      }
      if (this.thrown) {
        // yield from
        toBeReturned = errorHandle.eval(context, errorHandle);
      } else {
        toBeReturned = this;
      }
      return toBeReturned;
    });
    // theError here is a token!
    FLException.addMethod(flTokenize("catch ( 'theError ) : ( ' errorHandle )"), function(context) {
      var errorHandle, theError, toBeReturned;
      //yield
      theError = context.lookupTemp("theError");
      errorHandle = context.lookupTemp("errorHandle");
      // OK this is tricky: we'd normally just evaluate this from the
      // signature BUT we can't, because it's going to be in this form:
      // WITHOUT parens
      //    catch someError :
      // so it's going to try to match the ":" token, and
      // whenever an exception touches
      // anything else other than a catch, it ALWAYS matches and
      // re-throws itself, because this
      // is how we get exceptions to bubble up when they are not
      // caught. So, we get the token instead, and we look it up
      // here.
      // theError here is a token, with this evaluation we get an
      // actual exception.
      // yield from
      theError = theError.eval(context, theError);
      if (methodsExecutionDebug) {
        log("catch: same as one to catch?" + (this === theError) + " being thrown? " + context.throwing);
      }
      if (this === theError) {
        if (methodsExecutionDebug) {
          log("catch: got right exception, catching it");
        }
        if (this.thrown) {
          // yield from
          toBeReturned = errorHandle.eval(context, errorHandle);
        } else {
          toBeReturned = this;
        }
      } else {
        if (methodsExecutionDebug) {
          log("catch: got wrong exception, propagating it");
        }
        toBeReturned = this;
      }
      return toBeReturned;
    });
    FLException.addMethod(FLList.emptyMessage(), function(context) {
      //yield
      if (this.thrown) {
        context.throwing = true;
      }
      return this;
    });
    // String -------------------------------------------------------------------------
    FLString.addMethod(flTokenize("new"), function(context) {
      //yield
      return this.createNew("");
    });
    FLString.addMethod(flTokenize("+ ( stringToBeAppended )"), function(context) {
      var stringToBeAppended;
      //yield
      stringToBeAppended = context.lookupTemp("stringToBeAppended");
      return FLString.createNew(this.value + stringToBeAppended.flToString());
    }, 4);
    FLString.addMethod(flTokenize("== ( toCompare )"), commonSimpleValueEqualityFunction, 7);
    FLString.addMethod(flTokenize("!= ( toCompare )"), commonSimpleValueInequalityFunction, 7);
    // Number -------------------------------------------------------------------------
    FLNumber.addMethod(flTokenize("new"), function(context) {
      //yield
      return this.createNew(0);
    });
    FLNumber.addMethod(flTokenize("anotherPrint"), flTokenize("console print self"));
    FLNumber.addMethod(flTokenize("doublePrint"), flTokenize("console print(console print self)"));
    // mutates the very object
    // this one below actually mutates the number
    // object
    FLNumber.addMethod(flTokenize("incrementInPlace"), flTokenize("self ← self + 1"));
    FLNumber.addMethod(flTokenize("factorialtwo"), flTokenize("if self == 0: ( 1 ) else: (self * ( ( self minus 1 ) factorialtwo ))"));
    FLNumber.addMethod(flTokenize("factorialthree"), flTokenize("if self == 0: ( 1 ) else: ('temp ← self;console print temp; ( self minus 1 ) factorialthree * temp )"));
    FLNumber.addMethod(flTokenize("factorialfour"), flTokenize("if self == 0: ( 1 ) else: ('temp ← self;( self minus 1 ) factorialfour * temp )"));
    FLNumber.addMethod(flTokenize("factorialfive"), flTokenize("if self == 0: ( 1 ) else: (1 + 1;'temp ← self;( self minus 1 ) factorialfive * temp )"));
    FLNumber.addMethod(flTokenize("factorialsix"), flTokenize("if self == 0: ( 1 ) else: (( self minus 1 ) factorialsix * self)"));
    FLNumber.addMethod(flTokenize("amIZero"), flTokenize("self == 0"));
    FLNumber.addMethod(flTokenize("printAFromDeeperCall"), flTokenize("console print a"));
    // generates a range list including the extremes
    // e.g. 1...1 is (1), 1...0 is (1 0), 1...2 is (1 2)

    // hs higher priority NUMBER (i.e. lower precedence)
    // than +,-,*,/ so things like this can work:

    //   for each number in:
    //     numParams-1...0

    FLNumber.addMethod(flTokenize("...(endRange)"), function(context) {
      var endRange, i, l, listToBeReturned, ref, ref1;
      //yield
      endRange = context.lookupTemp("endRange");
      listToBeReturned = FLList.createNew();
      for (i = l = ref = this.value, ref1 = endRange.value; (ref <= ref1 ? l <= ref1 : l >= ref1); i = ref <= ref1 ? ++l : --l) {
        listToBeReturned.value.jsArrayPush(FLNumber.createNew(i));
        listToBeReturned.cursorEnd++;
      }
      return listToBeReturned;
    }, 5);
    // ---
    BasePlusFunction = function(context) {
      var operandum;
      //yield
      operandum = context.lookupTemp("operandum");
      // todo more type conversions needed, and also in the other operations
      if (operandum.flClass === FLString) {
        return FLString.createNew(this.value + operandum.value);
      } else {
        return FLNumber.createNew(this.value + operandum.value);
      }
    };
    FLNumber.addMethod(flTokenize("$plus_binary_default ( operandum )"), BasePlusFunction);
    BasePowerFunction = function(context) {
      var operandum;
      //yield
      operandum = context.lookupTemp("operandum");
      return FLNumber.createNew(Math.pow(this.value, operandum.value));
    };
    FLNumber.addMethod(flTokenize("$power_binary_default ( operandum )"), BasePowerFunction);
    FLNumber.addMethod(flTokenize("+ ( operandum )"), flTokenize("self $plus_binary_default operandum"), 4);
    // for power operator precedence discussions see
    // https://esdiscuss.org/topic/exponentiation-operator-precedence
    // Also, you can check Wolfram Alpha for what the
    // mathematically-accurate results should be
    FLNumber.addMethod(flTokenize("^ ( operandum )"), flTokenize("self $power_binary_default operandum"), 1, ASSOCIATIVITY_RIGHT_TO_LEFT);
    FLNumber.addMethod(flTokenize("^ - ( operandum )"), flTokenize("self $power_binary_default ( - operandum )"), 1, ASSOCIATIVITY_RIGHT_TO_LEFT);
    // although there are some good reasons to have this,
    // it can get confusing, consider for example
    // a++ ++
    // the first ++ does this: a = a+1 and returns a number
    // the second just increments the number without modifying
    // a.
    FLNumber.addMethod(flTokenize("++"), flTokenize("self + 1"));
    // see "++" regarding why this could be confusing
    FLNumber.addMethod(flTokenize("+= (value)"), flTokenize("self + value"));
    // ---
    BasePercentFunction = function(context) {
      var operandum;
      //yield
      operandum = context.lookupTemp("operandum");
      return FLNumber.createNew(this.value % operandum.value);
    };
    FLNumber.addMethod(flTokenize("$percent_binary_default ( operandum )"), BasePercentFunction);
    FLNumber.addMethod(flTokenize("% ( operandum )"), flTokenize("self $percent_binary_default operandum"), 3);
    // ---
    BaseFloorDivisionFunction = function(context) {
      var operandum;
      //yield
      operandum = context.lookupTemp("operandum");
      return FLNumber.createNew(Math.floor(this.value / operandum.value));
    };
    FLNumber.addMethod(flTokenize("$floordivision_binary_default ( operandum )"), BaseFloorDivisionFunction);
    FLNumber.addMethod(flTokenize("/_ ( operandum )"), flTokenize("self $floordivision_binary_default operandum"), 3);
    // ---
    BaseMinusFunction = function(context) {
      var operandum;
      //yield
      operandum = context.lookupTemp("operandum");
      return FLNumber.createNew(this.value - operandum.value);
    };
    FLNumber.addMethod(flTokenize("$minus_binary_default ( operandum )"), BaseMinusFunction);
    FLNumber.addMethod(flTokenize("- ( operandum )"), flTokenize("self $minus_binary_default operandum"), 4);
    // ---
    BaseDivideFunction = function(context) {
      var operandum;
      //yield
      operandum = context.lookupTemp("operandum");
      return FLNumber.createNew(this.value / operandum.value);
    };
    FLNumber.addMethod(flTokenize("$divide_binary_default ( operandum )"), BaseDivideFunction);
    FLNumber.addMethod(flTokenize("/ ( operandum )"), flTokenize("self $divide_binary_default operandum"), 3);
    // ---
    BaseMultiplyFunction = function(context) {
      var operandum;
      //yield
      operandum = context.lookupTemp("operandum");
      return FLNumber.createNew(this.value * operandum.value);
    };
    FLNumber.addMethod(flTokenize("$multiply_binary_default ( operandum )"), BaseMultiplyFunction);
    FLNumber.addMethod(flTokenize("* ( operandum )"), flTokenize("self $multiply_binary_default operandum"), 3);
    // see "++" regarding why this could be confusing
    FLNumber.addMethod(flTokenize("*= (value)"), flTokenize("self * value"));
    // ---
    FLNumber.addMethod(flTokenize("minus ( operandum )"), function(context) {
      var operandum;
      //yield
      operandum = context.lookupTemp("operandum");
      return FLNumber.createNew(this.value - operandum.value);
    });
    FLNumber.addMethod(flTokenize("selftimesminusone"), flTokenize("self * self minus 1"));
    FLNumber.addMethod(flTokenize("times ( ' loopCode )"), function(context) {
      var i, l, loopCode, ref, toBeReturned;
      loopCode = context.lookupTemp("loopCode");
      if (methodsExecutionDebug) {
        log("FLNumber: times loop code is: " + loopCode.flToString());
      }
      for (i = l = 0, ref = this.value; (0 <= ref ? l < ref : l > ref); i = 0 <= ref ? ++l : --l) {
        // yield from
        toBeReturned = loopCode.eval(context, loopCode);
        //flContexts.pop()

        // catch any thrown "done" object, used to
        // exit from a loop.
        if (toBeReturned != null) {
          if (context.throwing && (toBeReturned.flClass === FLDone || toBeReturned.flClass === FLBreak)) {
            context.throwing = false;
            if (toBeReturned.value != null) {
              toBeReturned = toBeReturned.value;
            }
            if (methodsExecutionDebug) {
              log("times loop exited with Done ");
            }
            break;
          }
          if (context.throwing && toBeReturned.flClass === FLReturn) {
            if (methodsExecutionDebug) {
              log("times loop exited with Return ");
            }
            break;
          }
        }
      }
      return toBeReturned;
    });
    FLNumber.addMethod(flTokenize("== ( toCompare )"), commonSimpleValueEqualityFunction, 7);
    FLNumber.addMethod(flTokenize("!= ( toCompare )"), commonSimpleValueInequalityFunction, 7);
    FLNumber.addMethod(flTokenize("< ( toCompare )"), function(context) {
      var toCompare;
      //yield
      toCompare = context.lookupTemp("toCompare");
      if (this.value < toCompare.value) {
        return FLBoolean.createNew(true);
      } else {
        return FLBoolean.createNew(false);
      }
    }, 6);
    FLNumber.addMethod(flTokenize("> ( toCompare )"), function(context) {
      var toCompare;
      //yield
      toCompare = context.lookupTemp("toCompare");
      if (this.value > toCompare.value) {
        return FLBoolean.createNew(true);
      } else {
        return FLBoolean.createNew(false);
      }
    }, 6);
    // mutating the number
    FLNumber.addMethod(flTokenize("← ( valueToAssign )"), function(context) {
      var valueToAssign;
      //yield
      if (methodsExecutionDebug) {
        log("evaluation " + indentation() + "assigning to number! ");
      }
      valueToAssign = context.lookupTemp("valueToAssign");
      this.value = valueToAssign.value;
      return this;
    });
    // Boolean -------------------------------------------------------------------------
    FLBoolean.addMethod(flTokenize("negate"), function(context) {
      //yield
      return FLBoolean.createNew(!this.value);
    });
    FLBoolean.addMethod(flTokenize("and ( operandum )"), function(context) {
      var operandum;
      //yield
      operandum = context.lookupTemp("operandum");
      return FLBoolean.createNew(this.value && operandum.value);
    }, 11);
    FLBoolean.addMethod(flTokenize("or ( operandum )"), function(context) {
      var operandum;
      //yield
      if (methodsExecutionDebug) {
        log("executing an or! ");
      }
      operandum = context.lookupTemp("operandum");
      return FLBoolean.createNew(this.value || operandum.value);
    }, 12);
    FLBoolean.addMethod(flTokenize("== ( toCompare )"), commonSimpleValueEqualityFunction, 7);
    FLBoolean.addMethod(flTokenize("!= ( toCompare )"), commonSimpleValueInequalityFunction, 7);
    // FLQuote --------------------------------------------------------------------------
    FLQuote.addMethod(flTokenize("( ' operandum )"), function(context) {
      var operandum;
      //yield
      operandum = context.lookupTemp("operandum");
      if (operandum.flClass === FLList) {
        log("list quote, giving it a definitionContext!");
        operandum.definitionContext = context.previousContext;
        operandum.giveDefinitionContextToElements(context.previousContext);
      }
      return operandum;
    });
    // Not --------------------------------------------------------------------------
    FLNot.addMethod(flTokenize("( operandum )"), flTokenize("operandum negate"), 2, ASSOCIATIVITY_RIGHT_TO_LEFT);
    // UnaryMinus --------------------------------------------------------------------------
    FLUnaryMinus.addMethod(flTokenize("( operandum )"), flTokenize("0 - operandum"), 2, ASSOCIATIVITY_RIGHT_TO_LEFT);
    // ListLiteralArrayNotationStarter -------------------------------------------------------------------------
    FLListLiteralArrayNotationStarter.addMethod(flTokenize("]"), function(context) {
      //yield
      // returns a List, not an ListLiteralArrayNotation
      return FLList.createNew();
    });
    FLListLiteralArrayNotationStarter.addMethod(flTokenize("( elementToBeAppended )"), function(context) {
      var elementToBeAppended, toBeReturned;
      //yield
      // returns an ListLiteralArrayNotation with the first element put in
      elementToBeAppended = context.lookupTemp("elementToBeAppended");
      toBeReturned = FLListLiteralArrayNotation.createNew();
      toBeReturned.value.mutablePush(elementToBeAppended);
      return toBeReturned;
    });
    // ListLiteralArrayNotation -------------------------------------------------------------------------
    FLListLiteralArrayNotation.addMethod(flTokenize("]"), function(context) {
      //yield
      // returns a List, not an ListLiteralArrayNotation
      return this.value;
    });
    FLListLiteralArrayNotation.addMethod(flTokenize(", ( elementToBeAppended )"), function(context) {
      var elementToBeAppended;
      //yield
      elementToBeAppended = context.lookupTemp("elementToBeAppended");
      this.value.mutablePush(elementToBeAppended);
      return this;
    });
    // List -------------------------------------------------------------------------
    FLList.addMethod(flTokenize("new"), function(context) {
      //yield
      return this.createNew();
    });
    FLList.addMethod(flTokenize("+ ( elementToBeAppended )"), function(context) {
      var elementToBeAppended;
      //yield
      elementToBeAppended = context.lookupTemp("elementToBeAppended");
      if (methodsExecutionDebug) {
        log("appending element to: " + this.flToString() + " : " + elementToBeAppended.toString());
      }
      return this.flListImmutablePush(elementToBeAppended);
    }, 4);
    FLList.addMethod(flTokenize("length"), function(context) {
      //yield
      return FLNumber.createNew(this.length());
    });
    FLList.addMethod(flTokenize("[ (indexValue) ] = (value)"), function(context) {
      var indexValue, value;
      //yield
      indexValue = context.lookupTemp("indexValue");
      value = context.lookupTemp("value");
      
      // -1 here is because arrays in Fizzylogo are 1-based
      return this.elementAtSetMutable(indexValue.value - 1, value);
    });
    FLList.addMethod(flTokenize("[ (indexValue) ] += (value)"), function(context) {
      var indexValue, runThis, toBeReturned, value;
      indexValue = context.lookupTemp("indexValue");
      value = context.lookupTemp("value");
      runThis = flTokenize("(self [indexValue]) += value");
      // yield from
      toBeReturned = runThis.eval(context, runThis);
      // -1 here is because arrays in Fizzylogo are 1-based
      this.elementAtSetMutable(indexValue.value - 1, toBeReturned);
      return toBeReturned;
    });
    FLList.addMethod(flTokenize("[ (indexValue) ] *= (value)"), function(context) {
      var indexValue, runThis, toBeReturned, value;
      indexValue = context.lookupTemp("indexValue");
      value = context.lookupTemp("value");
      runThis = flTokenize("(self [indexValue]) *= value");
      // yield from
      toBeReturned = runThis.eval(context, runThis);
      // -1 here is because arrays in Fizzylogo are 1-based
      this.elementAtSetMutable(indexValue.value - 1, toBeReturned);
      return toBeReturned;
    });
    FLList.addMethod(flTokenize("[ (indexValue) ] ++"), function(context) {
      var indexValue, runThis, toBeReturned;
      indexValue = context.lookupTemp("indexValue");
      runThis = flTokenize("(self [indexValue]) ++");
      // yield from
      toBeReturned = runThis.eval(context, runThis);
      // -1 here is because arrays in Fizzylogo are 1-based
      this.elementAtSetMutable(indexValue.value - 1, toBeReturned);
      return toBeReturned;
    });
    FLList.addMethod(flTokenize("[ (indexValue) ]"), function(context) {
      var indexValue;
      //yield
      indexValue = context.lookupTemp("indexValue");
      if (methodsExecutionDebug) {
        log("reading list element at index: " + indexValue.value);
      }
      context.justDidAFieldOrArrayAccess = true;
      // -1 here is because arrays in Fizzylogo are 1-based
      return this.elementAt(indexValue.value - 1);
    });
    FLList.addMethod(flTokenize("each ( ' variable ) do ( ' code )"), function(context) {
      var code, i, l, newContext, ref, toBeReturned, variable;
      variable = context.lookupTemp("variable");
      code = context.lookupTemp("code");
      if (methodsExecutionDebug) {
        log("FLList each do ");
      }
      newContext = new FLContext(context);
      for (i = l = 0, ref = this.value.length; (0 <= ref ? l < ref : l > ref); i = 0 <= ref ? ++l : --l) {
        newContext.tempVariablesDict[ValidIDfromString(variable.value)] = this.elementAt(i);
        // yield from
        toBeReturned = code.eval(newContext, code);
        // catch any thrown "done" object, used to
        // exit from a loop.
        if (toBeReturned != null) {
          if (context.throwing && (toBeReturned.flClass === FLDone || toBeReturned.flClass === FLBreak)) {
            context.throwing = false;
            if (toBeReturned.value != null) {
              toBeReturned = toBeReturned.value;
            }
            if (methodsExecutionDebug) {
              log("list-each-do loop exited with Done ");
            }
            break;
          }
          if (context.throwing && toBeReturned.flClass === FLReturn) {
            if (methodsExecutionDebug) {
              log("list-each-do loop exited with Return ");
            }
            break;
          }
        }
      }
      return toBeReturned;
    });
    // AccessUpperContextClass -------------------------------------------------------------------------
    FLAccessUpperContext.addMethod(FLList.emptyMessage(), function(context) {
      var base;
      //yield
      if (methodsExecutionDebug) {
        log("FLAccessUpperContext running emptyMessage");
        log("context.previousContext now tramsparent at depth: " + context.previousContext.depth() + " with self: " + (typeof (base = context.previousContext.self).flToString === "function" ? base.flToString() : void 0));
      }
      context.previousContext.isTransparent = true;
      return this;
    });
    // Console -----------------------------------------------------------------------------
    FLConsole.addMethod(flTokenize("print ( thingToPrint )"), function(context) {
      var stringToPrint, thingToPrint;
      //yield
      thingToPrint = context.lookupTemp("thingToPrint");
      stringToPrint = thingToPrint.flToString();
      if (methodsExecutionDebug) {
        log("///////// program printout: " + stringToPrint);
      }
      if (typeof textOutputElement !== "undefined" && textOutputElement !== null) {
        textOutputElement.value += stringToPrint;
      }
      rWorkspace.environmentPrintout += stringToPrint;
      return thingToPrint;
    });
    // Turtle -----------------------------------------------------------------------------
    FLTurtle.addMethod(flTokenize("home"), function(context) {
      //yield
      this.sendHome();
      return this;
    });
    FLTurtle.addMethod(flTokenize("forward ( distance )"), function(context) {
      var canvasContext, distance, radians;
      //yield
      distance = context.lookupTempValue("distance");
      if (typeof canvasOutputElement !== "undefined" && canvasOutputElement !== null) {
        canvasContext = canvasOutputElement.getContext("2d");
        canvasContext.strokeStyle = "#000";
        canvasContext.lineWidth = 1;
        radians = this.direction * Math.PI / 180.0;
        if (this.penDown) {
          canvasContext.beginPath();
          canvasContext.moveTo(this.x, this.y);
        }
        // new coords. The minus is because of
        // how HTML5 Canvas orients its y axis (points downwards)
        this.x += distance * Math.sin(radians);
        this.y -= distance * Math.cos(radians);
        if (this.penDown) {
          canvasContext.lineTo(this.x, this.y);
          canvasContext.stroke();
        }
      }
      return this;
    });
    FLTurtle.addMethod(flTokenize("right ( degrees )"), function(context) {
      var degrees;
      //yield
      degrees = context.lookupTempValue("degrees");
      this.direction += degrees;
      this.direction = this.direction % 360;
      return this;
    });
    FLTurtle.addMethod(flTokenize("left ( degrees )"), function(context) {
      var degrees;
      //yield
      degrees = context.lookupTempValue("degrees");
      this.direction += 360 - degrees;
      this.direction = this.direction % 360;
      return this;
    });
    // Done -------------------------------------------------------------------------
    FLDone.addMethod(flTokenize("with ( valueToReturn )"), function(context) {
      var valueToReturn;
      //yield
      valueToReturn = context.lookupTemp("valueToReturn");
      if (methodsExecutionDebug) {
        log("Done_object thrown with return value: " + valueToReturn.flToString());
      }
      this.value = valueToReturn;
      context.throwing = true;
      this.thrown = true;
      return this;
    });
    FLDone.addMethod(FLList.emptyMessage(), function(context) {
      //yield
      if (methodsExecutionDebug) {
        log("Done_object running emptyMessage");
      }
      context.throwing = true;
      this.thrown = true;
      return this;
    });
    // Break -------------------------------------------------------------------------
    FLBreak.addMethod(FLList.emptyMessage(), function(context) {
      //yield
      if (methodsExecutionDebug) {
        log("Break_object");
      }
      context.throwing = true;
      return this;
    });
    // Return -------------------------------------------------------------------------
    FLReturn.addMethod(flTokenize("( valueToReturn )"), function(context) {
      var valueToReturn;
      //yield
      valueToReturn = context.lookupTemp("valueToReturn");
      if (methodsExecutionDebug) {
        log("Return_object running a value");
      }
      this.value = valueToReturn;
      context.throwing = true;
      return this;
    });
    FLReturn.addMethod(FLList.emptyMessage(), function(context) {
      //yield
      if (methodsExecutionDebug) {
        log("Return_object running emptyMessage");
      }
      context.throwing = true;
      this.value = FLNil.createNew();
      return this;
    });
    // Repeat1 -------------------------------------------------------------------------
    FLRepeat1.addMethod(flTokenize("( ' loopCode )"), function(context) {
      var base, loopCode, toBeReturned;
      context.isTransparent = true;
      if (methodsExecutionDebug) {
        log("context now tramsparent at depth: " + context.depth() + " with self: " + (typeof (base = context.self).flToString === "function" ? base.flToString() : void 0));
        log("FLRepeat1 ⇒ loop code is: " + loopCode.flToString());
      }
      loopCode = context.lookupTemp("loopCode");
      while (true) {
        context.throwing = false;
        // yield from
        toBeReturned = loopCode.eval(context, loopCode);
        //flContexts.pop()
        if (methodsExecutionDebug) {
          log("Repeat1 ⇒ returning result after loop cycle: " + toBeReturned);
          log("Repeat1 ⇒ returning result CLASS after loop cycle: ");
          log("Repeat1 ⇒ remaining message after loop cycle: ");
          log("Repeat1 ⇒ message length:  ");
          log("Repeat1 ⇒ did I receive a Done? " + ((toBeReturned != null ? toBeReturned.flClass : void 0) === FLDone ? "yes" : "no"));
        }
        // catch any thrown "done" object, used to
        // exit from a loop.
        if (toBeReturned != null) {
          if (context.throwing && (toBeReturned.flClass === FLDone || toBeReturned.flClass === FLBreak)) {
            context.throwing = false;
            if (toBeReturned.value != null) {
              toBeReturned = toBeReturned.value;
            }
            if (methodsExecutionDebug) {
              log("Repeat1 ⇒ the loop exited with Done at context depth " + context.depth());
            }
            break;
          }
          if (context.throwing && toBeReturned.flClass === FLReturn) {
            if (methodsExecutionDebug) {
              log("Repeat1 ⇒ the loop exited with Return ");
            }
            break;
          }
        }
      }
      return toBeReturned;
    });
    // Repeat2 -------------------------------------------------------------------------
    repeatFunctionContinuation = function(context) {
      var base, howManyTimes, i, l, limit, loopCode, ref, toBeReturned;
      context.isTransparent = true;
      if (methodsExecutionDebug) {
        log("context now tramsparent at depth: " + context.depth() + " with self: " + (typeof (base = context.self).flToString === "function" ? base.flToString() : void 0));
      }
      howManyTimes = context.lookupTemp("howManyTimes");
      loopCode = context.lookupTemp("loopCode");
      if (methodsExecutionDebug) {
        log("FLRepeat2 ⇒ loop code is: " + loopCode.flToString());
      }
      if (howManyTimes.flClass === FLForever) {
        limit = Number.MAX_SAFE_INTEGER;
      } else {
        limit = howManyTimes.value;
      }
      for (i = l = 0, ref = limit; (0 <= ref ? l < ref : l > ref); i = 0 <= ref ? ++l : --l) {
        //yield "from repeatFunctionContinuation"
        if (methodsExecutionDebug) {
          log("Repeat2 ⇒ starting a(nother) cycle: ");
        }
        // yield from
        toBeReturned = loopCode.eval(context, loopCode);
        //flContexts.pop()
        if (methodsExecutionDebug) {
          log("Repeat2 ⇒ returning result after loop cycle: " + toBeReturned);
          log("Repeat2 ⇒ returning result CLASS after loop cycle: ");
          log("Repeat2 ⇒ remaining message after loop cycle: ");
          log("Repeat2 ⇒ message length:  ");
          log("Repeat2 ⇒ did I receive a Done? " + ((toBeReturned != null ? toBeReturned.flClass : void 0) === FLDone ? "yes" : "no"));
          log("Repeat2 ⇒ did I receive a thrown object? " + (context.throwing ? "yes" : "no"));
        }
        // catch any thrown "done" object, used to
        // exit from a loop.
        if (toBeReturned != null) {
          if (context.throwing && (toBeReturned.flClass === FLDone || toBeReturned.flClass === FLBreak)) {
            context.throwing = false;
            if (toBeReturned.value != null) {
              toBeReturned = toBeReturned.value;
            }
            if (methodsExecutionDebug) {
              log("Repeat2 ⇒ the loop exited with Done at context depth " + context.depth());
            }
            break;
          }
          if (context.throwing && toBeReturned.flClass === FLReturn) {
            if (methodsExecutionDebug) {
              log("Repeat2 ⇒ the loop exited with Return ");
            }
            break;
          }
        }
      }
      return toBeReturned;
    };
    FLRepeat2.addMethod(flTokenize("(howManyTimes) :( ' loopCode )"), repeatFunctionContinuation);
    // FLEvaluationsCounter -----------------------------------------------------------------------------
    FLEvaluationsCounter.addMethod(FLList.emptyMessage(), function(context) {
      var stringToPrint;
      //yield
      stringToPrint = "EvaluationsCounter running the \"empty\" method // ";
      if (methodsExecutionDebug) {
        log(stringToPrint);
      }
      rWorkspace.environmentPrintout += stringToPrint;
      return this;
    });
    // Throw -----------------------------------------------------------------------------
    FLThrow.addMethod(flTokenize("( theError )"), function(context) {
      var theError;
      //yield
      theError = context.lookupTemp("theError");
      theError.thrown = true;
      if (methodsExecutionDebug) {
        log("throwing an error: " + theError.value);
      }
      context.throwing = true;
      return theError;
    });
    // IfThen -----------------------------------------------------------------------------
    FLIfThen.addMethod(flTokenize("( predicate ) : ('trueBranch)"), function(context) {
      var base, predicate, toBeReturned, trueBranch;
      //yield
      context.isTransparent = true;
      if (methodsExecutionDebug) {
        log("context now tramsparent at depth: " + context.depth() + " with self: " + (typeof (base = context.self).flToString === "function" ? base.flToString() : void 0));
      }
      predicate = context.lookupTemp("predicate");
      trueBranch = context.lookupTemp("trueBranch");
      if (methodsExecutionDebug) {
        log("FLIfThen: predicate value is: " + predicate.value);
      }
      if (predicate.value) {
        if (methodsExecutionDebug) {
          log("FLIfThen: evaling true branch at depth " + context.depth());
        }
        // yield from
        toBeReturned = trueBranch.eval(context, trueBranch);
      } else {
        //flContexts.pop()
        toBeReturned = FLIfFallThrough.createNew();
      }
      return toBeReturned;
    });
    // FLIfFallThrough -----------------------------------------------------------------------------

    // all these "emptyMessage" signatures are going to be examined
    // last because "addMethod" sorts all methods in order of increasing
    // genericity. (more generic matches will be done last)
    FLIfFallThrough.addMethod(FLList.emptyMessage(), function(context) {
      //yield
      if (methodsExecutionDebug) {
        log("no more cases for the if");
      }
      return FLNil.createNew();
    });
    FLIfFallThrough.addMethod(flTokenize("else if ( predicate ): ('trueBranch)"), function(context) {
      var base, predicate, toBeReturned, trueBranch;
      //yield
      context.isTransparent = true;
      if (methodsExecutionDebug) {
        log("context now tramsparent at depth: " + context.depth() + " with self: " + (typeof (base = context.self).flToString === "function" ? base.flToString() : void 0));
      }
      predicate = context.lookupTemp("predicate");
      trueBranch = context.lookupTemp("trueBranch");
      if (methodsExecutionDebug) {
        log("FLIfFallThrough: predicate value is: " + predicate.value);
        log("FLIfFallThrough: true branch is: " + trueBranch.flToString());
      }
      if (predicate.value) {
        // yield from
        toBeReturned = trueBranch.eval(context, trueBranch);
      } else {
        //flContexts.pop()
        toBeReturned = FLIfFallThrough.createNew();
      }
      return toBeReturned;
    });
    FLIfFallThrough.addMethod(flTokenize("else: ('trueBranch)"), function(context) {
      var base, toBeReturned, trueBranch;
      if (methodsExecutionDebug) {
        log("FLIfFallThrough else: case ");
        log("context now tramsparent at depth: " + context.depth() + " with self: " + (typeof (base = context.self).flToString === "function" ? base.flToString() : void 0));
      }
      context.isTransparent = true;
      trueBranch = context.lookupTemp("trueBranch");
      // yield from
      if (methodsExecutionDebug) {
        log("FLIfFallThrough else: evalling code ");
      }
      toBeReturned = trueBranch.eval(context, trueBranch);
      //flContexts.pop()
      return toBeReturned;
    });
    // Try -----------------------------------------------------------------------------
    FLTry.addMethod(flTokenize(": ( ' code )"), function(context) {
      var code, toBeReturned;
      code = context.lookupTemp("code");
      // yield from
      toBeReturned = code.eval(context, code);
      // if there _is_ somethig being thrown, then
      // we do not want another receiver, the thrown
      // exception has to go through some catches
      // hopefully.
      context.throwing = false;
      return toBeReturned;
    });
    // Pause -----------------------------------------------------------------------------
    pauseFunctionContinuation = function(context) {
      var endTime, remainingTime, seconds, startTime;
      //yield
      seconds = context.lookupTemp("seconds");
      startTime = new Date().getTime();
      endTime = startTime + seconds.value * 1000;
      while ((remainingTime = new Date().getTime() - endTime) < 0) {
        //yield remainingTime
        "do nothing";
      }
      return this;
    };
    FLPause.addMethod(flTokenize("( seconds )"), pauseFunctionContinuation);
    // For -----------------------------------------------------------------------------
    FLFor.addMethod(flTokenize("( ' loopVar ) from ( startIndex ) to ( endIndex ) : ( 'loopCode )"), function(context) {
      var base, endIndex, forContext, i, l, loopCode, loopVar, loopVarName, ref, ref1, startIndex, toBeReturned;
      context.isTransparent = true;
      if (methodsExecutionDebug) {
        log("context now tramsparent at depth: " + context.depth() + " with self: " + (typeof (base = context.self).flToString === "function" ? base.flToString() : void 0));
      }
      loopVar = context.lookupTemp("loopVar");
      startIndex = context.lookupTemp("startIndex");
      endIndex = context.lookupTemp("endIndex");
      loopCode = context.lookupTemp("loopCode");
      loopVarName = loopVar.value;
      forContext = new FLContext(context);
      forContext.isTransparent = true;
      //flContexts.jsArrayPush forContext
      if (methodsExecutionDebug) {
        log("FLFor ⇒ loop code is: " + loopCode.flToString());
      }
      for (i = l = ref = startIndex.value, ref1 = endIndex.value; (ref <= ref1 ? l <= ref1 : l >= ref1); i = ref <= ref1 ? ++l : --l) {
        if (methodsExecutionDebug) {
          log("FLFor ⇒ loop iterating variable to " + i);
        }
        // the looping var is always in the new local for context
        // so it keeps any previous instance safe, and goes
        // away when this for is done.
        forContext.tempVariablesDict[ValidIDfromString(loopVarName)] = FLNumber.createNew(i);
        // yield from
        toBeReturned = loopCode.eval(forContext, loopCode);
        //flContexts.pop()

        // catch any thrown "done" object, used to
        // exit from a loop.
        if (toBeReturned != null) {
          if (context.throwing && (toBeReturned.flClass === FLDone || toBeReturned.flClass === FLBreak)) {
            context.throwing = false;
            if (toBeReturned.value != null) {
              toBeReturned = toBeReturned.value;
            }
            if (methodsExecutionDebug) {
              log("For ⇒ the loop exited with Done ");
            }
            break;
          }
          if (context.throwing && toBeReturned.flClass === FLReturn) {
            if (methodsExecutionDebug) {
              log("For ⇒ the loop exited with Return ");
            }
            break;
          }
        }
      }
      //flContexts.pop()
      return toBeReturned;
    });
    // there a few tricks that we performs on 'theList
    // FIRST OFF, we can't just pass theList as an evaluated
    // parameter because if you pass a list literal, then you
    // need the : to mean "quote", but at that point you can't
    // use the : when you pass statements that create a list
    // That does work, but it makes it tricky to understand when
    // to use the : and when not to.
    // So we make theList a quoted param instead, and we eval it.
    // If the evaluation returns a list, then we take that as
    // input. If not, we take the original list as input.
    return FLFor.addMethod(flTokenize("each ( ' variable ) in: ( theList ) do: ( 'code )"), function(context) {
      var base, code, forContext, i, l, ref, theList, toBeReturned, variable;
      //yield
      context.isTransparent = true;
      if (methodsExecutionDebug) {
        log("context now tramsparent at depth: " + context.depth() + " with self: " + (typeof (base = context.self).flToString === "function" ? base.flToString() : void 0));
      }
      variable = context.lookupTemp("variable");
      theList = context.lookupTemp("theList");
      code = context.lookupTemp("code");
      if (theList.flClass !== FLList) {
        context.throwing = true;
        // TODO this error should really be a stock error referanceable
        // from the workspace because someone might want to catch it.
        return FLException.createNew("for...each expects a list");
      }
      // trivial case
      if (theList.isEmpty()) {
        return theList;
      }
      if (methodsExecutionDebug) {
        log("FLEach do on the list: " + theList.flToString());
      }
      forContext = new FLContext(context);
      forContext.isTransparent = true;
      for (i = l = 0, ref = theList.value.length; (0 <= ref ? l < ref : l > ref); i = 0 <= ref ? ++l : --l) {
        forContext.throwing = false;
        if (methodsExecutionDebug) {
          log("FLEach element at " + i + " : " + (theList.elementAt(i)).flToString());
        }
        forContext.tempVariablesDict[ValidIDfromString(variable.value)] = theList.elementAt(i);
        if (methodsExecutionDebug) {
          log("FLEach do evaling...: " + code.flToString());
        }
        // yield from
        toBeReturned = code.eval(forContext, code);
        // catch any thrown "done" object, used to
        // exit from a loop.
        if (toBeReturned != null) {
          if (context.throwing && (toBeReturned.flClass === FLDone || toBeReturned.flClass === FLBreak)) {
            context.throwing = false;
            if (toBeReturned.value != null) {
              toBeReturned = toBeReturned.value;
            }
            if (methodsExecutionDebug) {
              log("for-each-in-list loop exited with Done ");
            }
            break;
          }
          if (context.throwing && toBeReturned.flClass === FLReturn) {
            if (methodsExecutionDebug) {
              log("for-each-in-list loop exited with Return ");
            }
            break;
          }
        }
      }
      return toBeReturned;
    });
  };

  //flContexts = []
  mainTurtle = null;

  initContext = function(context) {
    var itsInitialisation, j, keyword, keywords, keywordsAndTheirInit, ref, results;
    keywordsAndTheirInit = [
      "WorkSpace",
      FLWorkspace, // todo probably not needed?
      "Class",
      FLClass,
      "List",
      FLList,
      "String",
      FLString,
      "Exception",
      FLException,
      "Number",
      FLNumber,
      "Boolean",
      FLBoolean,
      "Console",
      FLConsole,
      "Turtle",
      FLTurtle,
      "not",
      FLNot.createNew(),
      "true",
      FLBoolean.createNew(true),
      "false",
      FLBoolean.createNew(false),
      "for",
      FLFor.createNew(),
      "repeat1",
      FLRepeat1.createNew(),
      "done",
      FLDone.createNew(),
      "break",
      FLBreak.createNew(),
      "return",
      FLReturn.createNew(),
      "if",
      FLIfThen.createNew(),
      "forever",
      FLForever.createNew(),
      "repeat",
      FLRepeat2.createNew(),
      "try",
      FLTry.createNew(),
      "throw",
      FLThrow.createNew(),
      "to",
      FLTo.createNew(),
      "in",
      FLIn.createNew(),
      "accessUpperContext",
      FLAccessUpperContext.createNew(),
      "evaluationsCounter",
      FLEvaluationsCounter.createNew(),
      "nil",
      FLNil.createNew(),
      "console",
      FLConsole.createNew(),
      "turtle",
      (mainTurtle = FLTurtle.createNew()),
      "pause",
      FLPause.createNew(),
      "'",
      FLQuote.createNew(),
      ":",
      FLQuote.createNew(),
      "-",
      FLUnaryMinus.createNew(),
      "[",
      FLListLiteralArrayNotationStarter.createNew()
    ];
    results = [];
    for (keywords = j = 0, ref = keywordsAndTheirInit.length; j < ref; keywords = j += 2) {
      [keyword, itsInitialisation] = keywordsAndTheirInit.slice(keywords, +(keywords + 1) + 1 || 9e9);
      results.push(context.tempVariablesDict[ValidIDfromString(keyword)] = itsInitialisation);
    }
    return results;
  };

  quickReset = function() {
    var eachClass, j, len, results;
    //flContexts = []
    rWorkspace = FLWorkspace.createNew();
    rWorkspace.environmentPrintout = "";
    console.log("resetting rWorkspace.environmentErrors");
    rWorkspace.environmentErrors = "";
    outerMostContext = new FLContext(null, rWorkspace);
    //flContexts.jsArrayPush outerMostContext
    initContext(outerMostContext);
    mainTurtle.sendHome();
    // instead of clearing and re-initiating all the classes,
    // let's just get rid of all the classes created after
    // booting, also so we don't create a memory leak.
    allClasses = bootClasses.slice();
    results = [];
    for (j = 0, len = allClasses.length; j < len; j++) {
      eachClass = allClasses[j];
      results.push(eachClass.resetInstanceVariables());
    }
    return results;
  };

  reset = function() {
    // resetting the classes and initing them
    // adds quite a bit more time to the tests
    // but it's worth checking once in a while
    // that the tests behave well when the state
    // is reset more deeply.
    clearClasses();
    initBootClasses();
    //flContexts = []
    rWorkspace = FLWorkspace.createNew();
    rWorkspace.environmentPrintout = "";
    console.log("resetting rWorkspace.environmentErrors");
    rWorkspace.environmentErrors = "";
    outerMostContext = new FLContext(null, rWorkspace);
    //flContexts.jsArrayPush outerMostContext
    initContext(outerMostContext);
    return mainTurtle.sendHome();
  };

  textOutputElement = null;

  canvasOutputElement = null;

  devicePixelRatio = 1;

  // this is called from the browser
  Fizzylogo.init = function(textOutElem, canvasOutElem, devPixRatio) {
    if (textOutElem != null) {
      // don't do any logging when used in
      // the browser
      log = function() {};
      dir = function() {};
    }
    textOutputElement = textOutElem;
    canvasOutputElement = canvasOutElem;
    devicePixelRatio = devPixRatio;
    // scale all drawing operations by the
    // devicePixelRatio value, otherwise, say,
    // in Retina Displays 2x we'd get drawings that
    // are much smaller.
    if (canvasOutputElement != null) {
      canvasOutputElement.getContext('2d').scale(devicePixelRatio, devicePixelRatio);
    }
    return reset();
  };

  // this one is for the browser, and the yielding is always
  // enabled for the browser build, so this is always used
  // as a generator.
  Fizzylogo.runOneStep = function(code) {
    var parsed, returned;
    quickReset();
    parsed = flTokenize(code);
    log("evaluation " + indentation() + "messaging workspace with " + parsed.flToString());
    // yield from
    returned = parsed.eval(outerMostContext, parsed);
    outerMostContext.returned = returned;
    console.log("evaluation " + indentation() + "end of workspace evaluation");
    console.log("rWorkspace.environmentPrintout " + rWorkspace.environmentPrintout);
    console.log("rWorkspace.environmentErrors " + rWorkspace.environmentErrors);
    if (outerMostContext.throwing && outerMostContext.returned.flClass === FLException) {
      log("evaluation " + indentation() + "exception: " + outerMostContext.returned.value);
      rWorkspace.environmentErrors += "! exception: " + outerMostContext.returned.value;
      log("rWorkspace.environmentErrors " + rWorkspace.environmentErrors);
      if (textOutputElement != null) {
        textOutputElement.value += rWorkspace.environmentErrors + "\n";
      }
    }
    return null;
  };

  run = function(code) {
    var gen, parsed, ret, yieldMode;
    quickReset();
    parsed = flTokenize(code);
    log("evaluation " + indentation() + "messaging workspace with " + parsed.flToString());
    yieldMode = false;
    //yieldMode = true
    if (yieldMode) {
      gen = parsed.eval(outerMostContext, parsed);
      while (!(ret = gen.next()).done) {
        if (ret.value != null) {
          log("obtained: " + ret.value);
        }
        log("obtained: yieldingfromtoplevel");
      }
      outerMostContext.returned = ret.value;
    } else {
      outerMostContext.returned = parsed.eval(outerMostContext, parsed);
    }
    log("evaluation " + indentation() + "end of workspace evaluation");
    console.log("rWorkspace.environmentErrors " + rWorkspace.environmentErrors);
    if (outerMostContext.throwing && outerMostContext.returned.flClass === FLException) {
      log("evaluation " + indentation() + "exception: " + outerMostContext.returned.value);
      rWorkspace.environmentErrors += "! exception: " + outerMostContext.returned.value;
      log("rWorkspace.environmentErrors " + rWorkspace.environmentErrors);
    }
    return null;
  };

  tests = [
    // ---------------------------------------------------------------------------
    "console print \"start of tests\"",
    "start of tests",
    // ---------------------------------------------------------------------------
    "pause 2",
    "",
    // ---------------------------------------------------------------------------
    // "common math" operator precedence
    // (contrarily to modern Smalltalk and some Logo
    // implementations which are left to right,
    // or Smalltalk-72 / Rosetta Smalltalk / APL which are
    // right to left) 
    "console print 2 * 3 + 1",
    "7",
    // left-associative rule: this is read as (8-3)-2
    // this is fine for most math operators except a^b^c
    // which in "common math" should actually be a^(b^c)
    "console print 8 - 3 - 2",
    "3",
    "console print 10 - 3 + 2",
    "9",
    "console print 2 + 3 * 4 - 1",
    "13",
    "a = 20\nb = 10\nc = 15\nd = 5\nconsole print (a+b)*c/d\nconsole print \" \"\nconsole print ((a+b)*c)/d\nconsole print \" \"\nconsole print (a+b)*c/d\nconsole print \" \"\nconsole print a+(b*c)/d",
    "90 90 90 50",
    "if 30 < 30 + 1:\n﹍console print \"ok\"\nelse:\n﹍console print \"nok\"",
    "ok",
    "if 30 + 1 > 30:\n﹍console print \"ok\"\nelse:\n﹍console print \"nok\"",
    "ok",
    "if 30 < 30 - 1:\n﹍console print \"nok\"\nelse:\n﹍console print \"ok\"",
    "ok",
    "if 30 - 1 > 30:\n﹍console print \"nok\"\nelse:\n﹍console print \"ok\"",
    "ok",
    // ---------------------------------------------------------------------------
    "console print (2 * 3) + 1",
    "7",
    // ---------------------------------------------------------------------------
    "console print (1.2 * 3.4) + 5.6",
    "9.68",
    // ---------------------------------------------------------------------------

    // note that the "ground" operators have a priority
    // so we better use the "answer with priority" with the
    // correct priority when we want to modify those, otherwise
    // precedence of operators changes!
    "console print 1+1;Number answer with priority 4 :(+(operandum))by:(console print self;console print \"+\";console print operandum);2+3;Number answer with priority 4 :(+(operandum))by:(self $plus_binary_default operandum);",
    "22+3",
    // see above about "answer with priority"
    "console print 1+1\nNumber answer with priority 4:\n﹍﹍+ (operandum)\n﹍by:\n﹍﹍console print self\n﹍﹍console print \"+\"\n﹍﹍console print operandum\n2+3\n\nNumber answer with priority 4:\n﹍﹍+ (operandum)\n﹍by:\n﹍﹍self $plus_binary_default operandum",
    "22+3",
    // / is left associative
    "console print 1/2/2/2/2",
    "0.0625",
    // ---------------------------------------------------------------------------
    // assignments are right-associative (the default if
    // the precedence is not set)
    "console print a\nconsole print b\nconsole print c\na = b = c = 1\nconsole print a\nconsole print b\nconsole print c",
    "nilnilnil111",
    // ---------------------------------------------------------------------------
    // unary minus checks
    "a = -1\nconsole print a",
    "-1",
    "a = -(1)\nconsole print a",
    "-1",
    "a = -(-1)\nconsole print a",
    "1",
    // this is fairly perverse and we
    // reject it. We could make sense of this if the
    // minuses were separated (i.e. we make sense of "- -1")
    // but we can't separate the --
    // since -- is the decrement operator.
    "console print --1",
    "nil! exception: message was not understood: ( 1 )",
    // right-to-left associativity of unary minus
    // not sure this is ever going to be used
    // also since we don't accept the "--" form
    // see test above
    "console print - -2\nconsole print - - 2\nconsole print - - - -2\nconsole print - - - - 2\nconsole print - - - - - -2\nconsole print - - - - - - 2\nconsole print \" \"\nconsole print -2\nconsole print - 2\nconsole print - - -2\nconsole print - - - 2\nconsole print - - - - -2\nconsole print - - - - - 2",
    "222222 -2-2-2-2-2-2",
    "console print -1*4\nconsole print 4*-1",
    "-4-4",
    "console print -1-1",
    "-2",
    "console print 1/-2/2/-2/-2",
    "-0.0625",
    "console print 1/-2/-2/-2/2",
    "-0.0625",
    "console print 1/2/-2/-2/-2",
    "-0.0625",
    "console print 1/-2/-2/-2/-2",
    "0.0625",
    "console print -2*2+1",
    "-3",
    "console print 1+-2*2",
    "-3",
    "console print 1*-2",
    "-2",
    "console print -2*1",
    "-2",
    "console print -2*-1",
    "2",
    // ---------------------------------------------------------------------------
    // power (exponent) operator, also with unary minus

    //it's right-associative
    "console print 4^3^2",
    "262144",
    "console print 2^2",
    "4",
    "console print 1+2^2",
    "5",
    "console print 2^2+1",
    "5",
    // traditional algebraic notation
    // same as PHP, Python, Haskell, and D
    // Javascript rules this out on the grounds of simplicity and
    // the fact that it's not that common to have a leading
    // unary minus like that, usually you have
    // somehting - 2 ^ 2 which makes that minus a binary minus
    "console print -2^2",
    "-4",
    "console print 0+-2^2",
    "-4",
    "console print 1-2^2",
    "-3",
    "console print 2^(-2)",
    "0.25",
    // same as PHP, Python, Haskell, D, Javascript
    // Haskell throws syntax error
    "console print 2^-2",
    "0.25",
    "console print -2^-2",
    "-0.25",
    "console print 2^2^2",
    "16",
    "console print 2^2^-2",
    "1.189207115002721",
    "console print 2^-2^2",
    "0.0625",
    "console print 2^-2^-2",
    "0.8408964152537145",
    "console print -2^2^2",
    "-16",
    "console print -2^2^-2",
    "-1.189207115002721",
    "console print -2^-2^2",
    "-0.0625",
    "console print -2^-2^-2",
    "-0.8408964152537145",
    "console print -2^-2-2",
    "-2.25",
    // ---------------------------------------------------------------------------
    // here "print" takes "print" and does
    // nothing with it, so first (1+1) is
    // printed, and then the result of that is
    // printed again.
    "console print(console print 1+1)",
    "22",
    // ---------------------------------------------------------------------------
    // there are two ways to assign things, this is
    // the most technically thorough but it's
    // more difficult to decypher.

    // The semicolon separates stataments.
    "'a ← \"test string\"; 'b ← a; 'c ← 'a; console print 'a eval;console print 'b eval;console print 'c eval",
    "test stringtest stringa",
    // -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-

    // the equal sign is less technically thorough but
    // it's move obvious from anybody coming from a mainstream language.
    "a=\"test string\";b=a;c='a;console print 'a eval;console print 'b eval;console print 'c eval",
    "test stringtest stringa",
    // the three "console print 'x eval" above are equivalent to "console print x"
    "a=\"test string\";b=a;c='a;console print a;console print b;console print c",
    "test stringtest stringa",
    // ---------------------------------------------------------------------------
    "'a←5;a incrementInPlace;'a←a+1;console print a",
    "7",
    // -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
    "a=5;a incrementInPlace;a=a+1;console print a",
    "7",
    // ---------------------------------------------------------------------------
    // the powers and dangers of mutating numbers in place
    "a=1;b=a;console print a;console print b;a incrementInPlace;console print a;console print b",
    "1122",
    // ---------------------------------------------------------------------------
    // testing crazy statement separations
    "'a←5;;a incrementInPlace; ;;;  ;'a←a+1;console print a",
    "7",
    ";'a←5;;a incrementInPlace; ;;;  ;'a←a+1;console print a;",
    "7",
    ";;'a←5;;a incrementInPlace; ;;;  ;'a←a+1;console print a;;",
    "7",
    "; ;'a←5;;a incrementInPlace; ;;;  ;'a←a+1;console print a; ;",
    "7",
    ";;;'a←5;;a incrementInPlace; ;;;  ;'a←a+1;console print a;;;",
    "7",
    // ---------------------------------------------------------------------------
    "'a←5;'a←a+1;console print a incrementInPlace",
    "7",
    // -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
    "a=5;a=a+1;console print a incrementInPlace",
    "7",
    // ---------------------------------------------------------------------------
    "'a←5+1;console print a incrementInPlace",
    "7",
    // -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
    "a=5+1;console print a incrementInPlace",
    "7",
    // ---------------------------------------------------------------------------
    "'a←(5+1);console print a incrementInPlace",
    "7",
    // -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
    "a=(5+1);console print a incrementInPlace",
    "7",
    // ---------------------------------------------------------------------------
    "console print 4+1+1",
    "6",
    // ---------------------------------------------------------------------------
    "'a←(4+1+1);console print a incrementInPlace",
    "7",
    // -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
    "a=(4+1+1);console print a incrementInPlace",
    "7",
    // ---------------------------------------------------------------------------
    "'a←(4 +(1+1));console print a incrementInPlace",
    "7",
    // -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
    "a=(4 +(1+1));console print a incrementInPlace",
    "7",
    // ---------------------------------------------------------------------------
    "'a←((4+1)+(0+1));console print a incrementInPlace",
    "7",
    // -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
    "a=((4+1)+(0+1));console print a incrementInPlace",
    "7",
    // ---------------------------------------------------------------------------
    "7 anotherPrint",
    "7",
    // ---------------------------------------------------------------------------
    "7 doublePrint",
    "77",
    // ---------------------------------------------------------------------------
    "console print console print 7",
    "77",
    // ---------------------------------------------------------------------------
    "console print 6 doublePrint+1",
    "667",
    // ---------------------------------------------------------------------------
    "6 doublePrint + console print 1",
    "661",
    // ---------------------------------------------------------------------------
    "console print 4+3",
    "7",
    // ---------------------------------------------------------------------------
    "console print console print 4+3",
    "77",
    // ---------------------------------------------------------------------------
    "console print (4 +(2+1))",
    "7",
    // ---------------------------------------------------------------------------
    "4 + console print 2+1",
    "3",
    // ---------------------------------------------------------------------------
    "4+2+ console print 1",
    "1",
    // ---------------------------------------------------------------------------
    "console print ('(1+1))",
    "( 1 + 1 )",
    // ---------------------------------------------------------------------------
    // the ' still ties to the first element
    // that comes after it i.e. ( 1+1 )
    "console print '(1+1)",
    "( 1 + 1 )",
    // ---------------------------------------------------------------------------
    "console print ('(1+1))length",
    "3",
    // ---------------------------------------------------------------------------
    "console print '(1+1)length",
    "3",
    // ---------------------------------------------------------------------------
    "console print (('(1+1))eval)",
    "2",
    // ---------------------------------------------------------------------------
    "console print ('(1+1))eval",
    "2",
    // ---------------------------------------------------------------------------
    "console print '(1+1)eval",
    "2",
    // ---------------------------------------------------------------------------
    // here is why we need eval to run a list,
    // and we can't just drop the list without eval
    // and hope that the "empty message" causes
    // it to run: because we want these two
    // statements to work the same.
    // Another way of saying it is that if a list
    // could run on its own without eval,
    // any *quoted* list would run on its own too!
    // *even if it's quoted*!
    "codeToBeRun = '(console print 1+2)\nconsole print codeToBeRun\nconsole print \" - \"\nconsole print '(console print 1+2)",
    "( console print 1 + 2 ) - ( console print 1 + 2 )",
    "codeToBeRun = '(console print 1+2)\ncodeToBeRun eval\ncodeToBeRun = '(console print \"hello\")\ncodeToBeRun eval",
    "3hello",
    // ---------------------------------------------------------------------------
    // initialising Lists via the "more normal" "array literal" notation.
    // Note that there are no "Array"s in FizzyLogo, only "List"s.
    // This is just a very very convenient way to initialise them
    // see the "ListLiteralArrayNotation" file for more insight.
    "a = [-2]\nconsole print a length\nconsole print a[1]",
    "1-2",
    "a = [0,-2]\nconsole print a length\nconsole print a[1]\nconsole print a[2]",
    "20-2",
    "someVariable = 1\na = [someVariable,1+2,\"a\"+\"b\",-2,-2,1-2]\nconsole print a length\nconsole print a",
    "6( 1 3 \"ab\" -2 -2 -1 )",
    "a = [(1+2),true,(not not true)]\nconsole print a length\nconsole print a",
    "3( 3 true true )",
    "a = [1,2,[3,4],5]\nconsole print a length\nconsole print a\nconsole print a[3] length\nconsole print a[3]",
    "4( 1 2 ( 3 4 ) 5 )2( 3 4 )",
    // doing
    //    a = []
    // is same as doing
    //    a = '()
    "a = []\nconsole print a length",
    "0",
    "a = [[]]\nconsole print a length\nconsole print a\nconsole print a[1] length\nconsole print a[1]",
    "1( empty message )0empty message",
    "someVariable = not not true\nsomeOtherVariable = [(1+2),true,someVariable]\na = [ 1+2,\"a\"+\"b\",someOtherVariable,-2,-2,1-2]\nconsole print a length\nconsole print a",
    "6( 3 \"ab\" ( 3 true true ) -2 -2 -1 )",
    "someVariable = not not true\na = [ 1+2,\"a\"+\"b\",[(1+2),true,someVariable],-2,-2,1-2]\nconsole print a length\nconsole print a",
    "6( 3 \"ab\" ( 3 true true ) -2 -2 -1 )",
    // ---------------------------------------------------------------------------
    "'a←5;'b←'a;console print b;console print a",
    "a5",
    // -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
    "a=5;b='a;console print b;console print a",
    "a5",
    // ---------------------------------------------------------------------------
    "console print true negate",
    "false",
    // ---------------------------------------------------------------------------
    // note how the first not understood
    // prevents any further statement to be
    // executed
    "1 negate; console print 2",
    "! exception: message was not understood: ( negate )",
    // ---------------------------------------------------------------------------
    "2 1 postfixPrint",
    "! exception: message was not understood: ( 1 postfixPrint )",
    // ---------------------------------------------------------------------------
    "console print negate",
    "nil",
    // ---------------------------------------------------------------------------
    "console print negate; negate = 2; console print negate; negate = nil; console print negate; negate +",
    "nil2nil! exception: message was not understood: ( + )",
    // ---------------------------------------------------------------------------
    "a = \"a\" \"b\"\nconsole print a",
    "! exception: message was not understood: ( TOKEN:b )",
    // ---------------------------------------------------------------------------
    "nonExistingObject",
    "",
    // ---------------------------------------------------------------------------
    "2 nonExistingMessage",
    "! exception: message was not understood: ( nonExistingMessage )",
    // ---------------------------------------------------------------------------
    "1 == 1 negate; console print 2",
    "2",
    // ---------------------------------------------------------------------------
    "console print false and false",
    "false",
    // ---------------------------------------------------------------------------
    "console print false and true",
    "false",
    // ---------------------------------------------------------------------------
    "console print true and false",
    "false",
    // ---------------------------------------------------------------------------
    "console print true and true",
    "true",
    // ---------------------------------------------------------------------------
    "console print false or false",
    "false",
    // ---------------------------------------------------------------------------
    "console print false or true",
    "true",
    // ---------------------------------------------------------------------------
    "console print true or false",
    "true",
    // ---------------------------------------------------------------------------
    "console print true or true",
    "true",
    // ---------------------------------------------------------------------------
    "console print not true",
    "false",
    // ---------------------------------------------------------------------------
    "console print not(not true)",
    "true",
    "console print not not true",
    "true",
    "console print (not not true)",
    "true",
    // ---------------------------------------------------------------------------
    "console print (not not not true)",
    "false",
    "console print not not not true",
    "false",
    // ---------------------------------------------------------------------------
    "console print (not not not not true)",
    "true",
    "console print not not not not true",
    "true",
    // ---------------------------------------------------------------------------
    "if true: (console print 1)",
    "1",
    // ---------------------------------------------------------------------------
    "if false: (console print 1) else: (console print 2)",
    "2",
    // ---------------------------------------------------------------------------
    "console print (0==0)",
    "true",
    "console print 0==0",
    "true",
    // ---------------------------------------------------------------------------
    "console print (1==0)",
    "false",
    "console print 1==0",
    "false",
    // ---------------------------------------------------------------------------
    // precedence tests for boolean operators and, or, not
    "console print \" \" + (false or false and false)\nconsole print \" \" + (false or false and true)\nconsole print \" \" + (false or true and false)\nconsole print \" \" + (false or true and true)\nconsole print \" \" + (true or false and false)\nconsole print \" \" + (true or false and true)\nconsole print \" \" + (true or true and false)\nconsole print \" \" + (true or true and true)\nconsole print \"----------------------------\"\nconsole print \" \" + (false or (false and false))\nconsole print \" \" + (false or (false and true ))\nconsole print \" \" + (false or (true and false))\nconsole print \" \" + (false or (true and true ))\nconsole print \" \" + (true or (false and false))\nconsole print \" \" + (true or (false and true ))\nconsole print \" \" + (true or (true and false))\nconsole print \" \" + (true or (true and true ))\nconsole print \"----------------------------\"\nconsole print \" \" + (false or false and false)\nconsole print \" \" + (false or true and false)\nconsole print \" \" + (false or false and true)\nconsole print \" \" + (false or true and true)\nconsole print \" \" + (true or false and false)\nconsole print \" \" + (true or true and false)\nconsole print \" \" + (true or false and true)\nconsole print \" \" + (true or true and true)\nconsole print \"----------------------------\"\nconsole print \" \" + (false or (false and false))\nconsole print \" \" + (false or (true and false))\nconsole print \" \" + (false or (false and true))\nconsole print \" \" + (false or (true and true))\nconsole print \" \" + (true or (false and false))\nconsole print \" \" + (true or (true and false))\nconsole print \" \" + (true or (false and true))\nconsole print \" \" + (true or (true and true ))\nconsole print \"----------------------------\"\nconsole print \"----------------------------\"\nconsole print \" \" + (false and false or false)\nconsole print \" \" + (false and true or false)\nconsole print \" \" + (true and false or false)\nconsole print \" \" + (true and true or false)\nconsole print \" \" + (false and false or true)\nconsole print \" \" + (false and true or true)\nconsole print \" \" + (true and false or true)\nconsole print \" \" + (true and true or true)\nconsole print \"----------------------------\"\nconsole print \" \" + ((false and false) or false)\nconsole print \" \" + ((false and true ) or false)\nconsole print \" \" + ((true and false) or false)\nconsole print \" \" + ((true and true ) or false)\nconsole print \" \" + ((false and false) or true)\nconsole print \" \" + ((false and true ) or true)\nconsole print \" \" + ((true and false) or true)\nconsole print \" \" + ((true and true ) or true)\nconsole print \"----------------------------\"\nconsole print \" \" + (false and false or false)\nconsole print \" \" + (true and false or false)\nconsole print \" \" + (false and true or false)\nconsole print \" \" + (true and true or false)\nconsole print \" \" + (false and false or true)\nconsole print \" \" + (true and false or true)\nconsole print \" \" + (false and true or true)\nconsole print \" \" + (true and true or true)\nconsole print \"----------------------------\"\nconsole print \" \" + ((false and false) or false)\nconsole print \" \" + ((true and false) or false)\nconsole print \" \" + ((false and true) or false)\nconsole print \" \" + ((true and true) or false)\nconsole print \" \" + ((false and false) or true)\nconsole print \" \" + ((true and false) or true)\nconsole print \" \" + ((false and true) or true)\nconsole print \" \" + ((true and true ) or true)\nconsole print \"++++++++++++++++++++++++++++\"\nconsole print \" \" + (not true or not true and not true)\nconsole print \" \" + (not true or not true and not false)\nconsole print \" \" + (not true or not false and not true)\nconsole print \" \" + (not true or not false and not false)\nconsole print \" \" + (not false or not true and not true)\nconsole print \" \" + (not false or not true and not false)\nconsole print \" \" + (not false or not false and not true)\nconsole print \" \" + (not false or not false and not false)\nconsole print \"----------------------------\"\nconsole print \" \" + (not true or (not true and not true))\nconsole print \" \" + (not true or (not true and not false ))\nconsole print \" \" + (not true or (not false and not true))\nconsole print \" \" + (not true or (not false and not false ))\nconsole print \" \" + (not false or (not true and not true))\nconsole print \" \" + (not false or (not true and not false ))\nconsole print \" \" + (not false or (not false and not true))\nconsole print \" \" + (not false or (not false and not false ))\nconsole print \"----------------------------\"\nconsole print \" \" + (not true or not true and not true)\nconsole print \" \" + (not true or not false and not true)\nconsole print \" \" + (not true or not true and not false)\nconsole print \" \" + (not true or not false and not false)\nconsole print \" \" + (not false or not true and not true)\nconsole print \" \" + (not false or not false and not true)\nconsole print \" \" + (not false or not true and not false)\nconsole print \" \" + (not false or not false and not false)\nconsole print \"----------------------------\"\nconsole print \" \" + (not true or (not true and not true))\nconsole print \" \" + (not true or (not false and not true))\nconsole print \" \" + (not true or (not true and not false))\nconsole print \" \" + (not true or (not false and not false))\nconsole print \" \" + (not false or (not true and not true))\nconsole print \" \" + (not false or (not false and not true))\nconsole print \" \" + (not false or (not true and not false))\nconsole print \" \" + (not false or (not false and not false ))\nconsole print \"----------------------------\"\nconsole print \"----------------------------\"\nconsole print \" \" + (not true and not true or not true)\nconsole print \" \" + (not true and not false or not true)\nconsole print \" \" + (not false and not true or not true)\nconsole print \" \" + (not false and not false or not true)\nconsole print \" \" + (not true and not true or not false)\nconsole print \" \" + (not true and not false or not false)\nconsole print \" \" + (not false and not true or not false)\nconsole print \" \" + (not false and not false or not false)\nconsole print \"----------------------------\"\nconsole print \" \" + ((not true and not true) or not true)\nconsole print \" \" + ((not true and not false ) or not true)\nconsole print \" \" + ((not false and not true) or not true)\nconsole print \" \" + ((not false and not false ) or not true)\nconsole print \" \" + ((not true and not true) or not false)\nconsole print \" \" + ((not true and not false ) or not false)\nconsole print \" \" + ((not false and not true) or not false)\nconsole print \" \" + ((not false and not false ) or not false)\nconsole print \"----------------------------\"\nconsole print \" \" + (not true and not true or not true)\nconsole print \" \" + (not false and not true or not true)\nconsole print \" \" + (not true and not false or not true)\nconsole print \" \" + (not false and not false or not true)\nconsole print \" \" + (not true and not true or not false)\nconsole print \" \" + (not false and not true or not false)\nconsole print \" \" + (not true and not false or not false)\nconsole print \" \" + (not false and not false or not false)\nconsole print \"----------------------------\"\nconsole print \" \" + ((not true and not true) or not true)\nconsole print \" \" + ((not false and not true) or not true)\nconsole print \" \" + ((not true and not false) or not true)\nconsole print \" \" + ((not false and not false) or not true)\nconsole print \" \" + ((not true and not true) or not false)\nconsole print \" \" + ((not false and not true) or not false)\nconsole print \" \" + ((not true and not false) or not false)\nconsole print \" \" + ((not false and not false ) or not false)",
    // all the segments must evaluate to:
    // false false false true true true true true
    " false false false true true true true true---------------------------- false false false true true true true true---------------------------- false false false true true true true true---------------------------- false false false true true true true true-------------------------------------------------------- false false false true true true true true---------------------------- false false false true true true true true---------------------------- false false false true true true true true---------------------------- false false false true true true true true++++++++++++++++++++++++++++ false false false true true true true true---------------------------- false false false true true true true true---------------------------- false false false true true true true true---------------------------- false false false true true true true true-------------------------------------------------------- false false false true true true true true---------------------------- false false false true true true true true---------------------------- false false false true true true true true---------------------------- false false false true true true true true",
    // ---------------------------------------------------------------------------
    "console print (0 amIZero)",
    "true",
    "console print 0 amIZero",
    "true",
    // ---------------------------------------------------------------------------
    "console print (1 amIZero)",
    "false",
    "console print 1 amIZero",
    "false",
    // ---------------------------------------------------------------------------
    "console print (8 - 1)",
    "7",
    "console print 8 - 1",
    "7",
    // ---------------------------------------------------------------------------
    // can't remove those parens!
    "if true: (console print 1) else: (console print 2)",
    "1",
    // ---------------------------------------------------------------------------
    "a=5\n\nif a==5:\n﹍console print \"yes a is 5\"",
    "yes a is 5",
    // ---------------------------------------------------------------------------
    "a=5\n\nif a==5:\n﹍console print \"yes a is 5\"\nconsole print \". the end.\"",
    "yes a is 5. the end.",
    // ---------------------------------------------------------------------------
    "a=5\n\nif a==5:\n﹍console print \"yes a is 5\"\nelse:\n﹍console print \"no a is not 5\"\nconsole print \". the end.\"",
    "yes a is 5. the end.",
    // ---------------------------------------------------------------------------
    "a=0\n\nif a==5:\n﹍console print \"yes a is 5\"\nelse:\n﹍console print \"no a is not 5\"\nconsole print \". the end.\"",
    "no a is not 5. the end.",
    // ---------------------------------------------------------------------------
    "a=0\n\nif a==5:\n﹍console print \"yes a is 5\"\nconsole print \"the end.\"",
    "the end.",
    // ---------------------------------------------------------------------------
    // if as expression
    "a = 0\na += if true:\n﹍﹍1\n﹍else:\n﹍﹍2\nconsole print a",
    "1",
    "a = 0\na +=\n﹍if true:\n﹍﹍1\n﹍else:\n﹍﹍2\nconsole print a",
    "1",
    "a = 0\na += if false:\n﹍﹍1\n﹍else:\n﹍﹍2\nconsole print a",
    "2",
    "a = 0\na +=\n﹍if false:\n﹍﹍1\n﹍else:\n﹍﹍2\nconsole print a",
    "2",
    // ---------------------------------------------------------------------------
    // more "if" as expression
    "to ifAsExpession:\n﹍if true:\n﹍﹍1\n\nconsole print ifAsExpession",
    "1",
    "to ifAsExpession:\n﹍if false:\n﹍﹍1\n\nconsole print ifAsExpession",
    "nil",
    "to ifAsExpession:\n﹍if false:\n﹍﹍1\n﹍2\n\nconsole print ifAsExpession",
    "2",
    // ---------------------------------------------------------------------------
    "console print 0 factorialsix",
    "1",
    // ---------------------------------------------------------------------------
    "console print 1 factorialsix",
    "1",
    // ---------------------------------------------------------------------------
    "console print 2 factorialsix",
    "2",
    // ---------------------------------------------------------------------------
    "console print 7 factorialsix",
    "5040",
    // ---------------------------------------------------------------------------
    "console print 0 factorialtwo",
    "1",
    // ---------------------------------------------------------------------------
    "console print 1 factorialtwo",
    "1",
    // ---------------------------------------------------------------------------
    "console print 2 factorialtwo",
    "2",
    // ---------------------------------------------------------------------------
    "console print 7 factorialtwo",
    "5040",
    // ---------------------------------------------------------------------------
    "console print 7 factorialthree",
    "76543215040",
    // ---------------------------------------------------------------------------
    "console print 7 factorialfour",
    "5040",
    // ---------------------------------------------------------------------------
    "console print 7 factorialfive",
    "5040",
    // ---------------------------------------------------------------------------
    "console print 7 selftimesminusone",
    "42",
    // ---------------------------------------------------------------------------
    "'a←5;1 printAFromDeeperCall",
    "5",
    // -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
    "a=5;1 printAFromDeeperCall",
    "5",
    // ---------------------------------------------------------------------------
    "'a←5;repeat1(if a==0: (done) else: ('a←a - 1));console print a",
    "0",
    // -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
    "a=5;repeat1(if a==0: (done) else: (a=a - 1));console print a",
    "0",
    // ---------------------------------------------------------------------------
    "'a←5\nrepeat1\n﹍if a==0:\n﹍﹍done\n﹍else:\n﹍﹍'a←a - 1\n\nconsole print a",
    "0",
    // -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
    "a=5\nrepeat1\n﹍if a==0:\n﹍﹍done\n﹍else:\n﹍﹍a=a - 1\n\nconsole print a",
    "0",
    // ---------------------------------------------------------------------------
    "'a←5\nrepeat1\n﹍if a==0:\n﹍﹍done\n﹍else:\n﹍﹍'a←a - 1\n;console print a",
    "0",
    // -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
    "a=5\nrepeat1\n﹍if a==0:\n﹍﹍done\n﹍else:\n﹍﹍a=a - 1\n;console print a",
    "0",
    // ---------------------------------------------------------------------------
    "'a←5\n\nrepeat forever:\n﹍if a==0:\n﹍﹍done\n﹍else:\n﹍﹍'a←a - 1\nconsole print a",
    "0",
    // -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
    "a=5\n\nrepeat forever:\n﹍if a==0:\n﹍﹍done\n﹍else:\n﹍﹍a=a - 1\nconsole print a",
    "0",
    // ---------------------------------------------------------------------------
    "a=5\n\nrepeat forever:\n﹍if a==0:\n﹍﹍done\n﹍else:\n﹍﹍a=a - 1\nconsole print a",
    "0",
    "a=5\n\nrepeat forever:\n﹍if a==0:\n﹍﹍break\n﹍else:\n﹍﹍a=a - 1\nconsole print a",
    "0",
    // ---------------------------------------------------------------------------
    // nested loops with breaks
    "j=5\ncounter = 0\n\nrepeat forever:\n﹍k=5\n﹍console print \" o/j: \" + j\n﹍console print \" o/k: \" + k\n﹍if j==0:\n﹍﹍break\n﹍else:\n﹍﹍j=j - 1\n﹍﹍repeat forever:\n﹍﹍﹍console print \" i/j: \" + j\n﹍﹍﹍console print \" i/k: \" + k\n﹍﹍﹍if k==0:\n﹍﹍﹍﹍break\n﹍﹍﹍else:\n﹍﹍﹍﹍k=k - 1\n﹍﹍﹍﹍counter++\n﹍﹍﹍﹍console print \" count so far: \" + counter\n\nconsole print \" total count: \" + counter",
    " o/j: 5 o/k: 5 i/j: 4 i/k: 5 count so far: 1 i/j: 4 i/k: 4 count so far: 2 i/j: 4 i/k: 3 count so far: 3 i/j: 4 i/k: 2 count so far: 4 i/j: 4 i/k: 1 count so far: 5 i/j: 4 i/k: 0 o/j: 4 o/k: 5 i/j: 3 i/k: 5 count so far: 6 i/j: 3 i/k: 4 count so far: 7 i/j: 3 i/k: 3 count so far: 8 i/j: 3 i/k: 2 count so far: 9 i/j: 3 i/k: 1 count so far: 10 i/j: 3 i/k: 0 o/j: 3 o/k: 5 i/j: 2 i/k: 5 count so far: 11 i/j: 2 i/k: 4 count so far: 12 i/j: 2 i/k: 3 count so far: 13 i/j: 2 i/k: 2 count so far: 14 i/j: 2 i/k: 1 count so far: 15 i/j: 2 i/k: 0 o/j: 2 o/k: 5 i/j: 1 i/k: 5 count so far: 16 i/j: 1 i/k: 4 count so far: 17 i/j: 1 i/k: 3 count so far: 18 i/j: 1 i/k: 2 count so far: 19 i/j: 1 i/k: 1 count so far: 20 i/j: 1 i/k: 0 o/j: 1 o/k: 5 i/j: 0 i/k: 5 count so far: 21 i/j: 0 i/k: 4 count so far: 22 i/j: 0 i/k: 3 count so far: 23 i/j: 0 i/k: 2 count so far: 24 i/j: 0 i/k: 1 count so far: 25 i/j: 0 i/k: 0 o/j: 0 o/k: 5 total count: 25",
    // ---------------------------------------------------------------------------
    // alternate formatting of the above, more C-like
    "a=5\n\nrepeat (forever):\n﹍if a==0:\n﹍﹍done\n﹍else:\n﹍﹍a=a - 1\nconsole print a",
    "0",
    // ---------------------------------------------------------------------------
    "a=5\n\nrepeat 2:\n﹍a=a - 1\nif a==3:\n﹍console print \"yes a is 3\"",
    "yes a is 3",
    // ---------------------------------------------------------------------------
    "a=5\nconsole print a\nconsole print b\nrepeat 2:\n﹍a=a - 1\n﹍b = 0\n﹍c = 0\nconsole print a\nconsole print b\nconsole print c",
    "5nil300",
    // ---------------------------------------------------------------------------
    "'a←5;console print repeat1(if a==0: (done) else: ('a←a - 1))",
    "[object of class \"Done\"]",
    // -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
    "a=5;console print repeat1(if a==0: (done) else: (a=a - 1))",
    "[object of class \"Done\"]",
    // ---------------------------------------------------------------------------
    // "done" stop the execution from within a loop,
    // nothing is executed after them
    "'a←5;repeat1(if a==0: (done; console print 2) else: ('a←a - 1));console print a",
    "0",
    // -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
    "a=5;repeat1(if a==0: (done; console print 2) else: (a=a - 1));console print a",
    "0",
    // ---------------------------------------------------------------------------
    "'a←5;console print repeat1(if a==0: (done with a+1) else: ('a←a - 1))",
    "1",
    // -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
    "a=5;console print repeat1(if a==0: (done with a+1) else: (a=a - 1))",
    "1",
    // ---------------------------------------------------------------------------
    "console print Class",
    "[class \"Class\" (an object of class Class)]",
    // ---------------------------------------------------------------------------
    "'something←3;console print something",
    "3",
    // -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
    "something=3;console print something",
    "3",
    // ---------------------------------------------------------------------------
    // this one creates a truly anonymous class
    "'MyClass←Class new",
    "",
    // -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
    // the "=" infers the name for the new class: MyClass
    // in this case
    "MyClass=Class new",
    "",
    // ---------------------------------------------------------------------------
    "Number answer:(aaa(operandum))by:(console print operandum);1 aaa 1",
    "1",
    // ---------------------------------------------------------------------------
    "'MyClass←Class new;MyClass answer:(printtwo)by:(console print self);'myObject←MyClass new;myObject printtwo",
    "[object of anonymous class]",
    "'MyClass←Class new;MyClass answer:(printtwo)by:(console print @);'myObject←MyClass new;myObject printtwo",
    "[object of anonymous class]",
    // -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
    "MyClass = Class new\nMyClass answer:\n﹍﹍printtwo\n﹍by:\n﹍﹍console print self\nmyObject = MyClass new\nmyObject printtwo",
    "[object of class \"MyClass\"]",
    "MyClass = Class new\nMyClass answer:\n﹍﹍printtwo\n﹍by:\n﹍﹍console print @\nmyObject = MyClass new\nmyObject printtwo",
    "[object of class \"MyClass\"]",
    // ---------------------------------------------------------------------------
    "'false←true;if false: (console print 1) else: (console print 2)",
    "1",
    // -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
    "false=true;if false: (console print 1) else: (console print 2)",
    "1",
    // ---------------------------------------------------------------------------
    "'temp←true;'true←false;'false←temp;if false: (console print 1) else: (console print 2)",
    "1",
    // -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
    "temp=true;true=false;false=temp;if false: (console print 1) else: (console print 2)",
    "1",
    // ---------------------------------------------------------------------------
    "'temp←true;'true←false;'false←temp;if true: (console print 1) else: (console print 2)",
    "2",
    // -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
    "temp=true;true=false;false=temp;if true: (console print 1) else: (console print 2)",
    "2",
    // ---------------------------------------------------------------------------
    "\"world\" = \"Dave\"\nconsole print \"Hello \"\nconsole print \"world\"",
    "Hello Dave",
    // ---------------------------------------------------------------------------
    "'2←10;console print 2",
    "10",
    // -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
    "2=10;console print 2",
    "10",
    // ---------------------------------------------------------------------------
    "3.14=\"pi\";console print 3.14",
    "pi",
    // ---------------------------------------------------------------------------
    "' & ← '; & a←8;console print a",
    "8",
    // -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
    "& = '; & a←8;console print a",
    "8",
    // ---------------------------------------------------------------------------
    "(4*2)times(console print 1)",
    "11111111",
    // ---------------------------------------------------------------------------
    "for k from(1)to(10):(console print k)",
    "12345678910",
    // ---------------------------------------------------------------------------
    "for k from 1 to 10 :(console print k)",
    "12345678910",
    // ---------------------------------------------------------------------------
    "for k from\n﹍﹍﹍1\n﹍to\n﹍﹍﹍10\n﹍﹍:\n﹍﹍﹍console print k\nconsole print \"done\"",
    "12345678910done",
    // ---------------------------------------------------------------------------
    "console print localTemp\nfor k from\n﹍﹍﹍1\n﹍to\n﹍﹍﹍1\n﹍﹍:\n﹍﹍﹍localTemp = \" - local temp\"\n﹍﹍﹍console print localTemp\nconsole print localTemp",
    "nil - local temp - local temp",
    // ---------------------------------------------------------------------------
    "for k from 1 to 1:\n﹍localTemp = \"local temp \"\n﹍console print localTemp\nconsole print localTemp",
    "local temp local temp ",
    // ---------------------------------------------------------------------------
    // the for construct creates an open context, so it can read and
    // write variables from/into the 
    // the loop variable is created inside it so it's
    // keep sealed.
    "j = 1\nconsole print j\nconsole print k\nfor k from 1 to 2:\n﹍j = k\n﹍console print j\n﹍console print k\n﹍l = k\n﹍\nconsole print j\nconsole print k\nconsole print l",
    "1nil11222nil2",
    "j = 1\nconsole print j\nconsole print k\nfor k from 1 to 2:\n﹍j = k\n﹍console print j\n﹍console print k\n﹍l = k\nconsole print j\nconsole print k\nconsole print l",
    "1nil11222nil2",
    // ---------------------------------------------------------------------------
    "8 unintelligibleMessage",
    "! exception: message was not understood: ( unintelligibleMessage )",
    // ---------------------------------------------------------------------------
    "' a ← 5 someUndefinedMessage",
    "! exception: message was not understood: ( someUndefinedMessage )",
    // ---------------------------------------------------------------------------
    "console print \"hello world\"",
    "hello world",
    // ---------------------------------------------------------------------------
    "console print ('(1)+2)",
    "( 1 2 )",
    // ---------------------------------------------------------------------------
    "console print ('(1)+(2+1))",
    "( 1 3 )",
    // ---------------------------------------------------------------------------
    "console print ('()+\"how to enclose something in a list\")",
    "( \"how to enclose something in a list\" )",
    "console print ([]+\"how to enclose something in a list\")",
    "( \"how to enclose something in a list\" )",
    // ---------------------------------------------------------------------------
    // note that the + evaluates
    // its argument, so the passed list
    // is evaluated. If you want to pass
    // a list you need to quote it, see
    // afterwards
    "console print ('(1)+(2))",
    "( 1 2 )",
    // ---------------------------------------------------------------------------
    "console print ('(1)+'(2))",
    "( 1 ( 2 ) )",
    // ---------------------------------------------------------------------------
    "console print ('((1))+2)",
    "( ( 1 ) 2 )",
    // ---------------------------------------------------------------------------
    "console print ('((1))+'(2))",
    "( ( 1 ) ( 2 ) )",
    // ---------------------------------------------------------------------------
    "'myList←List new;console print myList;'myList←myList+2;console print myList",
    "empty message( 2 )",
    // ---------------------------------------------------------------------------
    "'myString←String new;console print myString;'myString←myString+\"Hello \";'myString←myString+\"world\";console print myString",
    "Hello world",
    // ---------------------------------------------------------------------------
    "'MyClass←Class new;MyClass.counter = nil;MyClass answer:(setCounterToTwo)by:(self.counter←2);MyClass answer:(printCounter)by:(console print self.counter);'myObject←MyClass new;myObject printCounter;myObject setCounterToTwo;myObject printCounter;'myObject2←MyClass new;myObject2 printCounter;myObject2 setCounterToTwo;myObject2 printCounter",
    "nil2nil2",
    // -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
    "MyClass = Class new\nMyClass.counter = nil\n\nMyClass answer:\n﹍﹍setCounterToTwo\n﹍by:\n﹍﹍self.counter←2\n\nMyClass answer:\n﹍﹍printCounter\n﹍by:\n﹍﹍console print self.counter\n\nmyObject = MyClass new\nmyObject printCounter\nmyObject setCounterToTwo\nmyObject printCounter\n\nmyObject2 = MyClass new\nmyObject2 printCounter\nmyObject2 setCounterToTwo\nmyObject2 printCounter",
    "nil2nil2",
    // -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
    "MyClass = Class new\nMyClass.counter = nil\n\nMyClass answer:\n﹍﹍setCounterToTwo\n﹍by:\n﹍﹍@counter←2\n\nMyClass answer:\n﹍﹍printCounter\n﹍by:\n﹍﹍console print @counter\n\nmyObject = MyClass new\nmyObject printCounter\nmyObject setCounterToTwo\nmyObject printCounter\n\nmyObject2 = MyClass new\nmyObject2 printCounter\nmyObject2 setCounterToTwo\nmyObject2 printCounter",
    "nil2nil2",
    // ---------------------------------------------------------------------------
    "'MyClass←Class new;MyClass.counter = nil;MyClass answer:(setCounterToTwo)by:(self.counter←2);'myObject←MyClass new;myObject setCounterToTwo;console print myObject's counter",
    "2",
    // ---------------------------------------------------------------------------
    "'MyClass←Class new;MyClass.counter = nil;MyClass answer:(setCounterToTwo)by:(self.counter←2);'myObject←MyClass new;myObject setCounterToTwo;console print myObject.counter",
    "2",
    // -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-

    // dot notation here
    "MyClass = Class new\nMyClass.counter = nil\nMyClass answer:\n﹍﹍setCounterToTwo\n﹍by:\n﹍﹍self.counter = 2\nmyObject = MyClass new\nmyObject setCounterToTwo\nconsole print myObject.counter",
    "2",
    // -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-

    // dot notation here
    "MyClass = Class new\nMyClass.counter = nil\nMyClass answer:\n﹍﹍setCounterToTwo\n﹍by:\n﹍﹍@counter = 2\nmyObject = MyClass new\nmyObject setCounterToTwo\nconsole print myObject.counter",
    "2",
    // ---------------------------------------------------------------------------
    // navigating a little list via dot notation
    "MyClass = Class new\nMyClass.link = nil\n\nmyObject = MyClass new\nmyObject2 = MyClass new\nmyObject3 = MyClass new\nmyObject4 = MyClass new\n\nmyObject.link = myObject2\nmyObject2.link = myObject3\nmyObject3.link = myObject4\nmyObject4.link = \"the end\"\n\nconsole print myObject.link.link.link.link",
    "the end",
    // ---------------------------------------------------------------------------
    "codeToBeRun ='\n﹍counter=2\nconsole print codeToBeRun",
    "( counter = 2 )",
    // ---------------------------------------------------------------------------
    // you can assign arbitrary things to string tokens, even functions
    "\"codeToBeRun\" ='\n﹍counter=2\nconsole print \"codeToBeRun\"",
    "( counter = 2 )",
    // ---------------------------------------------------------------------------
    "my = 1\nlittle = \"hello\"\narray = false\nmyLittleArray = [my, little, array]\nconsole print myLittleArray\nconsole print myLittleArray[1]+1\nconsole print myLittleArray[2]\nif myLittleArray[3]:\n﹍console print \"true!\"\nelse:\n﹍console print \"false!\"",
    "( 1 \"hello\" false )2hellofalse!",
    // ---------------------------------------------------------------------------

    // a token containing a list doesn't cause
    // the list to be run
    "myArray =' (console print 1)\nmyArray",
    "",
    // classic "explicit" eval
    "myArray =' (console print 1)\nmyArray eval",
    "1",
    // ---------------------------------------------------------------------------
    // Closures
    // work with "to" and "answer" and any time a list is quote-assigned:
    // the "code list" is assigned a special "context of assignment"
    // that is looked up when the "context of use" doesn't give a lookup
    // value. This is one can read and write
    // variables that come from the context where the
    // closure was defined.
    // Note that you can read/write variables initialised AFTER the
    // definition of the "code list" i.e. the code list has access
    // to the whole context in which it was defined.
    "to codeToBeRun2:\n﹍op1 = 2\n﹍// this will be the definition context that we'll  \n﹍// stick to the piece of code \"( console print op1 )\"\n﹍codeToBeRun ='\n﹍﹍console print op1\n\nconsole print op1 // -> nil\n\ncodeToBeRun3 = codeToBeRun2\nconsole print codeToBeRun3 // -> ( console print op1 )\n\n// op1 is not defined in the running context but it\n// is defined in the\n// context where ( console print op1 ) was defined\ncodeToBeRun3 eval // -> 2",
    "nil( console print op1 )2",
    // "to" here is defining a "function" with arguments
    "to codeToBeRun2:\n﹍op1 = 2\n﹍// this will be the definition context that we'll  \n﹍// stick to the piece of code \"( console print op1 )\"\n﹍to codeToBeRun:\n﹍﹍﹍doit\n﹍﹍do:\n﹍﹍﹍console print op1\n﹍return codeToBeRun\n\nconsole print op1 // -> nil\n\ncodeToBeRun3 = codeToBeRun2\nconsole print codeToBeRun3 // -> ( console print op1 )\n\n// op1 is not defined in the running context but it\n// is defined in the\n// context where ( console print op1 ) was defined\ncodeToBeRun3 doit // -> 2",
    "nil[object of class \"Class_of_codeToBeRun\"]2",
    // "to" here is defining a "function" without arguments
    "to codeToBeRun2:\n﹍op1 = 2\n﹍// this will be the definition context that we'll  \n﹍// stick to the piece of code \"( console print op1 )\"\n﹍to codeToBeRun:\n﹍﹍console print op1\n\nconsole print op1 // -> nil\n\ncodeToBeRun3 = codeToBeRun2\n\n// op1 is not defined in the running context but it\n// is defined in the\n// context where ( console print op1 ) was defined\ncodeToBeRun3 // -> 2",
    "nil2",
    // note that this is not a demonstration of closures,
    // here simply op1 and op2 are defined
    // in the running context
    "op1 = 2\ncodeToBeRun ='\n﹍console print (op1+op2)\nop2 = 3\ncodeToBeRun eval\nop2 = 6\ncodeToBeRun eval\nop1 = 1000\ncodeToBeRun eval",
    "581006",
    // note that this is not a demonstration of closures,
    // here simply op1 is defined
    // in the running context
    "op1 = 2\ncodeToBeRun ='\n﹍op1++\n﹍console print op1\ncodeToBeRun eval\nconsole print op1",
    "33",
    // note that this is not a demonstration of closures,
    // here simply op1 and op2 are defined
    // in the running context
    // "eval" opens up the current context
    // so both op1 and op2 get modified
    "op1 = 2\ncodeToBeRun ='\n﹍op1++\n﹍op2 = 1\n﹍console print op1\n﹍console print op2\ncodeToBeRun eval\nconsole print op1\nconsole print op2",
    "3131",
    // note that this is not a demonstration of closures,
    // here simply op1 is defined
    // in the running context
    "op1 = 2\nto codeToBeRun:\n﹍op1++\n﹍console print op1\ncodeToBeRun\nconsole print op1",
    "33",
    // note that this is not a demonstration of closures,
    // here simply op1 is defined
    // in the running context
    "op1 = 2\nNumber answer:\n﹍﹍aFunction\n﹍by:\n﹍﹍op1++\n﹍﹍console print op1\n0 aFunction\nconsole print op1",
    "33",
    // note that this is not a demonstration of closures,
    // here simply op1 and op2 are defined
    // in the running context
    "op1 = 2\nto codeToBeRun:\n﹍op1++\n﹍op2 = 1\n﹍console print op1\n﹍console print op2\ncodeToBeRun\nconsole print op1\nconsole print op2",
    "313nil",
    // note that this is not a demonstration of closures,
    // here simply op1 and op2 are defined
    // in the running context
    "op1 = 2\nNumber answer:\n﹍﹍aFunction\n﹍by:\n﹍﹍op1++\n﹍﹍op2 = 1\n﹍﹍console print op1\n﹍﹍console print op2\n0 aFunction\nconsole print op1\nconsole print op2",
    "313nil",
    // ---------------------------------------------------------------------------
    "codeToBeRun ='\n﹍self's counter=2\n\nMyClass=Class new\nMyClass.counter = nil\nMyClass answer:\n﹍﹍setCounterToTwo\n﹍by:\n﹍﹍codeToBeRun eval\nmyObject=MyClass new\nmyObject setCounterToTwo\nconsole print myObject's counter\nmyObject's counter = 3\nconsole print myObject's counter",
    "23",
    // ---------------------------------------------------------------------------
    "codeToBeRun ='\n﹍self.counter=2\n\nMyClass=Class new\nMyClass.counter = nil\nMyClass answer:\n﹍﹍setCounterToTwo\n﹍by:\n﹍﹍codeToBeRun eval\nmyObject=MyClass new\nmyObject setCounterToTwo\nconsole print myObject.counter\nmyObject.counter = 3\nconsole print myObject.counter",
    "23",
    // ---------------------------------------------------------------------------
    "codeToBeRun ='\n﹍self's counter=2\n\nMyClass=Class new\nMyClass.counter = nil\nMyClass answer:\n﹍﹍setCounterToTwo\n﹍by:\n﹍﹍codeToBeRun eval\nmyObject=MyClass new\nmyObject setCounterToTwo\nconsole print myObject's counter\nin\n﹍﹍myObject\n﹍do\n﹍﹍self's counter = 3\nconsole print myObject's counter\nconsole print myObject's counter+myObject's counter",
    "236",
    // ---------------------------------------------------------------------------
    "codeToBeRun ='\n﹍self.counter=2\n\nMyClass=Class new\nMyClass.counter = nil\nMyClass answer:\n﹍﹍setCounterToTwo\n﹍by:\n﹍﹍codeToBeRun eval\nmyObject=MyClass new\nmyObject setCounterToTwo\nconsole print myObject.counter\nin\n﹍﹍myObject\n﹍do\n﹍﹍self.counter = 3\nconsole print myObject.counter\nconsole print myObject.counter+myObject.counter",
    "236",
    // ---------------------------------------------------------------------------
    "codeToBeRun ='\n﹍@counter=2\n\nMyClass=Class new\nMyClass.counter = nil\nMyClass answer:\n﹍﹍setCounterToTwo\n﹍by:\n﹍﹍codeToBeRun eval\nmyObject=MyClass new\nmyObject setCounterToTwo\nconsole print myObject.counter\nin\n﹍﹍myObject\n﹍do\n﹍﹍@counter = 3\nconsole print myObject.counter\nconsole print myObject.counter+myObject.counter",
    "236",
    // ---------------------------------------------------------------------------
    // note that while the dot notation can be used to access instance variables,
    // and in theory it could be used to invoke methods without
    // parameters, it can't be used to invoke methods with parameters
    // (you can just omit the dot and it works though)
    "MyClass = Class new\nMyClass answer:\n﹍﹍printtwo (argument)\n﹍by:\n﹍﹍console print argument\nmyObject = MyClass new\nmyObject printtwo \"hello\"",
    "hello",
    // -.-.-.-.-.-.-.-.--.-             vs.             .--.-.-.--.-.-.-.-.-.-.-.-
    "MyClass = Class new\nMyClass answer:\n﹍﹍printtwo (argument)\n﹍by:\n﹍﹍console print argument\nmyObject = MyClass new\nmyObject.printtwo \"hello\"",
    "! exception: message was not understood: ( TOKEN:hello )",
    // ---------------------------------------------------------------------------
    // FLTO
    "to sayHello: (withName (name)) do: (console print \"Hello \";console print name); sayHello withName \"Dave\"",
    "Hello Dave",
    // -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
    // FLTO
    "to sayHello:\n﹍﹍withName (name)\n﹍do:\n﹍﹍console print \"Hello \"; console print name\nsayHello withName \"Dave\"",
    "Hello Dave",
    // -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
    // FLTO
    "to sayHello:\n﹍﹍withName (name)\n﹍do:\n﹍﹍console print \"Hello \"\n﹍﹍console print name\nsayHello withName \"Dave\"",
    "Hello Dave",
    // ---------------------------------------------------------------------------
    // FLTO
    "to sayHello2: ((name)) do: (console print \"HELLO \"; console print name); sayHello2 \"Dave\"",
    "HELLO Dave",
    // -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
    "to sayHello2:\n﹍﹍(name)\n﹍do:\n﹍﹍console print \"HELLO \"\n﹍﹍console print name\nsayHello2 \"Dave\"",
    "HELLO Dave",
    // ---------------------------------------------------------------------------
    // FLTO with no signature
    "to testingReturn:\n﹍console print \"start\"",
    "",
    "to testingReturn:\n﹍console print \"start\"\ntestingReturn",
    "start",
    // ---------------------------------------------------------------------------
    // FLTO you can add multiple methods to a class/object
    // created with "to"
    "to anotherFunc:\n﹍﹍withAParameter\n﹍do:\n﹍﹍console print \"running with a param.\"\n\nanotherFunc withAParameter\n\nto anotherFunc:\n﹍console print \"running without params.\"\n\nanotherFunc\nanotherFunc withAParameter\n",
    "running with a param.running without params.running with a param.",
    // ---------------------------------------------------------------------------
    // lists that get evaluated but cannot be evaluated fully
    // ---------------------------------------------------------------------------
    "a = (1 2 3)",
    "! exception: message was not understood: ( 2 3 )",
    "a = (\"hello\" \"world\")",
    "! exception: message was not understood: ( TOKEN:world )",
    "myList = (\"Hello \" \"Dave \" \"my \" \"dear \" \"friend\")\n1",
    "! exception: message was not understood: ( TOKEN:Dave  TOKEN:my  TOKEN:dear  TOKEN:friend )",
    // ---------------------------------------------------------------------------
    "'( \"Hello \" \"Dave \" \"my \" \"dear \" \"friend\") each word do (console print word eval)",
    "Hello Dave my dear friend",
    // ---------------------------------------------------------------------------

    // this was working before I decided to eliminate
    // all empty lines, because it's difficult to make
    // them meaningful in this way, since they are completely
    // invisible. There is still a way to do something
    // analogous to this, see example
    // below.
    "for each word in:\n﹍﹍\n﹍do:\n﹍﹍console print word\nconsole print \"the end.\"",
    "! exception: message was not understood: ( each word in : ( do : ( console print word ) ) )",
    "for each word in: '() do:\n﹍console print word\nconsole print \"the end.\"",
    "the end.",
    "for each word in: [] do:\n﹍console print word\nconsole print \"the end.\"",
    "the end.",
    "for each word in: ([]) do:\n﹍console print word\nconsole print \"the end.\"",
    "the end.",
    // ---------------------------------------------------------------------------
    "for each word in: '(1 + 1) do:\n﹍console print word",
    "1+1",
    "for each word in:\n﹍﹍[1,'+,1]\n﹍do:\n﹍﹍console print word",
    "1+1",
    // ---------------------------------------------------------------------------
    // since here 1+1 gives us a result that is a number, we throw
    // an error. note that we could interpret it as a list, but it
    // would become very confusing to understand where to use
    // a list explicitly and when not.
    "for each word in:\n﹍﹍1 + 1\n﹍do:\n﹍﹍console print word",
    "! exception: for...each expects a list",
    // ---------------------------------------------------------------------------
    "for each word in: [\"Hello \",\"Dave \",\"my \",\"dear \",\"friend\"] do:\n﹍﹍console print word",
    "Hello Dave my dear friend",
    "for each word in:\n﹍﹍[\"Hello \",\"Dave \",\"my \",\"dear \",\"friend\"]\n﹍do:\n﹍﹍console print word",
    "Hello Dave my dear friend",
    "myList = [\"Hello \",\"Dave \",\"my \",\"dear \",\"friend\"]\nfor each word in:\n﹍﹍myList\n﹍do:\n﹍﹍console print word",
    "Hello Dave my dear friend",
    // ---------------------------------------------------------------------------
    "for each word in: '(\"Hello \" \"Dave \" \"my \" \"dear \" \"friend\") do:\n﹍console print word eval",
    "Hello Dave my dear friend",
    // ---------------------------------------------------------------------------
    "for each word in:\n﹍﹍'(\\\n﹍﹍\"Hello \"\\\n﹍﹍\"Dave \"\\\n﹍﹍\"my \"\\\n﹍﹍\"dear \"\\\n﹍﹍\"friend\"\\\n﹍﹍)\n﹍do:\n﹍﹍console print word eval",
    "Hello Dave my dear friend",
    "for each word in:\n﹍﹍[\\\n﹍﹍\"Hello \",\\\n﹍﹍\"Dave \",\\\n﹍﹍\"my \",\\\n﹍﹍\"dear \",\\\n﹍﹍\"friend\"\\\n﹍﹍]\n﹍do:\n﹍﹍console print word",
    "Hello Dave my dear friend",
    "for each word in: '\n﹍﹍\"Hello \"\\\n﹍﹍\"Dave \"\\\n﹍﹍\"my \"\\\n﹍﹍\"dear \"\\\n﹍﹍\"friend\"\n﹍do:\n﹍﹍console print word eval",
    "Hello Dave my dear friend",
    // ---------------------------------------------------------------------------
    "codeToBeRun ='\n﹍console print word eval\nfor each word in:\n﹍﹍'(\"Hello \" \"Dave \" \"my \" \"dear \" \"friend\")\n﹍do:\n﹍﹍codeToBeRun eval",
    "Hello Dave my dear friend",
    "codeToBeRun ='\n﹍console print word\nfor each word in:\n﹍﹍[\"Hello \",\"Dave \",\"my \",\"dear \",\"friend\"]\n﹍do:\n﹍﹍codeToBeRun eval",
    "Hello Dave my dear friend",
    // ---------------------------------------------------------------------------
    "codeToBeRun ='\n﹍console print word eval\nfor each word in:\n﹍﹍// this plus is the list adding an element (a string in this case)\n﹍﹍'(\"Hello \" \"Dave \") + \"my \" + \"dear \" + \"friend\"\n﹍do:\n﹍﹍codeToBeRun eval",
    "Hello Dave my dear friend",
    "codeToBeRun ='\n﹍console print word\nfor each word in:\n﹍﹍// this plus is the list adding an element (a string in this case)\n﹍﹍[\"Hello \",\"Dave \"] + \"my \" + \"dear \" + \"friend\"\n﹍do:\n﹍﹍codeToBeRun eval",
    "Hello Dave my dear friend",
    // ---------------------------------------------------------------------------
    "codeToBeRun ='\n﹍console print word eval\nmyList =' (\"Hello \" \"Dave \" \"my \" \"dear \" \"friend\")\nfor each word in:\n﹍﹍myList\n﹍do:\n﹍﹍codeToBeRun eval",
    "Hello Dave my dear friend",
    "codeToBeRun ='\n﹍console print word\nmyList = [\"Hello \",\"Dave \",\"my \",\"dear \",\"friend\"]\nfor each word in:\n﹍﹍myList\n﹍do:\n﹍﹍codeToBeRun eval",
    "Hello Dave my dear friend",
    // ---------------------------------------------------------------------------
    "codeToBeRun ='\n﹍console print word eval\nmyList = '(\"Hello \" \"Dave \") + \"my \" + \"dear \" + \"friend\"\nfor each word in:\n﹍﹍myList\n﹍do:\n﹍﹍codeToBeRun eval",
    "Hello Dave my dear friend",
    "codeToBeRun ='\n﹍console print word\nmyList = [\"Hello \",\"Dave \"] + \"my \" + \"dear \" + \"friend\"\nfor each word in:\n﹍﹍myList\n﹍do:\n﹍﹍codeToBeRun eval",
    "Hello Dave my dear friend",
    // ---------------------------------------------------------------------------
    "codeToBeRun ='\n﹍console print word eval\nmyList = '(\"Hello \" \"Dave \")\nmyString = \"my dear friend\"\nfor each word in:\n﹍﹍myList + myString\n﹍do:\n﹍﹍codeToBeRun eval",
    "Hello Dave my dear friend",
    "codeToBeRun ='\n﹍console print word\nmyList = [\"Hello \",\"Dave \"]\nmyString = \"my dear friend\"\nfor each word in:\n﹍﹍myList + myString\n﹍do:\n﹍﹍codeToBeRun eval",
    "Hello Dave my dear friend",
    // ---------------------------------------------------------------------------
    "codeToBeRun ='\n﹍console print word eval\nmyList ='\n﹍\"Hello \" \"Dave \" \"my \" \"dear \" \"friend\"\nfor each word in:\n﹍﹍myList\n﹍do:\n﹍﹍codeToBeRun eval",
    "Hello Dave my dear friend",
    "codeToBeRun ='\n﹍console print word\nmyList = [\"Hello \",\"Dave \",\"my \",\"dear \",\"friend\"]\nfor each word in:\n﹍﹍myList\n﹍do:\n﹍﹍codeToBeRun eval",
    "Hello Dave my dear friend",
    // ---------------------------------------------------------------------------
    "codeToBeRun =:\n﹍console print word eval\nmyList =:\n﹍\"Hello \" \"Dave \" \"my \" \"dear \" \"friend\"\nfor each word in:\n﹍﹍myList\n﹍do:\n﹍﹍codeToBeRun eval",
    "Hello Dave my dear friend",
    // ---------------------------------------------------------------------------
    // in this case "myList =..." causes an evaluation which ends up returning just
    // "Hello "
    "codeToBeRun ='\n﹍console print word\nmyList = (\"Hello \" \"Dave \" \"my \" \"dear \" \"friend\")\nconsole print \"myList: \" + myList",
    "! exception: message was not understood: ( TOKEN:Dave  TOKEN:my  TOKEN:dear  TOKEN:friend )",
    // ---------------------------------------------------------------------------
    // in this case "myList" ends up being a wrapped list i.e. ((wrapped))
    // so, when the right-side is evaluated, it ends up being the normal
    // un-wrapped contents, so it all works out without the ' after the =
    "codeToBeRun ='\n﹍console print word eval\nmyList =\n﹍'(\"Hello \" \"Dave \" \"my \" \"dear \" \"friend\")\nfor each word in:\n﹍﹍myList\n﹍do:\n﹍﹍codeToBeRun eval",
    "Hello Dave my dear friend",
    "codeToBeRun ='\n﹍console print word\nmyList =\n﹍[\"Hello \",\"Dave \",\"my \",\"dear \",\"friend\"]\nfor each word in:\n﹍﹍myList\n﹍do:\n﹍﹍codeToBeRun eval",
    "Hello Dave my dear friend",
    // ---------------------------------------------------------------------------
    "codeToBeRun ='\n﹍console print word eval\nmyList = '\n﹍\"Hello \" \"Dave \" \"my \" \"dear \" \"friend\"\nfor each word in:\n﹍﹍myList\n﹍do:\n﹍﹍codeToBeRun eval",
    "Hello Dave my dear friend",
    // ---------------------------------------------------------------------------
    "acc = 0\nfor each number in:\n﹍﹍'(1 2 3 4)\n﹍do:\n﹍﹍acc += number eval\nconsole print acc",
    "10",
    "acc = 0\nfor each number in:\n﹍﹍[1,2,3,4]\n﹍do:\n﹍﹍acc += number\nconsole print acc",
    "10",
    // ---------------------------------------------------------------------------
    "acc = 0\nfor each number in: '\n﹍﹍1 2 3 4\n﹍do:\n﹍﹍acc += number eval\nconsole print acc",
    "10",
    // ---------------------------------------------------------------------------
    "codeToBeRun ='\n﹍console print word\nmyList = 9\nfor each word in:\n﹍﹍myList\n﹍do:\n﹍﹍codeToBeRun eval",
    "! exception: for...each expects a list",
    // ---------------------------------------------------------------------------
    "'someException ← Exception new initWith \"my custom error\"; console print someException",
    "my custom error",
    // ---------------------------------------------------------------------------
    // wrong way to raise exceptions, they must be thrown
    "'someException ← Exception new initWith \"my custom error\";try: ( console print 1; someException )catch someException: ( console print \" caught the error I wanted\" )",
    "1",
    // ---------------------------------------------------------------------------
    // wrong way to raise exceptions, they must be thrown
    "'someException ← Exception new initWith \"my custom error\";'someOtherException ← Exception new initWith \"my other custom error\";try: ( console print 1; someException )catch someException: ( console print \" caught the error I wanted\" )",
    "1",
    // ---------------------------------------------------------------------------
    // wrong way to raise exceptions, they must be thrown
    "'someException ← Exception new initWith \"my custom error\";'someOtherException ← Exception new initWith \"my other custom error\";try: ( console print 1; someException )catch someOtherException: ( console print \" caught the error I wanted\" )",
    "1",
    // ---------------------------------------------------------------------------
    // thrown exception, note how the statement after the throw is not executed
    "'someException ← Exception new initWith \"my custom error\";try: ( console print 1; throw someException; console print 2 )catch someException: ( console print \" caught the error I wanted\" )",
    "1 caught the error I wanted",
    // ---------------------------------------------------------------------------
    "someException = Exception new initWith \"my custom error\"\ntry:\n﹍console print 1\n﹍throw someException\n﹍console print 2\ncatch someException:\n﹍console print \" caught the error I wanted\"\nconsole print \". the end.\"",
    "1 caught the error I wanted. the end.",
    // ---------------------------------------------------------------------------
    // thrown exception, note how the statement after the throw is not executed
    "'someException ← Exception new initWith \"my custom error\";'someOtherException ← Exception new initWith \"my other custom error\";try: ( console print 1; throw someException; console print 2 )catch someException: ( console print \" caught the error I wanted\" )",
    "1 caught the error I wanted",
    // ---------------------------------------------------------------------------
    // thrown exception, note how the statement after the throw is not executed
    "someException = Exception new initWith \"my custom error\"\nsomeOtherException = Exception new initWith \"my other custom error\"\ntry:\n﹍console print 1\n﹍throw someException\n﹍console print 2\ncatch someException:\n﹍console print \" caught the error I wanted\"\nconsole print \". the end.\"",
    "1 caught the error I wanted. the end.",
    // ---------------------------------------------------------------------------
    // thrown exception, note how the statement after the throw is not executed
    "'someException ← Exception new initWith \"my custom error\";'someOtherException ← Exception new initWith \"my other custom error\";try: ( console print 1; throw someException; console print 2 )catch someOtherException: ( console print \" caught the error I wanted\" )",
    "1! exception: my custom error",
    // ---------------------------------------------------------------------------
    // thrown exception, note how the statement after the throw is not executed
    // also note that the thrown exceptions is thrown right up to
    // the workspace, the ". the end." is not printed
    "someException = Exception new initWith \"my custom error\"\nsomeOtherException = Exception new initWith \"my other custom error\"\ntry:\n﹍console print 1\n﹍throw someException\n﹍console print 2\ncatch someOtherException:\n﹍console print \" caught the error I wanted\"\nconsole print \". the end.\"  ",
    "1! exception: my custom error",
    // ---------------------------------------------------------------------------
    // thrown exception, note how the statement after the throw is not executed
    "'someException ← Exception new initWith \"my custom error\";'someOtherException ← Exception new initWith \"my other custom error\";try: ( console print 1; throw someOtherException; console print 2 )catch someOtherException: ( console print \" caught the error the first time around\")catch someException: ( console print \" caught the error the second time around\")",
    "1 caught the error the first time around",
    // ---------------------------------------------------------------------------
    "someException = Exception new initWith \"my custom error\"\nsomeOtherException = Exception new initWith \"my other custom error\"\ntry:\n﹍console print 1\n﹍throw someOtherException\n﹍console print 2\ncatch someOtherException:\n﹍console print \" caught the error the first time around\"\ncatch someException:\n﹍console print \" caught the error the second time around\"\nconsole print \". the end.\"",
    "1 caught the error the first time around. the end.",
    // ---------------------------------------------------------------------------
    "'someException ← Exception new initWith \"my custom error\";'someOtherException ← Exception new initWith \"my other custom error\";try: ( console print 1; throw someException; console print 2 )catch someOtherException: ( console print \" caught the error the first time around\")catch someException: ( console print \" caught the error the second time around\")",
    "1 caught the error the second time around",
    // ---------------------------------------------------------------------------
    "someException = Exception new initWith \"my custom error\"\nsomeOtherException = Exception new initWith \"my other custom error\"\ntry:\n﹍console print 1\n﹍throw someException\n﹍console print 2\ncatch someOtherException:\n﹍console print \" caught the error the first time around\"\ncatch someException:\n﹍console print \" caught the error the second time around\"\nconsole print \". the end.\"",
    "1 caught the error the second time around. the end.",
    // ---------------------------------------------------------------------------
    // catch-all case 1
    "'someException ← Exception new initWith \"my custom error\";'someOtherException ← Exception new initWith \"my other custom error\";try: ( console print 1; throw someOtherException; console print 2 )catch someOtherException: ( console print \" caught the error the first time around\")catch someException: ( console print \" caught the error the second time around\")catch all: (console print \" catch all branch\")",
    "1 caught the error the first time around",
    // ---------------------------------------------------------------------------
    "someException = Exception new initWith \"my custom error\"\nsomeOtherException = Exception new initWith \"my other custom error\"\ntry:\n﹍console print 1\n﹍throw someOtherException\n﹍console print 2\ncatch someOtherException:\n﹍console print \" caught the error the first time around\"\ncatch someException:\n﹍console print \" caught the error the second time around\"\ncatch all:\n﹍console print \" catch all branch\"\nconsole print \". the end.\"",
    "1 caught the error the first time around. the end.",
    // ---------------------------------------------------------------------------
    // catch-all case 2
    "'someException ← Exception new initWith \"my custom error\";'someOtherException ← Exception new initWith \"my other custom error\";try: ( console print 1; throw someException; console print 2 )catch someOtherException: ( console print \" caught the error the first time around\")catch someException: ( console print \" caught the error the second time around\")catch all: (console print \" catch all branch\")",
    "1 caught the error the second time around",
    // ---------------------------------------------------------------------------
    "someException = Exception new initWith \"my custom error\"\nsomeOtherException = Exception new initWith \"my other custom error\"\ntry:\n﹍console print 1\n﹍throw someException\n﹍console print 2\ncatch someOtherException:\n﹍console print \" caught the error the first time around\"\ncatch someException:\n﹍console print \" caught the error the second time around\"\ncatch all:\n﹍console print \" catch all branch\"\nconsole print \". the end.\"",
    "1 caught the error the second time around. the end.",
    // ---------------------------------------------------------------------------
    // catch-all case 3
    "'someException ← Exception new initWith \"my custom error\";'someOtherException ← Exception new initWith \"my other custom error\";'yetAnotherException ← Exception new initWith \"another custom error that is only caught by the catch all branch\";try: ( console print 1; throw yetAnotherException; console print 2 )catch someOtherException: ( console print \" caught the error the first time around\")catch someException: ( console print \" caught the error the second time around\")catch all: (console print \" catch all branch\")",
    "1 catch all branch",
    // ---------------------------------------------------------------------------
    "someException = Exception new initWith \"my custom error\"\nsomeOtherException = Exception new initWith \"my other custom error\"\nyetAnotherException = Exception new initWith \"another custom error that is only caught by the catch all branch\"\ntry:\n﹍console print 1\n﹍throw yetAnotherException\n﹍console print 2\ncatch someOtherException:\n﹍console print \" caught the error the first time around\"\ncatch someException:\n﹍console print \" caught the error the second time around\"\ncatch all:\n﹍console print \" catch all branch\"\nconsole print \". the end.\"",
    "1 catch all branch. the end.",
    // ---------------------------------------------------------------------------
    "foo = 3\nthings =' ()\nthings = things+3\nthings = things+\"hello\"\nconsole print things",
    "( 3 \"hello\" )",
    // ---------------------------------------------------------------------------
    "myList =' (\"Hello \" \"Dave \" \"my \" \"dear \" \"friend\")\nconsole print myList[1] eval\nconsole print myList[1+1+1] eval",
    "Hello my ",
    "myList = [\"Hello \",\"Dave \",\"my \",\"dear \",\"friend\"]\nconsole print myList[1]\nconsole print myList[1+1+1]",
    "Hello my ",
    // ---------------------------------------------------------------------------
    "myList =' (\"Hello \" \"Dave \" \"my \" \"dear \" \"friend\")\n// the list contains tokens, to make it\n// contain strings instead, we need to\n// evaluate each token.\nmyList[1] = myList[1] eval\nmyList[1+1] = myList[1+1] eval\nmyList[1+1+1] = \"oh \"\nmyList[1+1+1+1] = myList[1+1+1+1] eval\nmyList[1+1+1+1+1] = myList[1+1+1+1+1] eval\nconsole print myList",
    "( \"Hello \" \"Dave \" \"oh \" \"dear \" \"friend\" )",
    "myList = [\"Hello \",\"Dave \",\"my \",\"dear \",\"friend\"]\nmyList[1+1+1] = \"oh \"\nconsole print myList",
    "( \"Hello \" \"Dave \" \"oh \" \"dear \" \"friend\" )",
    // ---------------------------------------------------------------------------
    "numbers =' (9 4 3 5 7)\nmyList = [\"Hello \",\"Dave \",\"my \",\"dear \",\"friend\"]\n// we need to evaluate the TOKEN 3 into the number 3\nmyList[numbers[1+1+1] eval] = \"oh \"\nconsole print myList",
    "( \"Hello \" \"Dave \" \"oh \" \"dear \" \"friend\" )",
    // ---------------------------------------------------------------------------
    "numbers =' (9 3 2 5 7)\nconsole print numbers[1] eval + numbers[2] eval",
    "12",
    "numbers = [9,3,2,5,7]\nconsole print numbers[1]+numbers[2]",
    "12",
    // ---------------------------------------------------------------------------
    "numbers =' (9 4 3 5 7)\nmyList = [\"Hello \",\"Dave \",[\"oh \",\"so \"],\"dear \",\"friend\"]\nconsole print myList[numbers[3] eval]",
    "( \"oh \" \"so \" )",
    // ---------------------------------------------------------------------------
    "MyClass = Class new\nmyObject = MyClass new\nconsole print myObject.someField\nconsole print myObject.someOtherField\nmyObject.someField =' (9 3 15 5 7)\nmyObject.someField[1+1+1] = 1+1+1\nmyObject.someOtherField = [\"Hello \",\"Dave \",[\"oh \",\"so \"],\"dear \",\"friend\"]\nconsole print myObject.someOtherField[myObject.someField[1+1+1] eval]",
    "nilnil( \"oh \" \"so \" )",
    // ---------------------------------------------------------------------------
    // "functions" in fields, and having them to run when they are
    // accessed
    "to rocket:\n﹍﹍with param (withAParameter)\n﹍do:\n﹍﹍console print \" running with param \" + withAParameter\n\nMyClass = Class new\nmyObject = MyClass new\n\nmyObject.🚀 = rocket\nmyObject.🚀 with param 2\n",
    " running with param 2",
    "MyClass = Class new\nmyObject = MyClass new\n\nmyObject.🚀 = to rocket:\n﹍console print \" running without param!\"\n\nmyObject.🚀",
    " running without param!",
    // ---------------------------------------------------------------------------
    // "functions" in lists, and having them to run when they are
    // accessed
    "myList = []\nmyList[1] = to rocket:\n﹍﹍with param (withAParameter)\n﹍do:\n﹍﹍console print \" running with param \" + withAParameter\nmyList[1] with param 2",
    " running with param 2",
    "myList = []\nmyList[1] = to rocket:\n﹍console print \" running without param!\"",
    "",
    "myList = []\nmyList[1] = to rocket:\n﹍console print \" running without param!\"\n\nmyList[1]",
    " running without param!",
    // ---------------------------------------------------------------------------
    "numbers =' (9 4 3 5 7)\nmyList = [\"Hello \",\"Dave \",[\"oh \",\"so \"],\"dear \",\"friend\"]\nconsole print myList[numbers[1+1+1] eval][0+1+1]",
    "so ",
    // ---------------------------------------------------------------------------
    "things =' (false true)\nconsole print things[1] eval or things[2] eval",
    "true",
    "things = [false,true]\nconsole print things[1] or things[2]",
    "true",
    // ---------------------------------------------------------------------------
    "foo = 3\nthings =' (foo bar 2)\nconsole print things[1] eval\nconsole print things[2] eval\nconsole print things[3] eval",
    "3nil2",
    "foo = 3\nthings = [foo,bar,2]\nconsole print things[1]\nconsole print things[2]\nconsole print things[3]",
    "3nil2",
    // ---------------------------------------------------------------------------
    "foo = 3\nthings =' (foo bar 2)\nconsole print things",
    "( foo bar 2 )",
    // note how "foo" evaluates to 3
    // and "bar" evaluates to nil
    // when printing the whole list when
    // it's defined via array literal
    // notation
    "foo = 3\nthings = [foo,bar,2]\nconsole print things",
    "( 3 nil 2 )",
    // ---------------------------------------------------------------------------
    "things1 =' (my little list)\nthings2 = things1\nconsole print things1\nconsole print things2\nthings1[1] = 'your\nthings2[2] = 'big\nconsole print things1\nconsole print things2\nthings1 = \" no more a list \"\nconsole print things1\nconsole print things2",
    "( my little list )( my little list )( your big list )( your big list ) no more a list ( your big list )",
    // ---------------------------------------------------------------------------
    // ... an extra line (extra ;) at the end of user-defined methods
    // means that a new receiver is mandated. Affects whether a particular
    // method "returns" something or not. Not returning anything is useful
    // (for example for user made control structures), because this way
    // they can be immediately followed by any other statement without
    // the obligation of having to chain with them.
    "MyClass = Class new\nMyClass answer:\n﹍﹍getYourself (param)\n﹍by:\n﹍﹍param\nmyObject = MyClass new\nmyObject getYourself\n﹍﹍2\n﹍postfixPrint",
    "2",
    "MyClass = Class new\nMyClass answer:\n﹍﹍getYourself (param)\n﹍by:\n﹍﹍param\nmyObject = MyClass new\nmyObject getYourself\n﹍﹍2\n﹍console print 1",
    "! exception: message was not understood: ( console print 1 )",
    // careful! here is the ...3 postfixPrint that ends up
    // running!
    "MyClass = Class new\nMyClass answer:\n﹍﹍getYourself (param)\n﹍by:\n﹍﹍param\nmyObject = MyClass new\nmyObject getYourself 3 postfixPrint",
    "3",
    "MyClass = Class new\nMyClass answer:\n﹍﹍getYourself (param)\n﹍by:\n﹍﹍param\nmyObject = MyClass new\n(myObject getYourself 3) postfixPrint",
    "3",
    "MyClass = Class new\nMyClass answer:\n﹍﹍getYourself (param)\n﹍by:\n﹍﹍param\nmyObject = MyClass new\nmyObject getYourself 3\nconsole print 1",
    "1",
    // ---------------------------------------------------------------------------
    "MyClass = Class new\nMyClass answer:\n﹍﹍whenNew\n﹍by:\n﹍﹍console print \"hey I'm new!\"\n﹍﹍self\nmyObject = MyClass new\nconsole print \" ...done!\"",
    "hey I'm new! ...done!",
    "MyClass = Class new\nMyClass answer:\n﹍﹍whenNew\n﹍by:\n﹍﹍console print \"hey I'm new!\"\n﹍﹍@\nmyObject = MyClass new\nconsole print \" ...done!\"",
    "hey I'm new! ...done!",
    // ---------------------------------------------------------------------------
    "MyClass = Class new\nMyClass answer:\n﹍﹍whenNew\n﹍by:\n﹍﹍2\n﹍﹍self\nmyObject = MyClass new\nconsole print 1",
    "1",
    "MyClass = Class new\nMyClass answer:\n﹍﹍whenNew\n﹍by:\n﹍﹍2\n﹍﹍@\nmyObject = MyClass new\nconsole print 1",
    "1",
    // ---------------------------------------------------------------------------
    // ooops in this case the "whenNew" returned an
    // integer and we assign that to the new object!
    // in this case it's an error, but it can be used
    // for the factory pattern to construct other things
    "MyClass = Class new\nMyClass answer:\n﹍﹍whenNew\n﹍by:\n﹍﹍2\nmyObject = MyClass new\nconsole print myObject",
    "2",
    // ---------------------------------------------------------------------------
    "MyClass = Class new\nMyClass answer:\n﹍﹍whenNew\n﹍by:\n﹍﹍console print \"hey I'm new!\"\n﹍﹍self\nMyClass answer:\n﹍﹍initWith (param)\n﹍by:\n﹍﹍console print param\n﹍﹍self\nmyObject = MyClass new initWith \" hello again! I am... \"\nconsole print myObject",
    "hey I'm new! hello again! I am... [object of class \"MyClass\"]",
    "MyClass = Class new\nMyClass answer:\n﹍﹍whenNew\n﹍by:\n﹍﹍console print \"hey I'm new!\"\n﹍﹍@\nMyClass answer:\n﹍﹍initWith (param)\n﹍by:\n﹍﹍console print param\n﹍﹍@\nmyObject = MyClass new initWith \" hello again! I am... \"\nconsole print myObject",
    "hey I'm new! hello again! I am... [object of class \"MyClass\"]",
    // ---------------------------------------------------------------------------
    "// a comment here\nMyClass = Class new\nMyClass answer:\n﹍﹍whenNew\n// another comment here\n﹍by:\n﹍﹍2\nmyObject = MyClass new\nconsole print myObject",
    "2",
    // ---------------------------------------------------------------------------
    // handling extra indentation
    // ---------------------------------------------------------------------------
    "MyClass = Class new\nMyClass answer:\n﹍﹍printtwo (argument)\n﹍by:\n﹍﹍console print argument\nmyObject = MyClass new\nmyObject printtwo \"hello\"",
    "hello",
    // ---------------------------------------------------------------------------
    "MyClass = Class new\nMyClass answer:\n﹍﹍﹍﹍printthree (argument)\n﹍by:\n﹍﹍﹍﹍console print argument\nmyObject = MyClass new\nmyObject printthree \"hello\"",
    "hello",
    // ---------------------------------------------------------------------------
    // unclear why you'd do this but it works
    "MyClass = Class new\nMyClass answer:\n﹍﹍﹍﹍﹍﹍﹍﹍﹍printthree (argument)\n﹍by:\n﹍﹍﹍﹍console print argument\nmyObject = MyClass new\nmyObject printthree \"hello\"",
    "hello",
    // ---------------------------------------------------------------------------
    // unclear why you'd do this but it works
    "MyClass = Class new\nMyClass answer:\n﹍﹍﹍﹍printthree (argument)\n﹍by:\n﹍﹍﹍﹍﹍﹍﹍﹍﹍console print argument\nmyObject = MyClass new\nmyObject printthree \"hello\"",
    "hello",
    // ---------------------------------------------------------------------------
    "MyClass = Class new\nMyClass answer:\n﹍﹍﹍﹍printthree (argument)\n﹍﹍by:\n﹍﹍﹍﹍console print argument\nmyObject = MyClass new\nmyObject printthree \"hello\"",
    "hello",
    "MyClass = Class new\nMyClass answer:\n﹍﹍﹍printthree (argument)\n﹍by:\n﹍﹍﹍console print argument\nmyObject = MyClass new\nmyObject printthree \"hello\"",
    "hello",
    // ---------------------------------------------------------------------------
    "MyClass = Class new\nMyClass answer:\n﹍﹍﹍﹍printthree (argument)\n﹍﹍﹍by:\n﹍﹍﹍﹍console print argument\nmyObject = MyClass new\nmyObject printthree \"hello\"",
    "hello",
    "MyClass = Class new\nMyClass answer:\n﹍﹍﹍printthree (argument)\n﹍﹍by:\n﹍﹍﹍console print argument\nmyObject = MyClass new\nmyObject printthree \"hello\"",
    "hello",
    // ---------------------------------------------------------------------------
    // particularly useful extra indentation for repeat
    "a=5\n\nrepeat forever:\n﹍if a==0:\n﹍﹍done\n﹍else:\n﹍﹍a=a - 1\nconsole print a",
    "0",
    // ---------------------------------------------------------------------------
    // you would NOT want to indent the if but you could
    "a=5\n\nrepeat forever:\n﹍if a==0:\n﹍﹍﹍done\n﹍﹍else:\n﹍﹍﹍a=a - 1\nconsole print a",
    "0",
    // ---------------------------------------------------------------------------
    "codeToBeRun ='\n﹍console print word\nmyList = '(1 2 3 4)\nfor each word in:\n﹍﹍myList\n﹍do:\n﹍﹍codeToBeRun eval",
    "1234",
    // ---------------------------------------------------------------------------
    "codeToBeRun ='\n﹍console print word\nmyList = 9\nfor each word in:\n﹍﹍myList\n﹍do:\n﹍﹍codeToBeRun eval",
    "! exception: for...each expects a list",
    // ---------------------------------------------------------------------------
    "MyClass = Class new\nmyObject = MyClass new\nconsole print myObject.someField\nmyObject.someField = 2\nconsole print myObject.someField",
    "nil2",
    // ---------------------------------------------------------------------------
    // simple example on how to implement a class variable
    // even though there is no special mechanism for them -
    // the classic "instantiations" counter.
    // We keep a "counter" object in MyClass.
    // When new objects are created from MyClass,
    // the class's instance variables are copied
    // (just the reference to them), so effectively
    // the counter is shared between MyClass and all its
    // instances.
    // Note how we could just directly use a number for the counter and
    // mutate it with something like "incrementInPlace", which mutates the
    // actual value of the number object, but here we choose the
    // other alternative, we don't change the value of the number itself, rather
    // we wrap the number into a "counter" object and give it a method to
    // swap-out the number with a new incremented number we get from
    // the result of "+ 1" invocation.
    "Counter = Class new\nCounter.counter = 0\n\nCounter answer:\n﹍﹍increment\n﹍by:\n﹍﹍self.counter = self.counter+1\n\nMyClass = Class new\nMyClass.instantiationsCounter = Counter new\n\nMyClass answer:\n﹍﹍whenNew\n﹍by:\n﹍﹍self.instantiationsCounter increment\n﹍﹍self\n\nMyClass answer:\n﹍﹍getCount\n﹍by:\n﹍﹍self.instantiationsCounter.counter\n\nconsole print MyClass getCount\n\nmyObject = MyClass new\nconsole print MyClass getCount\nconsole print myObject getCount\n\nmyObject2 = MyClass new\nconsole print MyClass getCount\nconsole print myObject getCount\nconsole print myObject2 getCount\n",
    "011222",
    "Counter = Class new\nCounter.counter = 0\n\nCounter answer:\n﹍﹍increment\n﹍by:\n﹍﹍@counter = @counter+1\n\nMyClass = Class new\nMyClass.instantiationsCounter = Counter new\n\nMyClass answer:\n﹍﹍whenNew\n﹍by:\n﹍﹍@instantiationsCounter increment\n﹍﹍@\n\nMyClass answer:\n﹍﹍getCount\n﹍by:\n﹍﹍@instantiationsCounter.counter\n\nconsole print MyClass getCount\n\nmyObject = MyClass new\nconsole print MyClass getCount\nconsole print myObject getCount\n\nmyObject2 = MyClass new\nconsole print MyClass getCount\nconsole print myObject getCount\nconsole print myObject2 getCount\n",
    "011222",
    // ---------------------------------------------------------------------------
    // because the field look-up mechanism, you can add a field to a class
    // at any time and it will affect all its objects (the ones already created
    // from it and the ones created from it after).
    // but of course as soon as an object changes the value, the object will
    // create the field in itself and stop "looking up the chain" (just like in
    // javascript).
    "Counter = Class new\nCounter.counter = 0\n\nCounter answer:\n﹍﹍increment\n﹍by:\n﹍﹍self.counter = self.counter+1\n\nMyClass = Class new\n\nmyObject = MyClass new\n\nMyClass.instantiationsCounter = Counter new\n\nMyClass answer:\n﹍﹍whenNew\n﹍by:\n﹍﹍self.instantiationsCounter increment\n﹍﹍self\n\nMyClass answer:\n﹍﹍getCount\n﹍by:\n﹍﹍self.instantiationsCounter.counter\n\nconsole print MyClass getCount\nconsole print myObject getCount\n\nmyObject2 = MyClass new\nconsole print MyClass getCount\nconsole print myObject getCount\nconsole print myObject2 getCount\n\nmyObject2.fieldAddedToObject2 = 2\n\nconsole print MyClass.fieldAddedToObject2\nconsole print myObject.fieldAddedToObject2\nconsole print myObject2.fieldAddedToObject2\n\nMyClass.fieldAddedToClass = 3\nconsole print MyClass.fieldAddedToClass\nconsole print myObject.fieldAddedToClass\nconsole print myObject2.fieldAddedToClass\n\nmyObject.fieldAddedToClass = 4\nconsole print MyClass.fieldAddedToClass\nconsole print myObject.fieldAddedToClass\nconsole print myObject2.fieldAddedToClass\n\nmyObject2.fieldAddedToClass = 5\nconsole print MyClass.fieldAddedToClass\nconsole print myObject.fieldAddedToClass\nconsole print myObject2.fieldAddedToClass\n\n",
    "00111nilnil2333343345",
    "Counter = Class new\nCounter.counter = 0\n\nCounter answer:\n﹍﹍increment\n﹍by:\n﹍﹍@counter++\n\nMyClass = Class new\n\nmyObject = MyClass new\n\nMyClass.instantiationsCounter = Counter new\n\nMyClass answer:\n﹍﹍whenNew\n﹍by:\n﹍﹍@instantiationsCounter increment\n﹍﹍@\n\nMyClass answer:\n﹍﹍getCount\n﹍by:\n﹍﹍@instantiationsCounter.counter\n\nconsole print MyClass getCount\nconsole print myObject getCount\n\nmyObject2 = MyClass new\nconsole print MyClass getCount\nconsole print myObject getCount\nconsole print myObject2 getCount\n\nmyObject2.fieldAddedToObject2 = 2\n\nconsole print MyClass.fieldAddedToObject2\nconsole print myObject.fieldAddedToObject2\nconsole print myObject2.fieldAddedToObject2\n\nMyClass.fieldAddedToClass = 3\nconsole print MyClass.fieldAddedToClass\nconsole print myObject.fieldAddedToClass\nconsole print myObject2.fieldAddedToClass\n\nmyObject.fieldAddedToClass = 4\nconsole print MyClass.fieldAddedToClass\nconsole print myObject.fieldAddedToClass\nconsole print myObject2.fieldAddedToClass\n\nmyObject2.fieldAddedToClass = 5\nconsole print MyClass.fieldAddedToClass\nconsole print myObject.fieldAddedToClass\nconsole print myObject2.fieldAddedToClass\n\n",
    "00111nilnil2333343345",
    // ---------------------------------------------------------------------------
    // compound assignments operators
    // ---------------------------------------------------------------------------
    "a = 1\na += a\nconsole print a",
    "2",
    "a = 1\nb = 2\na += b\nconsole print a",
    "3",
    "a = 1\nb = 2\na += b+1\nconsole print a",
    "4",
    // trick question
    "a = 1\nb = 2\na += console print b",
    "2",
    "a = 1\nb = 2\nconsole print a += b",
    "3",
    "a = 1\na *= 1\nconsole print a",
    "1",
    "a = 1\na *= 2\nconsole print a",
    "2",
    // ---------------------------------------------------------------------------
    // increment/decrement operators
    // ---------------------------------------------------------------------------
    "a = 1\na++\nconsole print a",
    "2",
    "a = 1\na++ + 1\nconsole print a",
    "2",
    "a = 1\na = a++ + 1\nconsole print a",
    "3",
    "a = 1\nconsole print a++",
    "2",
    "a = 1\na++ ++\nconsole print a",
    "2",
    "a = 1\nconsole print a++ ++",
    "3",
    "MyClass = Class new\nmyObject = MyClass new\nmyObject.someField = 2\nmyObject.someField += 2\nconsole print myObject.someField",
    "4",
    "MyClass = Class new\nmyObject = MyClass new\nmyObject.someField = 2\nconsole print myObject.someField += 2",
    "4",
    "MyClass = Class new\nmyObject = MyClass new\nmyObject.someField = 2\nmyObject.someField++\nconsole print myObject.someField",
    "3",
    "MyClass = Class new\nmyObject = MyClass new\nmyObject.someField = 2\nconsole print myObject.someField++",
    "3",
    "MyClass = Class new\nmyObject = MyClass new\nmyObject.someField = 2\nconsole print myObject.someField++ ++\nconsole print myObject.someField",
    "43",
    "myArray = '(1 2 3)\nmyArray[1]++\nconsole print myArray",
    "( 2 2 3 )",
    "myArray = '(1 2 3)\nconsole print myArray[1]++ ++\nconsole print myArray",
    "3( 2 2 3 )",
    "myArray = [1,2,3]\nconsole print myArray[1] += myArray[2]+myArray[3]\nconsole print myArray",
    "6( 6 2 3 )",
    "myArray = '(1 2 3)\nconsole print (myArray[1] eval) += myArray[2] eval +myArray[3] eval\n// notw how the first element of the array is unchanged\nconsole print myArray",
    "6( 1 2 3 )",
    "myArray = '(1 2 3)\nconsole print myArray[1]++",
    "2",
    "myArray = '(1 2 3)\nconsole print myArray[1]++ ++\nconsole print myArray[2]",
    "32",
    "a = []\na[5] = 1\nconsole print a",
    "( nil nil nil nil 1 )",
    // this shows how the ++ operator
    // CREATES a new object, so it creates
    // an entry in the object if it wasn't there
    "MyClass = Class new\nMyClass.count = 0\n\nmyObject = MyClass new\nmyObject2 = MyClass new\n\nconsole print MyClass.count // 0\nconsole print myObject.count // 0\nconsole print myObject2.count // 0\n\nMyClass.count++\n\nconsole print MyClass.count // 1\nconsole print myObject.count // 1\nconsole print myObject2.count // 1\n\nmyObject.count++\n\nconsole print MyClass.count // 1\nconsole print myObject.count // 2\nconsole print myObject2.count // 1\n\nmyObject2.count++\nmyObject2.count++\n\nconsole print MyClass.count // 1\nconsole print myObject.count // 2\nconsole print myObject2.count // 3\n\nMyClass.count++\n\nconsole print MyClass.count // 2\nconsole print myObject.count // 2\nconsole print myObject2.count // 3\n",
    "000111121123223",
    // ---------------------------------------------------------------------------
    // running with empty signature
    // FLTO
    "to sayHello: () do: (console print \"Hello\"); sayHello;",
    "Hello",
    // ---------------------------------------------------------------------------
    //    emojis!
    // ---------------------------------------------------------------------------
    "😁 = 4; console print 😁",
    "4",
    // ---------------------------------------------------------------------------
    "😁 =4;console print 😁",
    "4",
    // ---------------------------------------------------------------------------
    "😁=4;console print 😁",
    "4",
    // ---------------------------------------------------------------------------
    // here "print😁" is a single token, so there is no print happening
    "😁=4;console print😁",
    "! exception: message was not understood: ( print😁 )",
    // ---------------------------------------------------------------------------
    // FLTO

    // "nothing" signature
    "to 🚀:\n﹍console print \"launch!\"\n🚀",
    "launch!",
    // you can assign the "function" to a variable
    "🚀 = to rocket:\n﹍console print \" running without param!\"\n\n🚀",
    " running without param!",
    // you can assign then re-assign the variable
    // without triggering the function
    "🚀 = to rocket:\n﹍console print \" running without param!\"\n\n🚀 = 2\nconsole print 🚀",
    "2",
    "to 🚀:\n﹍console print \"launch!\"\n(🚀)",
    "launch!",
    "to 🚀:\n﹍console print \"launch!\"\n((((🚀))))",
    "launch!",
    // ---------------------------------------------------------------------------
    // you can assign arbitrary things to any token e.g. strings or numbers,
    // including objects which take the empty message
    // FLTO
    "to \"🚀\":\n﹍﹍withAParameter\n﹍do:\n﹍﹍console print \"running with a param.\"\n\n\"🚀\" withAParameter\n\nto \"🚀\":\n﹍console print \"running without params.\"\n\n\"🚀\"\n\"🚀\" withAParameter\n",
    "running with a param.running without params.running with a param.",
    // ---------------------------------------------------------------------------
    // string concatenation also with type conversion
    // ---------------------------------------------------------------------------
    "console print \"Hello \" + \"world!\"",
    "Hello world!",
    "console print \"Hello \" + \"world!\" + 2",
    "Hello world!2",
    "console print '(1+1)",
    "( 1 + 1 )",
    // here there is a concatenation of lists
    "console print '(1+1)+1",
    "( 1 + 1 1 )",
    // here there is a concatenation of strings
    "console print '(1+1) toString + 1",
    "( 1 + 1 )1",
    // it's the Javascript runtime doing this sum between number and boolean
    "console print 1 + true",
    "2",
    // ---------------------------------------------------------------------------
    // return
    // ---------------------------------------------------------------------------
    "to testingReturn:\n﹍console print \"start - \"\n﹍return 1+1\n﹍console print \"never reached\"\nconsole print testingReturn",
    "start - 2",
    "to testingReturn:\n﹍console print \"start - \"\n﹍return 1+1\n﹍console print \"never reached\"\ntestingReturn + 1",
    "start - ",
    "to testingReturn:\n﹍console print \"start - \"\n﹍return 1+1\n﹍console print \"never reached\"\nconsole print (testingReturn) + 1",
    "start - 3",
    "to testingReturn:\n﹍console print \"start - \"\n﹍return\n﹍console print \"never reached\"\nconsole print testingReturn",
    "start - nil",
    "to testingReturn:\n﹍console print \"start - \"\n﹍return\n﹍console print \"never reached\"\n(testingReturn 1 + 1) postfixPrint",
    "start - ! exception: message was not understood: ( 1 + 1 )",
    "to testingReturn:\n﹍repeat 2:\n﹍﹍console print 1\n﹍﹍console print 2\ntestingReturn\nconsole print \" the end.\"",
    "1212 the end.",
    "to testingReturn:\n﹍repeat 2:\n﹍﹍console print 1\n﹍﹍return\n﹍﹍console print 2\ntestingReturn\nconsole print \" the end.\"",
    "1 the end.",
    "nil 1 + 1",
    "! exception: message was not understood: ( 1 + 1 )",
    // ---------------------------------------------------------------------------
    // (in)equality comparisons
    // ---------------------------------------------------------------------------
    "console print 1 == 0",
    "false",
    "console print 1 == 1",
    "true",
    "console print 1.0 == 1",
    "true",
    "console print 0 == 0.0",
    "true",
    "console print 0.0 == 0.0",
    "true",
    "console print 1 == \"hello\"",
    "false",
    "console print \"hello\" == \"hello\"",
    "true",
    "console print \"hello\" == \"world\"",
    "false",
    "console print \"hello\" == true",
    "false",
    "console print false == false",
    "true",
    "console print false == 0",
    "false",
    "console print true == 0",
    "false",
    "console print true == 1",
    "false",
    "console print true == 1.0",
    "false",
    "console print true == 2",
    "false",
    "console print nil == nil",
    "true",
    "myList = '(1 2 3)\nmyList2 = '(1 2 3)\nconsole print myList == myList\nconsole print myList == myList2",
    "truefalse",
    "MyClass = Class new\nmyObject = MyClass new\nmyObject2 = MyClass new\nconsole print myObject == myObject\nconsole print myObject == myObject2",
    "truefalse",
    // ---------------------------------------------------------------------------
    // linked list
    // ---------------------------------------------------------------------------
    "console print console.nonExisting == nil",
    "true",
    "Node = Class new\n\nNode answer:\n﹍﹍initWith (item) (next)\n﹍by:\n﹍﹍@item = item\n﹍﹍console print \" adding item: \" + @item\n﹍﹍@next = next\n﹍﹍@\n\nLinkedList = Class new\n\nLinkedList answer:\n﹍﹍isEmpty\n﹍by:\n﹍﹍console print \" list is empty now? \" + (@head == nil)\n﹍﹍@head == nil\n\nLinkedList answer:\n﹍﹍append (item)\n﹍by:\n﹍﹍node = Node new initWith item nil\n﹍﹍console print \" 0 node is: \" + node\n﹍﹍console print \" 0 node has item: \" + node.item\n﹍﹍if @tail != nil:\n﹍﹍﹍console print \" 1 node is: \" + node\n﹍﹍﹍console print \" 1 node has item: \" + node.item\n﹍﹍﹍@tail.next = node\n﹍﹍﹍console print \" 2 node is: \" + node\n﹍﹍﹍console print \" 2 node has item: \" + node.item\n﹍﹍if @ isEmpty:\n﹍﹍﹍console print \" 3 node is: \" + node\n﹍﹍﹍console print \" 3 node has item: \" + node.item\n﹍﹍﹍@head = node\n﹍﹍if @ isEmpty:\n﹍﹍﹍console print \" this list should NOT be empty\"\n﹍﹍@tail = node\n\nmyLinkedList = LinkedList new\n\nmyLinkedList append \"Hello \"\nif myLinkedList isEmpty:\n﹍console print \" this list should NOT be empty\"\n\nmyLinkedList append \"World\"\n\nconsole print \" list contents: \"\nconsole print myLinkedList.head.item\nconsole print myLinkedList.head.next.item",
    " adding item: Hello  0 node is: [object of class \"Node\"] 0 node has item: Hello  1 node is: [object of class \"Node\"] 1 node has item: Hello  2 node is: [object of class \"Node\"] 2 node has item: Hello  list is empty now? true 3 node is: [object of class \"Node\"] 3 node has item: Hello  list is empty now? false list is empty now? false adding item: World 0 node is: [object of class \"Node\"] 0 node has item: World 1 node is: [object of class \"Node\"] 1 node has item: World 2 node is: [object of class \"Node\"] 2 node has item: World list is empty now? false list is empty now? false list contents: Hello World",
    // ---------------------------------------------------------------------------
    "evaluationsCounter",
    "EvaluationsCounter running the \"empty\" method // ",
    // the \"empty\" method is invoked multiple times as
    // the evaluationsCounter comes out as the
    // result of each parens...
    "(evaluationsCounter)",
    "EvaluationsCounter running the \"empty\" method // EvaluationsCounter running the \"empty\" method // ",
    // the "empty" method is invoked multiple times as
    // the evaluationsCounter comes out as the
    // result of each parens...
    "((((evaluationsCounter))))",
    "EvaluationsCounter running the \"empty\" method // EvaluationsCounter running the \"empty\" method // EvaluationsCounter running the \"empty\" method // EvaluationsCounter running the \"empty\" method // EvaluationsCounter running the \"empty\" method // ",
    // ---------------------------------------------------------------------------
    "console print 8 % 2",
    "0",
    "console print 7 % 2",
    "1",
    // ---------------------------------------------------------------------------

    // floor division operator à la python
    // (in python it's // but we use that for comments)
    "console print 9/_2",
    "4",
    "console print 9.0/_2.0",
    "4",
    "console print (0-11)/_3",
    "-4",
    "console print (0-11.0)/_3",
    "-4",
    // ---------------------------------------------------------------------------

    // Collatz
    "startingNumber = 97\nsteps = 0\n\nn = startingNumber\n\nrepeat forever:\n﹍console print n + \"-\"\n﹍if n==1:\n﹍﹍break\n﹍else:\n﹍﹍if 0==n%2:\n﹍﹍﹍n=n/2\n﹍﹍else:\n﹍﹍﹍n=1+n*3\n﹍﹍steps++\n\nconsole print \" steps: \" + steps\n",
    "97-292-146-73-220-110-55-166-83-250-125-376-188-94-47-142-71-214-107-322-161-484-242-121-364-182-91-274-137-412-206-103-310-155-466-233-700-350-175-526-263-790-395-1186-593-1780-890-445-1336-668-334-167-502-251-754-377-1132-566-283-850-425-1276-638-319-958-479-1438-719-2158-1079-3238-1619-4858-2429-7288-3644-1822-911-2734-1367-4102-2051-6154-3077-9232-4616-2308-1154-577-1732-866-433-1300-650-325-976-488-244-122-61-184-92-46-23-70-35-106-53-160-80-40-20-10-5-16-8-4-2-1- steps: 118",
    // using "common math" operator precedence
    // and associativity:
    "startingNumber = 97\nsteps = 0\n\nn = startingNumber\n\nrepeat forever:\n﹍console print n + \"-\"\n﹍if n==1:\n﹍﹍break\n﹍else:\n﹍﹍if n%2==0:\n﹍﹍﹍n=n/2\n﹍﹍else:\n﹍﹍﹍n=n*3+1\n﹍﹍steps++\n\nconsole print \" steps: \" + steps\n",
    "97-292-146-73-220-110-55-166-83-250-125-376-188-94-47-142-71-214-107-322-161-484-242-121-364-182-91-274-137-412-206-103-310-155-466-233-700-350-175-526-263-790-395-1186-593-1780-890-445-1336-668-334-167-502-251-754-377-1132-566-283-850-425-1276-638-319-958-479-1438-719-2158-1079-3238-1619-4858-2429-7288-3644-1822-911-2734-1367-4102-2051-6154-3077-9232-4616-2308-1154-577-1732-866-433-1300-650-325-976-488-244-122-61-184-92-46-23-70-35-106-53-160-80-40-20-10-5-16-8-4-2-1- steps: 118",
    // ---------------------------------------------------------------------------

    // 20 digits of pi using Jeremy Gibbons's unbounded spigot
    // streaming algorithm. Can't go beyond 20 because
    // Javascript's Number precision. (only a bigint
    // representation could go on "forever")
    "q = 1\nr = 0\nt = 1\nk = 1\nn = 3\nl = 3\nrepeat 82:\n﹍if ((r-t)+4*q) < (n*t):\n﹍﹍console print n\n﹍﹍nr = 10*(r-n*t)\n﹍﹍n = ((10*(r+3*q)) /_ t) - 10*n\n﹍﹍q *= 10\n﹍﹍r = nr\n﹍else:\n﹍﹍nr = (r+2*q) * l\n﹍﹍nn = ((q*(2+7*k))+r*l) /_ (t*l)\n﹍﹍q *= k\n﹍﹍t *= l\n﹍﹍l += 2\n﹍﹍k += 1\n﹍﹍n = nn\n﹍﹍r = nr",
    "31415926535897932384",
    // using "common math" operator precedence
    // and associativity:
    "q = 1\nr = 0\nt = 1\nk = 1\nn = 3\nl = 3\nrepeat 82:\n﹍if 4*q+r-t < n*t:\n﹍﹍console print n\n﹍﹍nr = 10*(r-n*t)\n﹍﹍n = 10*(3*q+r) /_ t - 10*n\n﹍﹍q *= 10\n﹍﹍r = nr\n﹍else:\n﹍﹍nr = (2*q+r) * l\n﹍﹍nn = (q*(7*k+2)+r*l) /_ (t*l)\n﹍﹍q *= k\n﹍﹍t *= l\n﹍﹍l += 2\n﹍﹍k += 1\n﹍﹍n = nn\n﹍﹍r = nr",
    "31415926535897932384",
    // ---------------------------------------------------------------------------
    // ranges
    "for each number in:\n﹍﹍3...10\n﹍do:\n﹍﹍console print number",
    "345678910",
    "for each number in:\n﹍﹍10...3\n﹍do:\n﹍﹍console print number",
    "109876543",
    "for each number in:\n﹍﹍3...3\n﹍do:\n﹍﹍console print number\nconsole print \"the end.\"",
    "3the end.",
    // ---------------------------------------------------------------------------
    // homoiconicity
    "codeToBeRun ='\n﹍console print 1+2\ncodeToBeRun eval",
    "3",
    "codeToBeRun ='\n﹍console print 1+2\nconsole print codeToBeRun[4]",
    "+",
    "codeToBeRun ='\n﹍console print 1+2\ncodeToBeRun[4] = '-\ncodeToBeRun eval",
    "-1",
    "codeToBeRun ='\n﹍console print 1+2\n\nMyClass=Class new\nMyClass.counter = nil\nMyClass answer:\n﹍﹍printOperation\n﹍by:\n﹍﹍codeToBeRun eval\nmyObject=MyClass new\nmyObject printOperation\ncodeToBeRun[4] = '-\nmyObject printOperation",
    "3-1",
    // ---------------------------------------------------------------------------
    // signatures in "answer" and "to" are not evaluated,
    // so they can't be closed in read-only mode (see closures)
    // so there can't be nasty "substitutions" in the signatures
    "//withName = 2\nname = \"Flora\"\n\nMyClass = Class new\nMyClass answer:\n﹍﹍withName (name)\n﹍by:\n﹍﹍console print \"Hello \"\n﹍﹍console print name\nmyObject = MyClass new\nmyObject withName \"Dave\"",
    "Hello Dave",
    "withName = 2\nname = \"Flora\"\n\nMyClass = Class new\nMyClass answer:\n﹍﹍withName (name)\n﹍by:\n﹍﹍console print \"Hello \"\n﹍﹍console print name\nmyObject = MyClass new\nmyObject withName \"Dave\"",
    "Hello Dave",
    "//withName = 2\nname = \"Flora\"\nto sayHello:\n﹍﹍withName (name)\n﹍do:\n﹍﹍console print \"Hello \"\n﹍﹍console print name\nsayHello withName \"Dave\"",
    "Hello Dave",
    "withName = 2\nname = \"Flora\"\nto sayHello:\n﹍﹍withName (name)\n﹍do:\n﹍﹍console print \"Hello \"\n﹍﹍console print name\nsayHello withName \"Dave\"",
    "Hello Dave",
    // ---------------------------------------------------------------------------
    // class names
    "console print \"a String object\".class",
    "[class \"String\" (an object of class Class)]",
    "console print \"a String object\".class.class",
    "[class \"Class\" (an object of class Class)]",
    "console print \"a String object\".class.class.class",
    "[class \"Class\" (an object of class Class)]",
    "console print \"a String object\".class.class.class.class.class.class.class.class",
    "[class \"Class\" (an object of class Class)]",
    "console print String == \"a String object\".class",
    "true",
    "console print Number == \"a String object\".class",
    "false",
    "console print String == 9.class",
    "false",
    "console print Number == 9.class",
    "true",
    "console print String == ('(some list items)).class",
    "false",
    "console print List == ('(some list items)).class",
    "true",
    "MyClass1 = Class new\nMyClass2 = Class new\n\nconsole print MyClass1 == MyClass2",
    "false",
    "MyClass1 = Class new\nMyClass2 = Class new\n\nconsole print MyClass1 == MyClass1",
    "true",
    "MyClass1 = Class new\nMyClass2 = Class new\n\nconsole print MyClass2 == MyClass2",
    "true",
    "MyClass1 = Class new\nmyObject1 = MyClass1 new\n\nconsole print MyClass1 == myObject1.class",
    "true",
    "MyClass1 = Class new\nmyObject1 = MyClass1 new\n\nMyClass2 = Class new\nmyObject2 = MyClass2 new\n\nconsole print MyClass1 == myObject2.class",
    "false",
    "MyClass1 = Class new\nmyObject1 = MyClass1 new\n\nMyClass2 = Class new\nmyObject2 = MyClass2 new\n\nconsole print MyClass1 == myObject2.class",
    "false",
    "MyClass1 = Class new\nmyObject1 = MyClass1 new\n\nconsole print myObject1.class == myObject1.class",
    "true",
    "MyClass1 = Class new\nmyObject1 = MyClass1 new\n\nMyClass2 = Class new\nmyObject2 = MyClass2 new\n\nconsole print myObject1.class == myObject2.class",
    "false",
    "console print Number.class",
    "[class \"Class\" (an object of class Class)]",
    "console print Number == \"a String object\".class",
    "false",
    "console print Number.class == \"a String object\".class.class",
    "true",
    "console print Number.class.class == \"a String object\".class.class.class",
    "true",
    "console print Number.class.class.class.class == \"a String object\".class.class.class.class.class",
    "true",
    // ---------------------------------------------------------------------------
    // primitive types checks
    "MyClass = Class new\nmyObject = MyClass new\n\nconsole print 6 isPrimitiveType\nconsole print 6.class isPrimitiveType\nconsole print true isPrimitiveType\nconsole print true.class isPrimitiveType\nconsole print \"hey\" isPrimitiveType\nconsole print \"hey\".class isPrimitiveType\nconsole print myObject isPrimitiveType\nconsole print myObject.class isPrimitiveType\nconsole print MyClass isPrimitiveType\nconsole print MyClass.class isPrimitiveType",
    "truetruetruetruetruetruefalsetruetruetrue",
    // ---------------------------------------------------------------------------
    // calling an object with empty message, when the object doesn't respond to
    // empty message: the following statements are executed
    "to 🚀:\n﹍﹍withAParameter\n﹍do:\n﹍﹍console print \"running with a param.\"\n🚀\nconsole print 1+1\nconsole print 🚀",
    "2[object of class \"Class_of_🚀\"]",
    // ---------------------------------------------------------------------------
    // assigning a function to a var and then running it from there.
    // This looks like HOF but it's really an object being assigned.
    "to 🚀:\n﹍﹍(withAParameter)\n﹍do:\n﹍﹍\" running with param \" + withAParameter\nmyFunc = 🚀\nconsole print 🚀 1\nconsole print myFunc 2",
    " running with param 1 running with param 2",
    // ---------------------------------------------------------------------------
    // factorial using FLTo
    "to factorial:\n﹍﹍(n)\n﹍do:\n﹍﹍if n == 0:\n﹍﹍﹍return 1\n﹍﹍else:\n﹍﹍﹍return n * factorial (n - 1)\n\nconsole print factorial 3",
    "6",
    // ---------------------------------------------------------------------------
    // factorial using FLTo and using "if" as an expression
    "to factorial:\n﹍﹍(n)\n﹍do:\n﹍﹍if n == 0:\n﹍﹍﹍1\n﹍﹍else:\n﹍﹍﹍n * factorial (n - 1)\n\nconsole print factorial 3",
    "6",
    // ---------------------------------------------------------------------------
    "Number answer:\n﹍﹍factorial\n﹍by:\n﹍﹍if self == 0:\n﹍﹍﹍return 1\n﹍﹍else:\n﹍﹍﹍(self - 1) factorial * self\nconsole print 3 factorial",
    "6",
    "Number answer:\n﹍﹍factorial\n﹍by:\n﹍﹍if self == 0:\n﹍﹍﹍return 1\n﹍﹍else:\n﹍﹍﹍return (self - 1) factorial * self\nconsole print 3 factorial",
    "6",
    "Number answer:\n﹍﹍factorial\n﹍by:\n﹍﹍if self == 0:\n﹍﹍﹍1\n﹍﹍else:\n﹍﹍﹍(self - 1) factorial * self\nconsole print 3 factorial",
    "6",
    // ---------------------------------------------------------------------------
    // override class default name. class names are really just for more
    // meaningful printouts.
    "MyClass = Class new named \"My Class\"\nconsole print MyClass\nmyObject = MyClass new\nconsole print myObject",
    "[class \"My Class\" (an object of class Class)][object of class \"My Class\"]",
    // ---------------------------------------------------------------------------
    // pythagorean triplets
    "for each c in: (2...9) do:\n﹍for each b in: (2...c-1) do:\n﹍﹍for each a in: (1...b-1) do:\n﹍﹍﹍if ((a * a) + (b * b)) == (c * c):\n﹍﹍﹍﹍console print \"a: \" + a + \" b: \" + b + \" c: \" + c",
    "a: 3 b: 4 c: 5",
    // ---------------------------------------------------------------------------
    // fizzbuzz
    "for each i in: (1...99) do:\n﹍if 0 == i % 15:\n﹍﹍console print \"FizzBuzz \"\n﹍else if 0 == i % 3:\n﹍﹍console print \"Fizz \"\n﹍else if 0 == i % 5:\n﹍﹍console print \"Buzz \"\n﹍else:\n﹍﹍console print i + \" \"",
    "1 2 Fizz 4 Buzz Fizz 7 8 Fizz Buzz 11 Fizz 13 14 FizzBuzz 16 17 Fizz 19 Buzz Fizz 22 23 Fizz Buzz 26 Fizz 28 29 FizzBuzz 31 32 Fizz 34 Buzz Fizz 37 38 Fizz Buzz 41 Fizz 43 44 FizzBuzz 46 47 Fizz 49 Buzz Fizz 52 53 Fizz Buzz 56 Fizz 58 59 FizzBuzz 61 62 Fizz 64 Buzz Fizz 67 68 Fizz Buzz 71 Fizz 73 74 FizzBuzz 76 77 Fizz 79 Buzz Fizz 82 83 Fizz Buzz 86 Fizz 88 89 FizzBuzz 91 92 Fizz 94 Buzz Fizz 97 98 Fizz ",
    // ---------------------------------------------------------------------------
    // Matrix class: initialisation from List of Lists, transposition,
    // multiplication, printing.
    "Matrix = Class new\nMatrix answer:\n﹍﹍initWith (array)\n﹍by:\n﹍﹍@array = array\n﹍﹍@rows = array length\n﹍﹍@columns = array[1] length\n\nMatrix answer:\n﹍﹍print\n﹍by:\n﹍﹍console print \"[\"\n﹍﹍for i from 1 to @rows:\n﹍﹍﹍console print \"[\"\n﹍﹍﹍for j from 1 to @columns:\n﹍﹍﹍﹍console print @array[i][j]\n﹍﹍﹍﹍if j != @columns:\n﹍﹍﹍﹍﹍console print \",\"\n﹍﹍﹍console print \"]\"\n﹍﹍﹍if i != @rows:\n﹍﹍﹍﹍console print \",\"\n﹍﹍console print \"]\"\n\nMatrix answer:\n﹍﹍transpose\n﹍by:\n﹍﹍transposed = []\n﹍﹍for i from 1 to @columns:\n﹍﹍﹍transposed[i] = []\n﹍﹍﹍for j from 1 to @rows:\n﹍﹍﹍﹍transposed[i][j] = @array[j][i]\n﹍﹍Matrix new initWith transposed\n\nMatrix answer:\n﹍﹍multiply (other)\n﹍by:\n﹍﹍result = []\n﹍﹍for i from 1 to @rows:\n﹍﹍﹍result[i] = []\n﹍﹍﹍for j from 1 to other.columns:\n﹍﹍﹍﹍sum = 0\n﹍﹍﹍﹍for k from 1 to @columns:\n﹍﹍﹍﹍﹍sum = sum + @array[i][k] * other.array[k][j]\n﹍﹍﹍﹍result[i][j] = sum\n﹍﹍Matrix new initWith result\n\nmyMatrix = Matrix new initWith [[1,2,3],[4,5,6],[7,8,9]]\nmyMatrix print\nconsole print \" \"\nmyMatrix transpose print\n\nconsole print \" \"\na = Matrix new initWith [[1,2],[3,4]]\nb = Matrix new initWith [[-3,-8,3],[-2,1,4]]\n(a multiply b) print\n",
    "[[1,2,3],[4,5,6],[7,8,9]] [[1,4,7],[2,5,8],[3,6,9]] [[-7,-6,11],[-17,-20,25]]",
    // ---------------------------------------------------------------------------
    // a macro
    "a = '( (1...2) (console print x + y + z) x y z)\nconsole print a length\nnumParams = a length - 2\nconsole print numParams\n\nbodies = []\n\nfor each number in:\n﹍﹍1...numParams\n﹍do:\n﹍﹍bodies[number] = []\n﹍﹍bodies[number] = bodies[number] + 'for + 'each + a[2+number] + 'in + ': + a[1]\n﹍﹍bodies[number] = bodies[number] + 'do + ':\n\nbodies[numParams] = bodies[numParams] + a[2]\nconsole print bodies\n\nconsole print \" ---------- \"\nfor each number in:\n﹍﹍numParams-1...1\n﹍do:\n﹍﹍bodies[number] = bodies[number] + bodies[number+1]\n\nconsole print \" ---- \"\nconsole print bodies\n\ntoRun = bodies[1]\nconsole print \" ---- \"\nconsole print toRun\n\ntoRun eval",
    '53( ( for each x in : ( 1 ... 2 ) do : ) ( for each y in : ( 1 ... 2 ) do : ) ( for each z in : ( 1 ... 2 ) do : ( console print x + y + z ) ) ) ----------  ---- ( ( for each x in : ( 1 ... 2 ) do : ( for each y in : ( 1 ... 2 ) do : ( for each z in : ( 1 ... 2 ) do : ( console print x + y + z ) ) ) ) ( for each y in : ( 1 ... 2 ) do : ( for each z in : ( 1 ... 2 ) do : ( console print x + y + z ) ) ) ( for each z in : ( 1 ... 2 ) do : ( console print x + y + z ) ) ) ---- ( for each x in : ( 1 ... 2 ) do : ( for each y in : ( 1 ... 2 ) do : ( for each z in : ( 1 ... 2 ) do : ( console print x + y + z ) ) ) )34454556',
    // ---------------------------------------------------------------------------
    // same macro, used more cleanly as a keyword
    "to nestedRepeat:\n﹍﹍(rangeBodyAndVars)\n﹍do:\n﹍﹍accessUpperContext\n﹍﹍numParams = rangeBodyAndVars length - 2\n﹍﹍body = rangeBodyAndVars[2]\n﹍﹍range =  rangeBodyAndVars[1]\n﹍﹍\n﹍﹍bodies = []\n﹍﹍\n﹍﹍for each number in:\n﹍﹍﹍﹍1...numParams\n﹍﹍﹍do:\n﹍﹍﹍﹍bodies[number] = []\n﹍﹍﹍﹍bodies[number] = bodies[number] + 'for + 'each + rangeBodyAndVars[2+number] + 'in + ': + range\n﹍﹍﹍﹍bodies[number] = bodies[number] + 'do + ':\n﹍﹍\n﹍﹍bodies[numParams] = bodies[numParams] + body\n﹍﹍\n﹍﹍for each number in:\n﹍﹍﹍﹍numParams-1...1\n﹍﹍﹍do:\n﹍﹍﹍﹍bodies[number] = bodies[number] + bodies[number+1]\n﹍﹍\n﹍﹍bodies[1] eval\n\nnestedRepeat '( (1...2) (console print x + y + z) x y z)",
    "34454556",
    // ---------------------------------------------------------------------------
    "to ackermann:\n﹍﹍(m)(n)\n﹍do:\n﹍﹍if m == 0:\n﹍﹍﹍n + 1\n﹍﹍else if m > 0 and n == 0:\n﹍﹍﹍ackermann m - 1 1\n﹍﹍else:\n﹍﹍﹍ackermann m - 1 ackermann m n - 1\nconsole print \" \" + ackermann 0 5\nconsole print \" \" + ackermann 0 6\nconsole print \" \" + ackermann 1 4\nconsole print \" \" + ackermann 1 5\nconsole print \" \" + ackermann 2 3\nconsole print \" \" + ackermann 2 4",
    " 6 7 6 7 9 11",
    // ---------------------------------------------------------------------------
    // Towers of Hanoi
    // checked solution at:
    // http://zylla.wipos.p.lodz.pl/games/hanoi4e.html
    "pegsNames = [\"L\",\"M\",\"R\"]\nto hanoi:\n﹍﹍(ndisks)(start_peg)(end_peg)\n﹍do:\n﹍﹍if start_peg == nil:\n﹍﹍﹍start_peg = 1\n﹍﹍﹍end_peg = 3\n﹍﹍if ndisks != 0:\n﹍﹍﹍staging_peg = 1 + 2 + 3 - start_peg - end_peg\n﹍﹍﹍hanoi ndisks-1 start_peg staging_peg\n﹍﹍﹍console print \" / Move disk \" + ndisks + \" from peg \" + pegsNames[start_peg] + \" to \" + pegsNames[end_peg]\n﹍﹍﹍hanoi ndisks-1 staging_peg end_peg\n \nhanoi 4 nil nil",
    " / Move disk 1 from peg L to M / Move disk 2 from peg L to R / Move disk 1 from peg M to R / Move disk 3 from peg L to M / Move disk 1 from peg R to L / Move disk 2 from peg R to M / Move disk 1 from peg L to M / Move disk 4 from peg L to R / Move disk 1 from peg M to R / Move disk 2 from peg M to L / Move disk 1 from peg R to L / Move disk 3 from peg M to R / Move disk 1 from peg L to M / Move disk 2 from peg L to R / Move disk 1 from peg M to R",
    // ---------------------------------------------------------------------------
    // leap year and some variants (rephrasing the logic tests)
    "to leap:\n﹍﹍(y)\n﹍do:\n﹍﹍y%4==0 and (y<1582 or y%400==0 or y%100!=0)\n\nfor each year in:\n﹍﹍[2400, 2012, 2000, 1600, 1500, 1400]\n﹍do:\n﹍﹍console print leap year\n\nconsole print \" \"\n\nfor each year in:\n﹍﹍[2100, 2014, 1900, 1800, 1700, 1499]\n﹍do:\n﹍﹍console print leap year\n",
    "truetruetruetruetruetrue falsefalsefalsefalsefalsefalse",
    "to leap:\n﹍﹍(y)\n﹍do:\n﹍﹍0==y%4 and (y<1582 or 0==y%400 or 0!=y%100)\n\nfor each year in:\n﹍﹍[2400, 2012, 2000, 1600, 1500, 1400]\n﹍do:\n﹍﹍console print leap year\n\nconsole print \" \"\n\nfor each year in:\n﹍﹍[2100, 2014, 1900, 1800, 1700, 1499]\n﹍do:\n﹍﹍console print leap year\n",
    "truetruetruetruetruetrue falsefalsefalsefalsefalsefalse",
    "to leap:\n﹍﹍(y)\n﹍do:\n﹍﹍y%4==0 and not (y%100==0 and y>1581 and y%400!=0)\n\nfor each year in:\n﹍﹍[2400, 2012, 2000, 1600, 1500, 1400]\n﹍do:\n﹍﹍console print leap year\n\nconsole print \" \"\n\nfor each year in:\n﹍﹍[2100, 2014, 1900, 1800, 1700, 1499]\n﹍do:\n﹍﹍console print leap year\n",
    "truetruetruetruetruetrue falsefalsefalsefalsefalsefalse",
    "to leap:\n﹍﹍(y)\n﹍do:\n﹍﹍0==y%4 and not (0==y%100 and y>1581 and 0!=y%400)\n\nfor each year in:\n﹍﹍[2400, 2012, 2000, 1600, 1500, 1400]\n﹍do:\n﹍﹍console print leap year\n\nconsole print \" \"\n\nfor each year in:\n﹍﹍[2100, 2014, 1900, 1800, 1700, 1499]\n﹍do:\n﹍﹍console print leap year\n",
    "truetruetruetruetruetrue falsefalsefalsefalsefalsefalse",
    // ---------------------------------------------------------------------------
    "to aToObjectFunction:\n﹍for each word in:\n﹍﹍﹍'(1 + 1)\n﹍﹍do:\n﹍﹍﹍console print word\n\naToObjectFunction",
    "1+1"
  ];

  /*
   * You can't mention a "@" (or "self") in this way, you'll
   * get an infinite loop, as "@" (or "self") will be evaluated and
   * run the empty method which will mention "@" (or "self"), which
   * will be evaluated... forever in this case.
  """
  to 🚀:
  ﹍console print "launch!"
  ﹍@
  🚀
  """
  "launch!"
   */
  /*
   * ---------------------------------------------------------------------------
  """
  foo = 3
  things =' (foo ('foo) 2)
  things[0] print
  things[1] print
  (things[1] eval) print
  ((things[1] eval) eval) print
  (things[1] eval) ← " bar"
  foo print
  ((things[1] eval) eval) print
  things[2] print
  2 = 10
  things[1+1] print
  things =' (foo ('foo) 2)
  things[1+1] print
  """
  "3( ' foo )foo3 bar bar2210"

   * ---------------------------------------------------------------------------
  """
  foo = 3
  things =' ()
  things = things+foo
  console print things
  things[0] print
  " // " print
  things =' ()
  things = things+'foo
  console print things
  things[0] print
  " // " print
  things =' ()
  things = things+'('foo)
  console print things
  things[0] print
  """
  "( 3 )3 // ( foo )3 // ( ( ' foo ) )( ' foo )"
   */
  /*
  tests = [
  ]
  */
  Fizzylogo.init();

  OKs = 0;

  FAILs = 0;

  for (i = j = 0, ref = tests.length; j < ref; i = j += 2) {
    // use reset() instead of quickReset()
    // every now and then to
    // check that the tests still work when
    // there is a deeper clean of the
    // environment
    //reset()
    quickReset();
    [testBody, testResult] = tests.slice(i, +(i + 1) + 1 || 9e9);
    testBodyMultiline = testBody.replace(/\n/g, ' ⏎ ');
    log("starting test: " + (i / 2 + 1) + ": " + testBodyMultiline);
    run(testBody);
    log("final return: " + ((ref1 = outerMostContext.returned) != null ? ref1.value : void 0));
    if (rWorkspace.environmentPrintout + rWorkspace.environmentErrors === testResult) {
      OKs++;
      log("...test " + (i / 2 + 1) + " OK, obtained: " + rWorkspace.environmentPrintout + rWorkspace.environmentErrors);
    } else {
      FAILs++;
      log("...test " + (i / 2 + 1) + " FAIL, test: " + testBodyMultiline + " obtained: " + rWorkspace.environmentPrintout + rWorkspace.environmentErrors + " expected: " + testResult);
    }
  }

  log("all tests done. obtained " + OKs + " OKs and " + FAILs + " FAILs");

}).call(this);
